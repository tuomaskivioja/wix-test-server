type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition$1<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition$1<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition$1<Payload, Type>;
type EventHandler$1<T extends EventDefinition$1> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition$1<T extends EventDefinition$1<any, string>> = (handler: EventHandler$1<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> = NonNullable<
// Wrap in `NonNullable` to strip away the `undefined` type from the produced union.
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key since the condition passes.
		? Key
	// Discard this key since the condition fails.
		: never;

	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base]
>;

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition$1<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition$1<any> ? BuildEventDefinition$1<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

/** Information about the pricing plan. */
interface Plan {
    /**
     * Plan ID.
     * @readonly
     */
    _id?: string;
    /** Plan name. */
    name?: string | null;
    /** Plan description. */
    description?: string | null;
    /**
     * List of text strings that promote what is included with this plan.
     *
     * For example, "Plenty of parking" or "Free gift on your birthday".
     */
    perks?: StringList;
    /** Plan price, payment schedule, and expiration. */
    pricing?: Pricing;
    /** Whether the plan is public (visible to site visitors and members). */
    public?: boolean | null;
    /**
     * Whether the plan is archived. Archived plans are not visible and can't be purchased anymore, but existing purchases remain in effect.
     * @readonly
     */
    archived?: boolean;
    /**
     * Whether the plan is marked as primary. If `true`, the plan is highlighted on the site with a custom ribbon.
     *
     * Default: `false`.
     * @readonly
     */
    primary?: boolean;
    /**
     * Whether the plan has any orders (including pending and unpaid orders).
     * @readonly
     */
    hasOrders?: boolean;
    /**
     * Date plan was created.
     * @readonly
     */
    _createdDate?: Date;
    /**
     * Date plan was last updated.
     * @readonly
     */
    _updatedDate?: Date;
    /**
     * URL-friendly version of plan name. Unique across all plans in the same site.
     * @readonly
     */
    slug?: string | null;
    /**
     * Number of times the same buyer can purchase the plan. Currently limited to support:
     * - Empty value or a value of `0`, meaning no limitation.
     * - Value of `1`, meaning limited to one purchase per buyer.
     */
    maxPurchasesPerBuyer?: number | null;
    /**
     * Whether the buyer can start the plan at a later date.
     *
     * Default: `false`.
     *
     */
    allowFutureStartDate?: boolean | null;
    /**
     * Whether the buyer is allowed to cancel their plan. If `false`, calling the [`requestCancellation()`](https://www.wix.com/velo/reference/wix-pricing-plans-v2/orders/requestcancellation) function returns an error.
     *
     * Default: `true`.
     *
     */
    buyerCanCancel?: boolean | null;
    /** Any terms and conditions that apply to the plan. This information will be displayed during checkout. */
    termsAndConditions?: string | null;
    /** ID of the form associated with the plan at checkout. */
    formId?: string | null;
}
/** This wrapper type exist in order to distinguish an empty string list from no list at all in update requests. */
interface StringList {
    values?: string[];
}
/** Plan pricing information. Includes the price of the plan and payment details. */
interface Pricing extends PricingPricingModelOneOf {
    /**
     * Pricing model indicating that the plan has recurring payments.
     *
     * Note: This type of subscription is not a "Wix subscription," which encompasses various types of subscriptions, such as Wix Stores subscriptions, Wix invoice subscriptions, and *all* pricing plan models.
     */
    subscription?: Recurrence;
    /** Pricing model indicating a single payment per cycle and the length of the cycle. The cycle is the duration of the plan, not a payment cycle. */
    singlePaymentForDuration?: Duration;
    /** Pricing model indicating the plan is paid in one single payment. The plan is valid until canceled.   */
    singlePaymentUnlimited?: boolean | null;
    /** Amount for a single payment. For subscriptions, this is the amount to pay each payment cycle and it is required. For plans that are not recurring plans, it is the single payment amount for the whole subscription.  */
    price?: Money;
    /** Free trial period for the plan in days. Available only for recurring plans, meaning plans whose pricing model is `subscription`. Set to `0` to remove the free trial.  */
    freeTrialDays?: number | null;
}
/** @oneof */
interface PricingPricingModelOneOf {
    /** Plan has recurring payments. */
    subscription?: Recurrence;
    /** One time payment, plan is valid for the specified duration. */
    singlePaymentForDuration?: Duration;
    /** One time payment, plan is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
}
/** An object specifying how often and for how long payments recur (may be forever). */
interface Recurrence {
    /** Length of one payment cycle. For example, 1 month to have monthly payments. Multiply `cycleDuration`'s `count` by `cycleCount` to get the subscription duration. Currently, only a value of `1` is supported.  */
    cycleDuration?: Duration;
    /**
     * Amount of payment cycles the subscription is valid for.
     *
     * `0` for unlimited plans or for plans that are valid until canceled.
     */
    cycleCount?: number | null;
}
/** A duration expressed in number of time units. */
interface Duration {
    /** Number of days days, months, weeks, or years in a single payment cycle. Currently limited to support only `1`.  */
    count?: number | null;
    /** Unit of time for the cycle duration. */
    unit?: PeriodUnit;
}
declare enum PeriodUnit {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface Money {
    /** Monetary amount. Decimal string with a period as a decimal separator. For example, `'3.99'`. Cannot be a negative value.   */
    value?: string;
    /**
     * Currency code. Three-letter currency code in
     * [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format. For example, `'USD'`.
     */
    currency?: string;
}
interface FeeConfig {
    /** Fee configuration. */
    fee?: Fee;
    /** The time this fee will be charged */
    appliedAt?: AppliedAt;
}
interface Fee {
    /** Fee name */
    name?: string;
    /** Amount of fee to be charged */
    amount?: string;
}
declare enum AppliedAt {
    UNKNOWN_CHARGE_EVENT = "UNKNOWN_CHARGE_EVENT",
    /** Will charge the fee on first payment. If order has a free trial meaning it will charge after the free trial. */
    FIRST_PAYMENT = "FIRST_PAYMENT"
}
interface ListPublicPlansRequest {
    /**
     * Number of pricing plans to list.
     *
     * Default: `75`.
     */
    limit?: number | null;
    /**
     * Number of pricing plans to skip.
     *
     * Default: `0`.
     */
    offset?: number | null;
    /** IDs of public plans to list. If non-existent IDs are specified, they are ignored and don't cause errors. If no IDs are specified, all public are listed according to the [order](#arrangeplans) displayed in the Dashboard. You can pass a maximum of 100 IDs.  */
    planIds?: string[];
}
interface ListPublicPlansResponse {
    /** List of public pricing plans. */
    plans?: PublicPlan[];
    /** Details on the paged set of public pricing plans returned.  */
    pagingMetadata?: PagingMetadataV2;
}
/** Public plan entity containing information about the pricing plan. Can be read by any site member or visitor. */
interface PublicPlan {
    /** Plan ID. */
    _id?: string;
    /** Plan name. */
    name?: string | null;
    /** Plan description. */
    description?: string | null;
    /** What is included with this plan (e.g., 1 weekly entrance to a specific class). */
    perks?: StringList;
    /** Plan price, payment schedule, and expiration. */
    pricing?: Pricing;
    /** Whether the plan is marked as primary. */
    primary?: boolean;
    /** Date plan was created. */
    _createdDate?: Date;
    /** Date plan was last updated. */
    _updatedDate?: Date;
    /** URL-friendly version of plan name. Unique across all plans in the same site. */
    slug?: string | null;
    /** Number of times the same buyer can purchase the plan. An empty value or a value of zero means no limitation. */
    maxPurchasesPerBuyer?: number | null;
    /** Whether the buyer can start the plan at a later date. Defaults to false. */
    allowFutureStartDate?: boolean | null;
    /** Whether the buyer is allowed to cancel their plan. Defaults to false. */
    buyerCanCancel?: boolean | null;
    /** Any terms and conditions that apply to the plan. This information will be displayed during checkout. */
    termsAndConditions?: string | null;
    /** ID of the form associated with the plan at checkout. */
    formId?: string | null;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface QueryPublicPlansRequest {
    /** Query */
    query?: QueryV2;
}
interface QueryV2 {
    /** A filter object. See [supported fields and operators](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/filter-and-sort#wix-pricing-plans_pricing-plans_plans_filter-and-sort_query-public-plans) */
    filter?: Record<string, any> | null;
    /** Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}] */
    sort?: Sorting[];
    /** Pointer to page of results using offset. Can not be used together with 'cursorPaging' */
    paging?: Paging;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface QueryPublicPlansResponse {
    /** List of public pricing plans that match the specified query. */
    plans?: PublicPlan[];
    /** Object containing paging-related data (number of plans returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
interface GetPlanRequest {
    /** Plan ID. */
    _id: string;
}
interface GetPlanResponse {
    /** Pricing plan info.  */
    plan?: Plan;
}
interface ListPlansRequest {
    /**
     * Archived filter.
     *
     * Default: `ACTIVE` (not archived).
     */
    archived?: ArchivedFilter;
    /**
     * Visibility filter.
     *
     * Default: `PUBLIC_AND_HIDDEN` (meaning, both public and hidden plans are listed).
     *
     */
    public?: PublicFilter;
    /**
     * Number of pricing plans to list.
     *
     * Default: `75`.
     */
    limit?: number | null;
    /**
     * Number of pricing plans to skip.
     *
     * Default: `0`.
     */
    offset?: number | null;
    /** IDs of plans to list. If non-existent IDs are specified, they are ignored and don't cause errors. If no IDs are specified, all public and hidden plans (based on `options`) are listed according to the [order](#arrangeplans) displayed in the Dashboard. You can pass a maximum of 100 IDs.  */
    planIds?: string[];
}
declare enum ArchivedFilter {
    /** Returns all plans that are active. */
    ACTIVE = "ACTIVE",
    /** Returns all plans that are archived. */
    ARCHIVED = "ARCHIVED",
    /** Returns all plans that are active and archived. */
    ARCHIVED_AND_ACTIVE = "ARCHIVED_AND_ACTIVE"
}
declare enum PublicFilter {
    /** Returns all public and hidden plans. */
    PUBLIC_AND_HIDDEN = "PUBLIC_AND_HIDDEN",
    /** Returns only public plans. */
    PUBLIC = "PUBLIC",
    /** Returns only hidden plans. */
    HIDDEN = "HIDDEN"
}
interface ListPlansResponse {
    /** List of all public and hidden pricing plans. */
    plans?: Plan[];
    /** Details on the paged set of pricing plans returned.  */
    pagingMetadata?: PagingMetadataV2;
}
interface GetPlanStatsRequest {
}
interface GetPlanStatsResponse {
    /** Total number of plans created, including active plans (both public and hidden) and archived plans. */
    totalPlans?: number;
}
interface CreatePlanRequest {
    /** Information for the plan being created. */
    plan: Plan;
}
interface CreatePlanResponse {
    /** Plan info.  */
    plan?: Plan;
}
interface UpdatePlanRequest {
    /** Plan info to update. */
    plan: Plan;
}
interface UpdatePlanResponse {
    /** Updated plan info. */
    plan?: Plan;
}
interface BuyerCanCancelUpdated {
    /** Pricing plan. */
    plan?: Plan;
}
interface SetPlanVisibilityRequest {
    /** The ID of the plan to either display or hide on the site page.  */
    _id: string;
    /** Whether to set the plan as visible. */
    visible: boolean;
}
interface SetPlanVisibilityResponse {
    /** Plan info.  */
    plan?: Plan;
}
interface MakePlanPrimaryRequest {
    /** ID of the pricing plan to set as the primary plan. */
    _id: string;
}
interface MakePlanPrimaryResponse {
    /** Primary plan info. */
    plan?: Plan;
}
interface ClearPrimaryRequest {
}
interface ClearPrimaryResponse {
}
interface ArchivePlanRequest {
    _id: string;
}
interface ArchivePlanResponse {
    /** Archived plan info.  */
    plan?: Plan;
}
interface PlanArchived {
    /** Pricing plan. */
    plan?: Plan;
}
interface BulkArchivePlanRequest {
    /** List of Plan IDs. */
    ids?: string[];
    /** Set to true to return Plan entity in response. */
    returnFullEntity?: boolean;
}
interface BulkArchivePlanResponse {
    /** Plans to be archived. */
    results?: BulkPlanResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkPlanResult {
    /** Item metadata. */
    itemMetadata?: ItemMetadata;
    /** Pricing plan. */
    plan?: Plan;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface ArrangePlansRequest {
    /** IDs of all non-archived plans in the order you want them arranged. */
    ids?: string[];
}
interface ArrangePlansResponse {
}
interface CountPlansRequest {
    /** The filter. */
    filter?: Record<string, any> | null;
    /** If true, will count only visible plans (visible and not archived). If no value is given all site's plans will be counted. */
    visibility?: boolean | null;
}
interface CountPlansResponse {
    /** Number of plans in the response. */
    count?: number;
}
interface GetPlansPremiumStatusRequest {
}
interface GetPlansPremiumStatusResponse {
    /** True if site has non-free, non-template plans. */
    hasPaidPlans?: boolean;
    /** True if site has plans that were created before Pricing Plans became a premium app. */
    hasOldPlans?: boolean;
}
interface SearchPlansRequest {
    /** Query */
    query?: QueryV2;
    /** Search phrase for plan name */
    searchPhrase?: string | null;
}
interface SearchPlansResponse {
    /** List of pricing plans that match the specified filter and search phrase. */
    plans?: Plan[];
    /** Object containing paging-related data (number of plans returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface StringListNonNullableFields {
    values: string[];
}
interface DurationNonNullableFields {
    unit: PeriodUnit;
}
interface RecurrenceNonNullableFields {
    cycleDuration?: DurationNonNullableFields;
}
interface MoneyNonNullableFields {
    value: string;
    currency: string;
}
interface FeeNonNullableFields {
    name: string;
    amount: string;
}
interface FeeConfigNonNullableFields {
    fee?: FeeNonNullableFields;
    appliedAt: AppliedAt;
}
interface PricingNonNullableFields {
    subscription?: RecurrenceNonNullableFields;
    singlePaymentForDuration?: DurationNonNullableFields;
    price?: MoneyNonNullableFields;
    feeConfigs: FeeConfigNonNullableFields[];
}
interface PublicPlanNonNullableFields {
    _id: string;
    perks?: StringListNonNullableFields;
    pricing?: PricingNonNullableFields;
    primary: boolean;
}
interface ListPublicPlansResponseNonNullableFields {
    plans: PublicPlanNonNullableFields[];
}
interface QueryPublicPlansResponseNonNullableFields {
    plans: PublicPlanNonNullableFields[];
}
interface PlanNonNullableFields {
    _id: string;
    perks?: StringListNonNullableFields;
    pricing?: PricingNonNullableFields;
    archived: boolean;
    primary: boolean;
    hasOrders: boolean;
}
interface GetPlanResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface ListPlansResponseNonNullableFields {
    plans: PlanNonNullableFields[];
}
interface GetPlanStatsResponseNonNullableFields {
    totalPlans: number;
}
interface CreatePlanResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface UpdatePlanResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface SetPlanVisibilityResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface MakePlanPrimaryResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface ArchivePlanResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface BaseEventMetadata {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
interface PlanUpdatedEnvelope {
    entity: Plan;
    metadata: EventMetadata;
}
interface PlanCreatedEnvelope {
    entity: Plan;
    metadata: EventMetadata;
}
interface PlanBuyerCanCancelUpdatedEnvelope {
    data: BuyerCanCancelUpdated;
    metadata: EventMetadata;
}
interface PlanArchivedEnvelope {
    data: PlanArchived;
    metadata: EventMetadata;
}
interface ListPublicPlansOptions {
    /**
     * Number of pricing plans to list.
     *
     * Default: `75`.
     */
    limit?: number | null;
    /**
     * Number of pricing plans to skip.
     *
     * Default: `0`.
     */
    offset?: number | null;
    /** IDs of public plans to list. If non-existent IDs are specified, they are ignored and don't cause errors. If no IDs are specified, all public are listed according to the [order](#arrangeplans) displayed in the Dashboard. You can pass a maximum of 100 IDs.  */
    planIds?: string[];
}
interface QueryOffsetResult {
    currentPage: number | undefined;
    totalPages: number | undefined;
    totalCount: number | undefined;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface PlansQueryResult extends QueryOffsetResult {
    items: PublicPlan[];
    query: PlansQueryBuilder;
    next: () => Promise<PlansQueryResult>;
    prev: () => Promise<PlansQueryResult>;
}
interface PlansQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    eq: (propertyName: '_id' | 'primary' | '_createdDate' | '_updatedDate' | 'slug', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ne: (propertyName: '_id' | 'primary' | '_createdDate' | '_updatedDate' | 'slug', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ge: (propertyName: '_createdDate' | '_updatedDate', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    gt: (propertyName: '_createdDate' | '_updatedDate', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    le: (propertyName: '_createdDate' | '_updatedDate', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    lt: (propertyName: '_createdDate' | '_updatedDate', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     */
    startsWith: (propertyName: '_id' | 'slug', value: string) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     */
    hasSome: (propertyName: '_id' | 'primary' | '_createdDate' | '_updatedDate' | 'slug', value: any[]) => PlansQueryBuilder;
    in: (propertyName: '_id' | 'primary' | '_createdDate' | '_updatedDate' | 'slug', value: any) => PlansQueryBuilder;
    exists: (propertyName: '_id' | 'primary' | '_createdDate' | '_updatedDate' | 'slug', value: boolean) => PlansQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    ascending: (...propertyNames: Array<'_id' | 'primary' | '_createdDate' | '_updatedDate' | 'slug'>) => PlansQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    descending: (...propertyNames: Array<'_id' | 'primary' | '_createdDate' | '_updatedDate' | 'slug'>) => PlansQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
    limit: (limit: number) => PlansQueryBuilder;
    /** @param skip - Number of items to skip in the query results before returning the results. */
    skip: (skip: number) => PlansQueryBuilder;
    find: () => Promise<PlansQueryResult>;
}
interface ListPlansOptions {
    /**
     * Archived filter.
     *
     * Default: `ACTIVE` (not archived).
     */
    archived?: ArchivedFilter;
    /**
     * Visibility filter.
     *
     * Default: `PUBLIC_AND_HIDDEN` (meaning, both public and hidden plans are listed).
     *
     */
    public?: PublicFilter;
    /**
     * Number of pricing plans to list.
     *
     * Default: `75`.
     */
    limit?: number | null;
    /**
     * Number of pricing plans to skip.
     *
     * Default: `0`.
     */
    offset?: number | null;
    /** IDs of plans to list. If non-existent IDs are specified, they are ignored and don't cause errors. If no IDs are specified, all public and hidden plans (based on `options`) are listed according to the [order](#arrangeplans) displayed in the Dashboard. You can pass a maximum of 100 IDs.  */
    planIds?: string[];
}
interface UpdatePlan {
    /**
     * Plan ID.
     * @readonly
     */
    _id?: string;
    /** Plan name. */
    name?: string | null;
    /** Plan description. */
    description?: string | null;
    /**
     * List of text strings that promote what is included with this plan.
     *
     * For example, "Plenty of parking" or "Free gift on your birthday".
     */
    perks?: StringList;
    /** Plan price, payment schedule, and expiration. */
    pricing?: Pricing;
    /** Whether the plan is public (visible to site visitors and members). */
    public?: boolean | null;
    /**
     * Whether the plan is archived. Archived plans are not visible and can't be purchased anymore, but existing purchases remain in effect.
     * @readonly
     */
    archived?: boolean;
    /**
     * Whether the plan is marked as primary. If `true`, the plan is highlighted on the site with a custom ribbon.
     *
     * Default: `false`.
     * @readonly
     */
    primary?: boolean;
    /**
     * Whether the plan has any orders (including pending and unpaid orders).
     * @readonly
     */
    hasOrders?: boolean;
    /**
     * Date plan was created.
     * @readonly
     */
    _createdDate?: Date;
    /**
     * Date plan was last updated.
     * @readonly
     */
    _updatedDate?: Date;
    /**
     * URL-friendly version of plan name. Unique across all plans in the same site.
     * @readonly
     */
    slug?: string | null;
    /**
     * Number of times the same buyer can purchase the plan. Currently limited to support:
     * - Empty value or a value of `0`, meaning no limitation.
     * - Value of `1`, meaning limited to one purchase per buyer.
     */
    maxPurchasesPerBuyer?: number | null;
    /**
     * Whether the buyer can start the plan at a later date.
     *
     * Default: `false`.
     *
     */
    allowFutureStartDate?: boolean | null;
    /**
     * Whether the buyer is allowed to cancel their plan. If `false`, calling the [`requestCancellation()`](https://www.wix.com/velo/reference/wix-pricing-plans-v2/orders/requestcancellation) function returns an error.
     *
     * Default: `true`.
     *
     */
    buyerCanCancel?: boolean | null;
    /** Any terms and conditions that apply to the plan. This information will be displayed during checkout. */
    termsAndConditions?: string | null;
    /** ID of the form associated with the plan at checkout. */
    formId?: string | null;
}

declare function listPublicPlans$1(httpClient: HttpClient): ListPublicPlansSignature;
interface ListPublicPlansSignature {
    /**
     * Retrieves a list of public pricing plans.
     *
     *
     * The `listPublicPlans()` function returns a Promise that resolves to a list of up to 100 public pricing plans. Public plans are visible plans that site visitors can see on the site and purchase.
     * @param - Options for filtering and paging the list of public plans.
     * @returns Fulfilled - List of public pricing plans.
     */
    (options?: ListPublicPlansOptions | undefined): Promise<ListPublicPlansResponse & ListPublicPlansResponseNonNullableFields>;
}
declare function queryPublicPlans$1(httpClient: HttpClient): QueryPublicPlansSignature;
interface QueryPublicPlansSignature {
    /**
     * Creates a query to retrieve a list of public pricing plans.
     *
     *
     * The `queryPublicPlans()` function builds a query to retrieve a list of up to 1,000 public plans and returns a [`PublicPlansQueryBuilder`](#plansquerybuilder) object.
     *
     * The returned object contains the query definition which is typically used to run the query using the [`find()`](#plansquerybuilder/find) function.
     *
     * You can refine the query by chaining `PublicPlansQueryBuilder` functions onto the query. `PublicPlansQueryBuilder` functions enable you to sort, filter, and control the results that `queryPublicPlans()` returns.
     *
     * `queryPublicPlans()` runs with the following `PublicPlansQueryBuilder` defaults that you can override:
     * - [`skip`](#plansquerybuilder/skip): `0`
     * - [`limit`](#plansquerybuilder/limit): `50`
     *
     * The functions that are chained to `queryPublicPlans()` are applied in the order they are called. For example, if you sort on the `_createdDate` property in ascending order and then on the `_id` property in ascending order, the results are sorted first by the created date of the items and then, if there are multiple results with the same date, the items are sorted by `_id` in ascending order, per created date value.
     *
     * The following `PublicPlansQueryBuilder` functions are supported for the `queryPublicPlans()` function. For a full description of the Plans object, see the object returned for the [`items`](#plansqueryresult/items) property in [`PublicPlansQueryResult`](#plansqueryresult).
     */
    (): PlansQueryBuilder;
}
declare function getPlan$1(httpClient: HttpClient): GetPlanSignature;
interface GetPlanSignature {
    /**
     * Retrieves a pricing plan by the specified ID.
     *
     * The `getPlan()` function returns a Promise that resolves to a plan whose ID matched the specified ID.
     * @param - Plan ID.
     * @returns Fulfilled - The retrieved plan's information.
     */
    (_id: string): Promise<Plan & PlanNonNullableFields>;
}
declare function listPlans$1(httpClient: HttpClient): ListPlansSignature;
interface ListPlansSignature {
    /**
     * Retrieves a list of pricing plans.
     *
     * The `listPlans()` function returns a Promise that resolves to a list of up to 100 pricing plans. This includes public, hidden, and archived plans.
     * @param - Options for filtering and paging the list of plans.
     * @returns Fulfilled - List of plans that match the given criteria.
     */
    (options?: ListPlansOptions | undefined): Promise<ListPlansResponse & ListPlansResponseNonNullableFields>;
}
declare function getPlanStats$1(httpClient: HttpClient): GetPlanStatsSignature;
interface GetPlanStatsSignature {
    /**
     * Retrieves statistics about the pricing plans.
     *
     *
     * The `getPlanStats()` function returns a Promise that resolves to statistics about the plan on the site.
     *
     * Currently this function provides only the total number of pricing plans, including archived plans.
     * @returns Fulfilled - Overall statistics about the pricing plans.
     */
    (): Promise<GetPlanStatsResponse & GetPlanStatsResponseNonNullableFields>;
}
declare function createPlan$1(httpClient: HttpClient): CreatePlanSignature;
interface CreatePlanSignature {
    /**
     * Creates a pricing plan.
     *
     *
     * The `createPlan()` function returns a Promise that resolves to a newly-created pricing plan after is has successfully been created.
     *
     * The passed `plan` object must contain a [pricing model](https://www.wix.com/velo/reference/wix-pricing-plans-v2/plans/pricing-models). A pricing model can be one of the following:
     * - **A subscription**: A subscription with recurring payment and how often the plan occurs. Subscriptions can have free trial days.
     * - **A plan that does not renew**: A single payment for a specific duration that doesn't renew.
     * - **An unlimited plan**: A single payment for an unlimited amount of time (until canceled).
     *
     * Pricing plans created by this function are available to the site owner in the Pricing Plans section in the Dashboard.
     * @param - Information for the plan being created.
     * @returns Fulfilled - The created plan.
     *
     * Rejected - Error message.
     */
    (plan: Plan): Promise<Plan & PlanNonNullableFields>;
}
declare function updatePlan$1(httpClient: HttpClient): UpdatePlanSignature;
interface UpdatePlanSignature {
    /**
     * Updates a pricing plan.
     *
     *
     * The `updatePlan()` function returns a Promise that resolves to an updated plan.
     *
     * Updating a plan does not impact existing purchases made for the plan. All purchases keep the details of the original plan that was active at the time of the purchase.
     * @param - ID of the plan to update.
     * @param - Options for updating the plan.
     * @returns Fulfilled - The updated plan.
     *
     * Rejected - Error message.
     */
    (_id: string, plan: UpdatePlan): Promise<Plan & PlanNonNullableFields>;
}
declare function setPlanVisibility$1(httpClient: HttpClient): SetPlanVisibilitySignature;
interface SetPlanVisibilitySignature {
    /**
     * Sets visibility for non-archived pricing plans.
     *
     * The `setPlanVisibility()` functions returns a Promise that resolves to a pricing plan when its visibility has successfully been set.
     *
     * By default, pricing plans are public, meaning they are visible. [Plans can be hidden](https://support.wix.com/en/article/pricing-plans-removing-a-plan-from-your-site#hiding-plans) so that site members and visitors cannot see or choose them.
     *
     * As opposed to archiving, setting visibility can be reversed. This means that a public plan can be hidden, and a hidden plan can be made public (visible).
     *
     * >**Note:** An archived plan always remains archived and cannot be made active again. When archiving a plan, its `public` property is automatically set to `false` so that it is hidden.
     *
     * Changing a plan's visibility does not impact existing orders for the plan. All orders for hidden plans are still active and keep their terms and payment options.
     * @param - Whether to set the plan as visible.
     * @param - The ID of the plan to either display or hide on the site page.
     * @param - Plan visibility options.
     * @returns Fulfilled - The plan's information.
     *
     * Rejected - Error message.
     */
    (_id: string, visible: boolean): Promise<SetPlanVisibilityResponse & SetPlanVisibilityResponseNonNullableFields>;
}
declare function makePlanPrimary$1(httpClient: HttpClient): MakePlanPrimarySignature;
interface MakePlanPrimarySignature {
    /**
     * Marks a pricing plan as the primary pricing plan.
     *
     *
     * The `makePlanPrimary()` function returns a Promise that resolves to the now primary pricing plan.
     *
     * Only a single plan can be marked as a primary plan at any given time. If there is an existing plan marked as primary, calling `makePlanPrimary()` causes the existing primary plan to lose its primary status.
     *
     * When viewing pricing plans on the site, the primary plan is highlighted with a customizable ribbon.
     * @param - ID of the pricing plan to set as the primary plan.
     * @returns Fulfilled - The primary plan.
     */
    (_id: string): Promise<MakePlanPrimaryResponse & MakePlanPrimaryResponseNonNullableFields>;
}
declare function clearPrimary$1(httpClient: HttpClient): ClearPrimarySignature;
interface ClearPrimarySignature {
    /**
     * Sets all pricing plans to no longer be primary.
     *
     * The `clearPrimary()` function returns a Promise that is resolved when there are no pricing plans marked as `primary`.
     *
     * After clearing the primary plan, when viewing pricing plans on the site, no plan is highlighted with a customizable ribbon.
     */
    (): Promise<void>;
}
declare function archivePlan$1(httpClient: HttpClient): ArchivePlanSignature;
interface ArchivePlanSignature {
    /**
     * Archives a single plan.
     *
     *
     * The `archivePlan()` function returns a Promise that resolves to the newly-archived plan.
     *
     * When a plan is archived, the plan
     * - Is no longer available for display or selection by visitors. This is because the plan's `public` property is automatically set to `false`.
     * - Cannot be purchased.
     * - Cannot be "un-archived", meaning the plan cannot be made active again.
     *
     * Plan archiving does not impact existing purchases made for the plan. All purchases for the plan are still active and keep their payment options and terms.
     *
     * Site owners can see archived plans in the Dashboard under **Pricing Plans -> Archived Plans**.
     *
     * >**Note:** An attempt to archive an already-archived plan throws an error.
     * @param - ID of the active plan to archive.
     * @returns Fulfilled - The archived plan.
     *
     * Rejected - Error message.
     */
    (_id: string): Promise<ArchivePlanResponse & ArchivePlanResponseNonNullableFields>;
}
declare const onPlanUpdated$1: EventDefinition$1<PlanUpdatedEnvelope, "wix.pricing_plans.plan_updated">;
declare const onPlanCreated$1: EventDefinition$1<PlanCreatedEnvelope, "wix.pricing_plans.plan_created">;
declare const onPlanBuyerCanCancelUpdated$1: EventDefinition$1<PlanBuyerCanCancelUpdatedEnvelope, "wix.pricing_plans.plan_buyer_can_cancel_updated">;
declare const onPlanArchived$1: EventDefinition$1<PlanArchivedEnvelope, "wix.pricing_plans.plan_plan_archived">;

type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare function createEventModule<T extends EventDefinition<any, string>>(eventDefinition: T): BuildEventDefinition<T> & T;

declare const listPublicPlans: MaybeContext<BuildRESTFunction<typeof listPublicPlans$1> & typeof listPublicPlans$1>;
declare const queryPublicPlans: MaybeContext<BuildRESTFunction<typeof queryPublicPlans$1> & typeof queryPublicPlans$1>;
declare const getPlan: MaybeContext<BuildRESTFunction<typeof getPlan$1> & typeof getPlan$1>;
declare const listPlans: MaybeContext<BuildRESTFunction<typeof listPlans$1> & typeof listPlans$1>;
declare const getPlanStats: MaybeContext<BuildRESTFunction<typeof getPlanStats$1> & typeof getPlanStats$1>;
declare const createPlan: MaybeContext<BuildRESTFunction<typeof createPlan$1> & typeof createPlan$1>;
declare const updatePlan: MaybeContext<BuildRESTFunction<typeof updatePlan$1> & typeof updatePlan$1>;
declare const setPlanVisibility: MaybeContext<BuildRESTFunction<typeof setPlanVisibility$1> & typeof setPlanVisibility$1>;
declare const makePlanPrimary: MaybeContext<BuildRESTFunction<typeof makePlanPrimary$1> & typeof makePlanPrimary$1>;
declare const clearPrimary: MaybeContext<BuildRESTFunction<typeof clearPrimary$1> & typeof clearPrimary$1>;
declare const archivePlan: MaybeContext<BuildRESTFunction<typeof archivePlan$1> & typeof archivePlan$1>;

type _publicOnPlanUpdatedType = typeof onPlanUpdated$1;
/**
 * An event that is triggered when a pricing plan is updated.
 */
declare const onPlanUpdated: ReturnType<typeof createEventModule<_publicOnPlanUpdatedType>>;

type _publicOnPlanCreatedType = typeof onPlanCreated$1;
/**
 * An event that is triggered when a pricing plan is created.
 */
declare const onPlanCreated: ReturnType<typeof createEventModule<_publicOnPlanCreatedType>>;

type _publicOnPlanBuyerCanCancelUpdatedType = typeof onPlanBuyerCanCancelUpdated$1;
/** */
declare const onPlanBuyerCanCancelUpdated: ReturnType<typeof createEventModule<_publicOnPlanBuyerCanCancelUpdatedType>>;

type _publicOnPlanArchivedType = typeof onPlanArchived$1;
/**
 * An event that is triggered when a pricing plan is archived.
 */
declare const onPlanArchived: ReturnType<typeof createEventModule<_publicOnPlanArchivedType>>;

export { type ActionEvent, type ApplicationError, AppliedAt, type ArchivePlanRequest, type ArchivePlanResponse, type ArchivePlanResponseNonNullableFields, ArchivedFilter, type ArrangePlansRequest, type ArrangePlansResponse, type BaseEventMetadata, type BulkActionMetadata, type BulkArchivePlanRequest, type BulkArchivePlanResponse, type BulkPlanResult, type BuyerCanCancelUpdated, type ClearPrimaryRequest, type ClearPrimaryResponse, type CountPlansRequest, type CountPlansResponse, type CreatePlanRequest, type CreatePlanResponse, type CreatePlanResponseNonNullableFields, type Cursors, type DomainEvent, type DomainEventBodyOneOf, type Duration, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventMetadata, type Fee, type FeeConfig, type GetPlanRequest, type GetPlanResponse, type GetPlanResponseNonNullableFields, type GetPlanStatsRequest, type GetPlanStatsResponse, type GetPlanStatsResponseNonNullableFields, type GetPlansPremiumStatusRequest, type GetPlansPremiumStatusResponse, type IdentificationData, type IdentificationDataIdOneOf, type ItemMetadata, type ListPlansOptions, type ListPlansRequest, type ListPlansResponse, type ListPlansResponseNonNullableFields, type ListPublicPlansOptions, type ListPublicPlansRequest, type ListPublicPlansResponse, type ListPublicPlansResponseNonNullableFields, type MakePlanPrimaryRequest, type MakePlanPrimaryResponse, type MakePlanPrimaryResponseNonNullableFields, type MessageEnvelope, type Money, type Paging, type PagingMetadataV2, PeriodUnit, type Plan, type PlanArchived, type PlanArchivedEnvelope, type PlanBuyerCanCancelUpdatedEnvelope, type PlanCreatedEnvelope, type PlanNonNullableFields, type PlanUpdatedEnvelope, type PlansQueryBuilder, type PlansQueryResult, type Pricing, type PricingPricingModelOneOf, PublicFilter, type PublicPlan, type QueryPublicPlansRequest, type QueryPublicPlansResponse, type QueryPublicPlansResponseNonNullableFields, type QueryV2, type Recurrence, type RestoreInfo, type SearchPlansRequest, type SearchPlansResponse, type SetPlanVisibilityRequest, type SetPlanVisibilityResponse, type SetPlanVisibilityResponseNonNullableFields, SortOrder, type Sorting, type StringList, type UpdatePlan, type UpdatePlanRequest, type UpdatePlanResponse, type UpdatePlanResponseNonNullableFields, WebhookIdentityType, type _publicOnPlanArchivedType, type _publicOnPlanBuyerCanCancelUpdatedType, type _publicOnPlanCreatedType, type _publicOnPlanUpdatedType, archivePlan, clearPrimary, createPlan, getPlan, getPlanStats, listPlans, listPublicPlans, makePlanPrimary, onPlanArchived, onPlanBuyerCanCancelUpdated, onPlanCreated, onPlanUpdated, onPlanArchived$1 as publicOnPlanArchived, onPlanBuyerCanCancelUpdated$1 as publicOnPlanBuyerCanCancelUpdated, onPlanCreated$1 as publicOnPlanCreated, onPlanUpdated$1 as publicOnPlanUpdated, queryPublicPlans, setPlanVisibility, updatePlan };
