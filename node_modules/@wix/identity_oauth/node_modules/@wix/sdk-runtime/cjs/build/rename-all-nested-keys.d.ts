import type { Simplify } from 'type-fest/source/simplify.js';
import { RESTResponseToSDKResponseRenameMap, SDKRequestToRESTRequestRenameMap } from './constants.js';
/**
 * Recursively rename nested keys provided in `renameMap` in the given object.
 * Providing a list of paths to ignore will prevent renaming of keys in nested objects.
 *
 * Paths are provided in the format of 'path.to.nested.field'
 * @param payload The object to rename keys for
 * @param renameMap A map of keys to rename, where the key is the original key and the value is the new key
 * @param ignorePaths Paths of nested fields to ignore while traversing the object
 * @returns The object with renamed keys
 */
export declare function renameAllNestedKeys<T, KeyMapper extends Record<string, string>>(payload: T | undefined, renameMap: KeyMapper, ignorePaths: string[]): RenameAllNestedKeys<T, KeyMapper>;
export declare function renameKeysFromSDKRequestToRESTRequest<T>(payload: T | undefined, ignorePaths?: string[]): RenameAllNestedKeys<T, typeof SDKRequestToRESTRequestRenameMap>;
export declare function renameKeysFromRESTResponseToSDKResponse<T>(payload: T | undefined, ignorePaths?: string[]): RenameAllNestedKeys<T, typeof RESTResponseToSDKResponseRenameMap>;
type NonTransformedTypes = ArrayBufferLike | Date | RegExp | string | number | boolean | null | undefined;
export type RenameAllNestedKeys<T, KeyMapper extends Record<string, string>> = T extends NonTransformedTypes ? T : Simplify<MapKeys<{
    [P in keyof T]: T extends T[P] ? T[P] : T[] extends T[P] ? T[P] : TransformedValue<T[P], KeyMapper>;
}, KeyMapper>>;
type TransformedValue<T, KeyMapper extends Record<string, string>> = T extends NonTransformedTypes ? T : T extends (infer E)[] ? TransformedArray<E, KeyMapper> : T extends object ? RenameAllNestedKeys<T, KeyMapper> : T;
interface TransformedArray<T, KeyMapper extends Record<string, string>> extends Array<TransformedValue<T, KeyMapper>> {
}
type MapKeys<T, M extends Record<string, string>> = KeyValueTupleToObject<ValueOf<{
    [K in keyof T]-?: [
        K extends keyof M ? (M[K] extends keyof T ? K : M[K]) : K,
        T[K]
    ];
}>>;
type KeyValueTupleToObject<T extends [keyof any, any]> = {
    [K in T[0]]: Extract<T, [K, any]>[1];
};
type ValueOf<T> = T[keyof T];
export {};
