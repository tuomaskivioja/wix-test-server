export interface RefreshToken {
    token?: string;
}
/**
 * AuthorizeRequest is sent by the client to the authorization server to initiate
 * the authorization process.
 */
export interface AuthorizeRequest {
    /** ID of the Wix OAuth app requesting authorization. */
    clientId?: string;
    /**
     * Desired authorization [grant type](https://auth0.com/docs/authenticate/protocols/oauth#grant-types).
     *
     * Supported values:
     * + `code`: The endpoint returns an authorization code that can be used to obtain an access token.
     */
    responseType?: string;
    /** URI to redirect the browser to after authentication and authorization. The browser is redirected to this URI whether the authentication and authorization process is successful or not. */
    redirectUri?: string | null;
    /**
     * Desired scope of access. If this field is left empty, only an access token is granted.
     * To received a refresh token, pass `offline_access` as the value of this field.
     */
    scope?: string | null;
    /**
     * A value used to confirm the state of an application before and after it makes an authorization
     * request. If a value for this field is set in the request, it's added to the `redirectUri` when the browser
     * is redirected there.
     * Learn more about [using the state parameter](https://auth0.com/docs/secure/attack-protection/state-parameters).
     */
    state?: string;
    /**
     * esired response format.
     *
     * Supported values:
     * + `query`: The response parameters are encoded as query string parameters and added to the `redirectUri` when redirecting.
     * + `fragment`: The response parameters are encoded as URI fragment parameters and added to the `redirectUri` when redirecting.
     * + `web_message`: The response parameters are encoded as a JSON object and added to the body of a [web message response](https://datatracker.ietf.org/doc/html/draft-sakimura-oauth-wmrm-00).
     *
     * Default value: `query`
     */
    responseMode?: string | null;
    /**
     * Code challenge to use for PKCE verification.
     * This field is only used if `responseType` is set to `code`.
     */
    codeChallenge?: string | null;
    /**
     * Code challenge method to use for PKCE verification.
     * This field is only used if `responseType` is set to `code`.
     *
     * Supported values:
     * + `S256`: The code challenge is transformed using SHA-256 encyption.
     * + `S512`: The code challenge is transformed using SHA-512 encyption.
     */
    codeChallengeMethod?: string | null;
    /** Session token of the site visitor to authorize. */
    sessionToken?: string | null;
}
export interface RawHttpResponse {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry[];
}
export interface HeadersEntry {
    key?: string;
    value?: string;
}
export interface RawHttpRequest {
    body?: Uint8Array;
    pathParams?: PathParametersEntry[];
    queryParams?: QueryParametersEntry[];
    headers?: HeadersEntry[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
export interface PathParametersEntry {
    key?: string;
    value?: string;
}
export interface QueryParametersEntry {
    key?: string;
    value?: string;
}
export interface DeviceCodeRequest {
    /** The ID of the application that asks for authorization. */
    clientId?: string;
    /**
     * scope is a space-delimited string that specifies the requested scope of the
     * access request.
     */
    scope?: string | null;
}
export interface DeviceCodeResponse {
    /** is the unique code for the device. When the user goes to the verification_uri in their browser-based device, this code will be bound to their session. */
    deviceCode?: string;
    /** contains the code that should be input at the verification_uri to authorize the device. */
    userCode?: string;
    /** contains the URL the user should visit to authorize the device. */
    verificationUri?: string;
    /** indicates the lifetime (in seconds) of the device_code and user_code. */
    expiresIn?: number;
    /** indicates the interval (in seconds) at which the app should poll the token URL to request a token. clients MUST use 5 as the default */
    interval?: number | null;
}
export interface DeviceVerifyRequest {
    /** User code representing a currently authorizing device. */
    userCode?: string;
}
export interface DeviceVerifyResponse {
}
export interface InvalidateUserCodeRequest {
    /** user code to invalidate. Only the authorizing identity is able to invalidate it. */
    userCode?: string;
}
export interface InvalidateUserCodeResponse {
}
export interface RevokeRefreshTokenRequest {
    /** The refresh token itself. Anyone with the token itself is able to revoke it. */
    token?: string;
}
export interface RevokeRefreshTokenResponse {
}
export interface Empty {
}
export interface DomainEvent<T = string> extends DomainEventBodyOneOf<T> {
    createdEvent?: EntityCreatedEvent<T>;
    updatedEvent?: EntityUpdatedEvent<T>;
    deletedEvent?: EntityDeletedEvent<T>;
    actionEvent?: ActionEvent<T>;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp. */
    eventTime?: Date;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
export interface DomainCreatedEvent<T> extends Omit<DomainEvent<T>, 'deletedEvent' | 'updatedEvent' | 'actionEvent'> {
}
export interface DomainDeletedEvent<T> extends Omit<DomainEvent<T>, 'createdEvent' | 'updatedEvent' | 'actionEvent'> {
}
export interface DomainUpdatedEvent<T> extends Omit<DomainEvent<T>, 'createdEvent' | 'deletedEvent' | 'actionEvent'> {
}
export interface DomainActionEvent<T> extends Omit<DomainEvent<T>, 'createdEvent' | 'deletedEvent' | 'updatedEvent'> {
}
/** @oneof */
export interface DomainEventBodyOneOf<T> {
    createdEvent?: EntityCreatedEvent<T>;
    updatedEvent?: EntityUpdatedEvent<T>;
    deletedEvent?: EntityDeletedEvent<T>;
    actionEvent?: ActionEvent<T>;
}
export interface EntityCreatedEvent<T> {
    entity?: T;
}
export interface EntityUpdatedEvent<T> {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: T;
}
export interface EntityDeletedEvent<T> {
    /** Entity that was deleted */
    deletedEntity?: T | null;
}
export interface ActionEvent<T> {
    body?: T;
}
export interface RawHttpResponseNonNullableFields {
    body: Uint8Array;
    headers: {
        key: string;
        value: string;
    }[];
}
/**
 * Creates an access token.
 *
 *
 * The endpoint accepts raw HTTP requests. You must pass the request's body
 * parameters formatted as bytes in the raw HTTP request's `body` field,
 * following this template:
 * `{"grantType": "client_credentials", "client_id": "<APP_ID>", "client_secret": "<APP_SECRET_KEY>", "instance_id": "<INSTANCE_ID>"}`.
 *
 * When the call succeeds, Wix returns `{"statusCode": 200}` and the created access
 * token in the `body` field of the raw HTTP response.
 *
 * In case the call fails, Wix returns the relevant `4XX` error code in the raw
 * HTTP response's `statusCode` field and details
 * about the error in `body`. Error details follow the
 * [conventions of the Internet Engineering Task Force (IETF)](https://datatracker.ietf.org/doc/html/rfc6749#appendix-A.7).
 * @public
 * @documentationMaturity preview
 */
export declare function token(options?: TokenOptions): Promise<RawHttpResponse & RawHttpResponseNonNullableFields>;
export interface TokenOptions {
    body?: Uint8Array;
    pathParams?: PathParametersEntry[];
    queryParams?: QueryParametersEntry[];
    headers?: HeadersEntry[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
