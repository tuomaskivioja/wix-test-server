import { isJsonPathExpression, reduceTransformation, runCustomFunctionCallExpression, } from '@wix/motion-edm-autogen-transformations-core';
import { JSONPath } from 'jsonpath-plus';
import { get, isPlainObject, omit, pickBy, set } from 'lodash';
const getValueAtPath = (json, path) => JSONPath({ path, json, wrap: false });
const getValueToSpread = ({ sourceObject, expressionOfValueToSpread, spreadOperatorSiblingKeys, }) => {
    // eslint-disable-next-line no-use-before-define
    const valueToSpread = transform(sourceObject, expressionOfValueToSpread);
    return isPlainObject(valueToSpread)
        ? pickBy(valueToSpread, (_, k) => !spreadOperatorSiblingKeys.includes(k))
        : {};
};
const resolveArgumentValues = (argumentExpressions, sourceObject) => argumentExpressions.map((expression) => isJsonPathExpression(expression)
    ? getValueAtPath(sourceObject, expression)
    : expression);
const transform = (sourceObject, transformation, customFunctions = undefined) => reduceTransformation(transformation, {
    visitors: {
        TopLevelSimpleTransformationExpression: (expression) => getValueAtPath(sourceObject, expression),
        TopLevelCustomFunctionExpression: (functionName, argumentExpressions) => runCustomFunctionCallExpression({
            customFunctions,
            functionName,
            argumentValues: resolveArgumentValues(argumentExpressions, sourceObject),
            transformationParentPath: '',
        }),
        NestedSpreadExpression: (acc, path, expressionOfValueToSpread, spreadOperatorSiblingKeys) => {
            const valueToSpread = getValueToSpread({
                sourceObject,
                expressionOfValueToSpread,
                spreadOperatorSiblingKeys,
            });
            const existing = get(acc, path, {});
            set(acc, path, { ...existing, ...valueToSpread });
        },
        TopLevelSpreadExpression: (acc, expressionOfValueToSpread, spreadOperatorSiblingKeys) => {
            const valueToSpread = getValueToSpread({
                sourceObject,
                expressionOfValueToSpread,
                spreadOperatorSiblingKeys,
            });
            Object.keys(valueToSpread).forEach((key) => {
                acc[key] = valueToSpread[key];
            });
        },
        CustomFunctionExpression: (acc, path, functionName, argumentExpressions) => {
            const customFunctionResult = runCustomFunctionCallExpression({
                customFunctions,
                functionName,
                argumentValues: resolveArgumentValues(argumentExpressions, sourceObject),
                transformationParentPath: path,
            });
            set(acc, path, customFunctionResult);
        },
        NestedSimpleTransformationExpression: (acc, path, simpleTransformationExpression) => {
            set(acc, path, getValueAtPath(sourceObject, simpleTransformationExpression));
        },
        TopLevelMapArrayItems: (sourceArrayExpression, itemTransformation) => {
            const source = transform(sourceObject, sourceArrayExpression);
            return Array.isArray(source)
                ? source.map((item) => transform(item, itemTransformation, customFunctions))
                : source;
        },
        MapArrayItems: (acc, path, sourceArrayExpression, itemTransformation) => {
            const source = transform(sourceObject, sourceArrayExpression);
            const transformedValue = Array.isArray(source)
                ? source.map((item) => transform(item, itemTransformation, customFunctions))
                : source;
            set(acc, path, transformedValue);
        },
        TopLevelOmit: (sourcePathExpression, fieldsToOmit) => {
            const source = transform(sourceObject, sourcePathExpression);
            if (source === undefined) {
                return undefined;
            }
            return isPlainObject(source)
                ? omit(source, fieldsToOmit)
                : sourceObject;
        },
        NestedOmit: (accumulator, path, sourcePathExpression, fieldsToOmit) => {
            const source = transform(sourceObject, sourcePathExpression);
            if (source === undefined) {
                set(accumulator, path, undefined);
                return;
            }
            const value = isPlainObject(source)
                ? omit(source, fieldsToOmit)
                : source;
            set(accumulator, path, value);
        },
        NestedConstantValue: ({ accumulator, path, value }) => {
            set(accumulator, path, value);
        },
    },
    accumulator: {},
});
const transformToRequestMessage = (sourceObject, transformation, customFunctions = undefined) => transform(sourceObject, transformation, customFunctions) || {};
const transformResponseMessage = (sourceObject, transformation, customFunctions = undefined) => transform(sourceObject, transformation, customFunctions);
export { transformResponseMessage, transformToRequestMessage };
//# sourceMappingURL=custom-transformations.js.map