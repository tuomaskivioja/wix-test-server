import { anObject, aString } from '@wix/motion-runtime-test-context';
import { set, times } from 'lodash';
import { violationsWithRenamedFields } from '../../../lib/transformations/transformError/violationsWithRenamedFields';
describe('violationsWithRenamedFields', () => {
    const argumentNames = times(3, () => aString());
    const propertyName = aString();
    const description = aString();
    const originalPath = `some.nested.path.${propertyName}`;
    const fieldViolations = [{ field: originalPath, description }];
    describe('identity transformation', () => {
        test('prepends the path with the single argument name', () => {
            const transformation = '$[0]';
            expect(violationsWithRenamedFields({
                transformation,
                fieldViolations,
                argumentNames,
            })).toStrictEqual([
                {
                    field: `${argumentNames[0]}.${originalPath}`,
                    description,
                },
            ]);
        });
    });
    describe('complex transformation', () => {
        test('replaces an argument reference with its name in a given field-path', () => {
            const transformation = set({}, originalPath, '$[1].another.field');
            expect(violationsWithRenamedFields({
                transformation,
                fieldViolations,
                argumentNames,
            })).toStrictEqual([
                {
                    field: `${argumentNames[1]}.another.field`,
                    description,
                },
            ]);
        });
        test('ignores violations with a path overlapping another violation with a more specific path', () => {
            const overlappingFieldViolations = [
                {
                    field: 'something',
                    description: 'is invalid',
                },
                {
                    field: 'something.displayName',
                    description,
                },
            ];
            const transformation = {
                something: { displayName: '$[1]', key: '$[0]' },
            };
            expect(violationsWithRenamedFields({
                transformation,
                fieldViolations: overlappingFieldViolations,
                argumentNames,
            })).toStrictEqual([{ field: argumentNames[1], description }]);
        });
        test('handles the #wrap custom function', () => {
            const fieldName = 'emails';
            const path = `info.${fieldName}`;
            const wrapper = 'items';
            const subField = aString();
            const wrappedFieldViolations = [
                { field: `${path}.${wrapper}[0].${subField}`, description },
            ];
            const transformation = set({}, path, `#wrap($[0].${fieldName}, ${wrapper})`);
            expect(violationsWithRenamedFields({
                transformation,
                fieldViolations: wrappedFieldViolations,
                argumentNames,
            })).toStrictEqual([
                {
                    field: `${argumentNames[0]}.${fieldName}[0].${subField}`,
                    description,
                },
            ]);
        });
        test('strip field name for invalid input (query builder case)', () => {
            const transformation = { '*': '$[1]', [originalPath]: '$[0]' };
            expect(violationsWithRenamedFields({
                transformation,
                fieldViolations,
                argumentNames: undefined,
            })).toStrictEqual([
                {
                    description,
                },
            ]);
        });
        // TODO: this assumes that the value against "*" is always a string referencing an argument.
        // This needs to be added to the transformation validation-rules
        describe('when a direct match could not be found', () => {
            test('attempts to match with spread-notation path, using the deepest possible match', () => {
                const transformation = {
                    some: {
                        nested: { '*': '$[2]', path: { '*': '$[1].another.object' } },
                    },
                };
                expect(violationsWithRenamedFields({
                    transformation,
                    fieldViolations,
                    argumentNames,
                })).toStrictEqual([
                    {
                        field: `${argumentNames[1]}.another.object.${propertyName}`,
                        description,
                    },
                ]);
            });
            test('returns the the path unchanged in case no match was found', () => {
                const transformation = anObject();
                expect(violationsWithRenamedFields({
                    transformation,
                    fieldViolations,
                    argumentNames,
                })).toStrictEqual(fieldViolations);
            });
        });
    });
});
//# sourceMappingURL=violationsWithRenamedFields.spec.js.map