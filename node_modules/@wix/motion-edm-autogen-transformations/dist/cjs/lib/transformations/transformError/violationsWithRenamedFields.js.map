{"version":3,"names":["_motionEdmAutogenTransformationsCore","require","_lodash","_interopRequireDefault","_withRenamedArgument","JS_SINGLE_ARG_UNCHANGED","transformations","chain","some","_","collectArgumentExpressions","transformation","accumulator","spreadPathsToArguments","explicitPathsToArguments","reduceTransformation","visitors","NestedSpreadExpression","acc","spreadOperatorParentPath","argumentExpressionToSpread","NestedSimpleTransformationExpression","path","simpleTransformationExpression","CustomFunctionExpression","functionName","transformationPath","wrappingName","violationsWithRenamedFields","fieldViolations","argumentNames","allPathsToArguments","allPathsToArgumentsKeys","Object","keys","map","fieldViolation","containedInAMoreSpecificViolationField","anotherViolation","field","length","startsWith","includes","exactMatchArgumentExpression","omitBy","withRenamedArgument","isEmpty","longestPartialPathMatch","sortBy","reverse","find","value","partialMatchArgumentExpression","replace","compact","exports"],"sources":["../../../../../src/lib/transformations/transformError/violationsWithRenamedFields.ts"],"sourcesContent":["import {\n  reduceTransformation,\n  transformations,\n} from '@wix/motion-edm-autogen-transformations-core';\nimport _ from 'lodash';\n\nimport { withRenamedArgument } from './withRenamedArgument';\n\nconst { JS_SINGLE_ARG_UNCHANGED } = transformations;\n\nconst { chain, some } = _;\n\nconst collectArgumentExpressions = (transformation) => {\n  const accumulator = {\n    spreadPathsToArguments: {},\n    explicitPathsToArguments: {},\n  };\n\n  reduceTransformation(transformation, {\n    visitors: {\n      NestedSpreadExpression: (\n        acc,\n        spreadOperatorParentPath,\n        argumentExpressionToSpread,\n      ) => {\n        acc.spreadPathsToArguments[spreadOperatorParentPath] =\n          argumentExpressionToSpread;\n      },\n      NestedSimpleTransformationExpression: (\n        acc,\n        path,\n        simpleTransformationExpression,\n      ) => {\n        acc.explicitPathsToArguments[path] = simpleTransformationExpression;\n      },\n      CustomFunctionExpression: (\n        acc,\n        path,\n        functionName,\n        [transformationPath, wrappingName],\n      ) => {\n        switch (functionName) {\n          case 'wrap':\n            acc.explicitPathsToArguments[`${path}.${wrappingName}`] =\n              transformationPath;\n            break;\n          default:\n          // ignore\n        }\n      },\n    },\n    accumulator,\n  });\n\n  return accumulator;\n};\n\nconst violationsWithRenamedFields = ({\n  transformation,\n  fieldViolations,\n  argumentNames,\n}) => {\n  const { spreadPathsToArguments, explicitPathsToArguments } =\n    collectArgumentExpressions(transformation);\n  const allPathsToArguments = {\n    ...spreadPathsToArguments,\n    ...explicitPathsToArguments,\n  };\n  const allPathsToArgumentsKeys = Object.keys(allPathsToArguments);\n\n  return _(fieldViolations)\n    .map((fieldViolation) => {\n      // In some cases, the violations error will include both some.nested and some.nested.path,\n      // so we'll pick the more specific one if it's covered by the paths in the transformation.\n      const containedInAMoreSpecificViolationField = some(\n        fieldViolations,\n        (anotherViolation) =>\n          anotherViolation.field.length > fieldViolation.field.length &&\n          anotherViolation.field.startsWith(fieldViolation.field) &&\n          allPathsToArgumentsKeys.includes(anotherViolation.field),\n      );\n\n      if (containedInAMoreSpecificViolationField) {\n        return null;\n      }\n\n      // This means we've got some.nested.field in the violation,\n      // matched against { some: { nested: { field: $[0].a.b.c } } } in the transformation.\n      // some.nested.field is replaced entirely with $[0].a.b.c, with $[0] replaced with the name of argument 0\n      const exactMatchArgumentExpression =\n        explicitPathsToArguments[fieldViolation.field];\n\n      if (exactMatchArgumentExpression) {\n        return _.omitBy(\n          {\n            ...fieldViolation,\n            field: withRenamedArgument(\n              exactMatchArgumentExpression,\n              argumentNames,\n            ),\n          },\n          _.isEmpty,\n        );\n      }\n\n      const longestPartialPathMatch = chain(allPathsToArgumentsKeys)\n        .sortBy('length')\n        .reverse()\n        .find((path) => fieldViolation.field.startsWith(path))\n        .value();\n\n      // This means we've got some.nested.field in the violation,\n      // matched against { some: { nested: { *: $[0].a.b.c } } } in the transformation.\n      // Only the prefix some.nested is replaced with $[0].a.b.c, with $[0] replaced with the name of argument 0\n      // This can also happen in the case where the #wrap function is used.\n      const partialMatchArgumentExpression =\n        allPathsToArguments[longestPartialPathMatch];\n\n      if (partialMatchArgumentExpression) {\n        return {\n          ...fieldViolation,\n          field: fieldViolation.field.replace(\n            longestPartialPathMatch,\n            withRenamedArgument(partialMatchArgumentExpression, argumentNames),\n          ),\n        };\n      }\n\n      if (transformation === JS_SINGLE_ARG_UNCHANGED) {\n        return {\n          ...fieldViolation,\n          field: `${argumentNames[0]}.${fieldViolation.field}`,\n        };\n      }\n\n      return fieldViolation;\n    })\n    .compact()\n    .value();\n};\n\nexport { violationsWithRenamedFields };\n"],"mappings":"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","ignoreList":[]}