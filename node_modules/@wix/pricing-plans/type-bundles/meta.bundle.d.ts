/**
 * An order object includes all of the details related to the purchase of a Pricing Plan.
 * You can manage existing orders, create offline orders, and preview orders not yet purchased.
 *
 * Orders are based on pricing models based on the payment and duration cycles for each plan. See here to
 * [learn more about pricing models](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/introduction#wix-pricing-plans_pricing-plans_introduction_pricing-models).
 */
interface Order$1 {
    /**
     * Order ID.
     * @readonly
     */
    id?: string;
    /**
     * ID of the plan purchased with the order. See [Plans for more information about pricing plans](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/introduction).
     * @readonly
     */
    planId?: string;
    /**
     * ID of the related Wix subscription.
     *
     * Every pricing plan order corresponds to a Wix subscription, including orders for single payment plans. See here
     * for a [Pricing Plans overview](https://support.wix.com/en/article/pricing-plans-an-overview#create-plans-to-suit-your-business).
     * @readonly
     */
    subscriptionId?: string;
    /**
     * Wix Pay order ID.
     *
     * Provided by Wix whether the order is created online or offline. The field is omitted when the order is free.
     * @readonly
     */
    wixPayOrderId?: string | null;
    /**
     * The buyer's IDs. Includes `memberId` and `contactId`.
     *
     * Currently, Pricing Plan purchases are limited to members only. `contactId` is returned,
     * but a buyer will not be able to purchase a plan without a `memberId`.
     * @readonly
     */
    buyer?: Buyer$1;
    /**
     * __Deprecated.__ Use `pricing` instead. This property will be removed on September 30, 2022.
     * @readonly
     * @deprecated __Deprecated.__ Use `pricing` instead. This property will be removed on September 30, 2022.
     * @replacedBy pricing
     * @targetRemovalDate 2022-10-01
     */
    priceDetails?: PriceDetails$1;
    /**
     * Order pricing model, price, and payment schedule.
     *
     * [Learn more about pricing models](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/introduction#wix-pricing-plans_pricing-plans_introduction_pricing-models).
     * @readonly
     */
    pricing?: PricingDetails$1;
    /**
     * How the order was processed. One of:
     * + `ONLINE`: The buyer purchased the plan using the site.
     * + `OFFLINE`: The buyer made a manual, offline purchase without using the site.
     * + `EXTERNAL`: The buyer made a purchase through an external payment provider.
     * @readonly
     */
    type?: OrderType$1;
    /**
     * Status of the order. One of:
     * + `DRAFT`: Order has been initiated but payment hasn't been processed yet. The plan isn't yet available for use to the buyer.
     * + `PENDING`: Order has been purchased and its start date is set in the future.
     * + `ACTIVE`: Order has been processed. The plan is available for use.
     * + `PAUSED`: Order, and use of the plan, is [paused](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/pause-order). The order, and use of the plan, can be [resumed](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/resume-order).
     * + `ENDED`: Order has completed its duration and is no longer available for use.
     * + `CANCELED`: Order has been [canceled](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/cancel-order).
     * @readonly
     */
    status?: OrderStatus$1;
    /**
     * Whether the order will be canceled at the next payment date.
     *
     * If `true`, the order status will be `CANCELED` and the next payment won't be charged. Omitted for single payment orders.
     * @readonly
     */
    autoRenewCanceled?: boolean | null;
    /**
     * Details about the cancellation of an order.
     *
     * Only present if the status is `CANCELED`.
     * @readonly
     */
    cancellation?: Cancellation$1;
    /**
     * Status of the last payment for the order.
     * Updated automatically for online orders. Updated manually by the site owner for offline orders. One of:
     * + `PAID`: The last payment was paid.
     * + `REFUNDED`: The last payment was refunded.
     * + `FAILED`: The last payment transaction didn't complete.
     * + `UNPAID`: The last payment wasn't paid.
     * + `PENDING`: Awaiting payment.
     * + `NOT_APPLICABLE`: No payment was necessary. For example, for free plans or free trials.
     * @readonly
     */
    lastPaymentStatus?: PaymentStatus$1;
    /**
     * Start date and time for the ordered plan.
     * @readonly
     */
    startDate?: Date;
    /**
     * Current end date and time for the ordered plan.
     *
     * `endDate` may be updated over the course of an order. If the order is [paused](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/pause-order),
     * it will have a later `endDate` once it [resumes](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/resume-order). `endDate` may also be [postponed](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/postpone-end-date).
     *
     * Omitted if the order is valid until canceled and still `ACTIVE`.
     * @readonly
     */
    endDate?: Date;
    /**
     * List of periods during which the order is paused.
     * @readonly
     */
    pausePeriods?: PausePeriod$1[];
    /**
     * Free trial period for the order, in days.
     *
     * Only available for recurring plans.
     * @readonly
     */
    freeTrialDays?: number | null;
    /**
     * Earliest end date and time that the plan for the order can expire.
     *
     * Calculated by using the original end date plus any pause periods. Omitted if the order is active until canceled. Reserved for future use.
     * @readonly
     */
    earliestEndDate?: Date;
    /**
     * Current payment cycle for the order.
     *
     * `currentCycle` will be omitted if the order's status is `CANCELED` or `ENDED`, or if the `startDate` hasn't passed yet.
     * @readonly
     */
    currentCycle?: CurrentCycle$1;
    /**
     * Plan name at the time of purchase.
     * @readonly
     */
    planName?: string;
    /**
     * Plan description at the time of purchase
     * @readonly
     */
    planDescription?: string;
    /**
     * Plan price as it was at the moment of order creation.
     * @readonly
     */
    planPrice?: string;
    /**
     * Date and time the order was created.
     * @readonly
     */
    createdDate?: Date;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    updatedDate?: Date;
    /**
     * Information about the form submitted during the plan's checkout.
     * @readonly
     */
    formData?: FormData$1;
}
interface Buyer$1 {
    /**
     * Member ID for a Wix site member. See [Members to learn more about a site's members](https://dev.wix.com/api/rest/members/members).
     * @readonly
     */
    memberId?: string;
    /**
     * Contact ID for a Wix site contact. See [Contacts to learn more about a site's contacts](https://dev.wix.com/api/rest/contacts/contacts/contacts-v4/contact-object).
     * @readonly
     */
    contactId?: string;
}
interface PriceDetails$1 extends PriceDetailsPricingModelOneOf$1 {
    /** Order has recurring payments. */
    subscription?: Recurrence$3;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration$3;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
    /** Price of the order excluding tax, specified as a monetary amount. for example, `"9.99"`. */
    subtotal?: string;
    /** Total discount applied. */
    discount?: string;
    /** Tax applied. */
    tax?: Tax$1;
    /**
     * Price after tax and discount is applied, specified as a monetary amount. For example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     */
    total?: string;
    /** Plan price as it was at the moment of order creation. */
    planPrice?: string;
    /** Currency code. Must be valid ISO 4217 currency code (e.g., USD). */
    currency?: string;
    /** Free trial period for the order in days. Only available for recurring plans. */
    freeTrialDays?: number | null;
    /** Coupon applied to the order. Empty means no coupon was applied. */
    coupon?: Coupon$1;
}
/** @oneof */
interface PriceDetailsPricingModelOneOf$1 {
    /** Order has recurring payments. */
    subscription?: Recurrence$3;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration$3;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
}
interface Tax$1 {
    /** Name of the tax. For example, VAT. */
    name?: string;
    /** Whether tax is included in the original price. When `false`, tax is added at checkout. */
    includedInPrice?: boolean;
    /** Tax rate percentage, as a number between 0 and 100. For example, a 7% tax rate is `"7.00"`. */
    rate?: string;
    /** Total tax, specified as a monetary amount. For example, `"3.99"`. */
    amount?: string;
}
/** An object specifying how often and for how long payments recur (may be forever). */
interface Recurrence$3 {
    /** Length of one payment cycle. */
    cycleDuration?: Duration$3;
    /**
     * Amount of payment cycles this subscription is valid for.
     *
     * `0` for unlimited or until-canceled.
     */
    cycleCount?: number | null;
}
/** A duration expressed in number of time units. */
interface Duration$3 {
    /** The amount of a duration `unit` in a single payment cycle. */
    count?: number | null;
    /** Unit of time for the cycle duration. */
    unit?: PeriodUnit$3;
}
declare enum PeriodUnit$3 {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface Coupon$1 {
    /** Code of the applied coupon. */
    code?: string;
    /** Total discount of the coupon, as a monetary amount. */
    amount?: string;
    /**
     * Coupon ID.
     * @readonly
     */
    id?: string;
}
interface PricingDetails$1 extends PricingDetailsPricingModelOneOf$1 {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence$3;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration$3;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
    /**
     * Pricing details for all pricing models.
     * @readonly
     */
    prices?: SpannedPrice$1[];
}
/** @oneof */
interface PricingDetailsPricingModelOneOf$1 {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence$3;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration$3;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
}
interface SpannedPrice$1 {
    /**
     * Cycle duration to apply `price` for.
     *
     * Use with all pricing models.
     * Can apply the same price to multiple payment cycles.
     */
    duration?: PriceDuration$1;
    /** Order price. */
    price?: Price$1;
}
interface PriceDuration$1 {
    /**
     * Price starts to apply with this cycle.
     *
     * `1` is the first payment cycle for all pricing models.
     */
    cycleFrom?: number;
    /**
     * Amount of cycles to apply price for.
     *
     * For `subscription` pricing models with a finite number of cycles, the `numberOfCycles` is the same as `pricing.subscription.cycleCount`.
     *
     * For `subscription` pricing models that are unlimited or until-canceled, the `numberOfCycles` is not returned.
     *
     * For `singlePaymentForDuration` and `singlePaymentUnlimited` pricing models, the `numberOfCycles` is `1`.
     */
    numberOfCycles?: number | null;
}
interface Price$1 {
    /** Price of the order excluding tax, specified as a monetary amount. For example, `"9.99"`. */
    subtotal?: string;
    /**
     * Coupon applied to the order.
     *
     * See Coupons [to learn more about coupons](https://dev.wix.com/api/rest/coupons).
     */
    coupon?: Coupon$1;
    /** Total discount applied to the order. */
    discount?: string;
    /**
     * Tax applied to the order.
     *
     * Tax is only applied if the site [has it configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection).
     */
    tax?: Tax$1;
    /**
     * Price after tax and discount is applied. Specified as a monetary amount, for example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     */
    total?: string;
    /**
     * Three-letter currency code in
     * [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     */
    currency?: string;
    /** Price change after billing date was change and price was adjusted. Could be positive and negative values. */
    proration?: string;
}
declare enum OrderType$1 {
    UNDEFINED = "UNDEFINED",
    /** Payments made by the buyer */
    ONLINE = "ONLINE",
    /** Payments managed manually by the site owner */
    OFFLINE = "OFFLINE",
    /** Payments managed externally */
    EXTERNAL = "EXTERNAL"
}
declare enum OrderMethod$1 {
    UNKNOWN = "UNKNOWN",
    /** Mail Order / Telephone Order transaction */
    MOTO = "MOTO",
    /** Point of Sale transaction */
    POS = "POS"
}
declare enum OrderStatus$1 {
    /** Order status undefined */
    UNDEFINED = "UNDEFINED",
    /** Order created, but hasn't been paid for yet. Filtered out in ListOrders response by default. */
    DRAFT = "DRAFT",
    /** Order has been paid for, but the start date is in the future */
    PENDING = "PENDING",
    /** Order is active */
    ACTIVE = "ACTIVE",
    /** Order is paused until site owner resumes it */
    PAUSED = "PAUSED",
    /** Order has ended */
    ENDED = "ENDED",
    /** Order has been canceled */
    CANCELED = "CANCELED"
}
interface Cancellation$1 {
    /** Date and time the cancellation was requested. */
    requestedDate?: Date;
    /**
     * Reason for the cancellation. One of:
     * + `OWNER_ACTION`: Site owner canceled the order.
     * + `MEMBER_ACTION`: Buyer initiated the cancellation.
     * + `PAYMENT_FAILURE`: Payment transaction failed.
     * + `PAYMENT_SETUP_FAILURE`: Buyer's payment details weren't set up correctly.
     * + `UNKNOWN`: Reason for the cancellation is unknown.
     */
    cause?: CancellationCause$1;
    /**
     * When the cancellation takes effect. Set when cancelling the order. One of:
     * + `IMMEDIATELY`: Cancellation occurs immediately and the buyer can no longer use the plan.
     * + `NEXT_PAYMENT_DATE`: Cancellation occurs at the next payment date and time. Buyer can continue to use the plan until that date and time.
     */
    effectiveAt?: CancellationEffectiveAt$1;
}
declare enum CancellationCause$1 {
    /** Cancellation initiator undefined */
    UNDEFINED = "UNDEFINED",
    /** Order was canceled by site owner (default if canceled by user or service identity) */
    OWNER_ACTION = "OWNER_ACTION",
    /** Order was canceled by member (default if canceled by member identity) */
    MEMBER_ACTION = "MEMBER_ACTION",
    /** Order was canceled because of payment failure */
    PAYMENT_FAILURE = "PAYMENT_FAILURE",
    /** Order was canceled because of payment setup failure */
    PAYMENT_SETUP_FAILURE = "PAYMENT_SETUP_FAILURE",
    /** Order was cancelled because of an unknown reason. It's not possible to know with certain payment providers (e.g. paypal) */
    UNKNOWN = "UNKNOWN"
}
declare enum CancellationEffectiveAt$1 {
    /** Cancellation time undefined */
    UNDEFINED = "UNDEFINED",
    /** Will cancel the order now, i.e. update validUntil to the current date */
    IMMEDIATELY = "IMMEDIATELY",
    /** Will cancel the order at the date when next payment should have been made */
    NEXT_PAYMENT_DATE = "NEXT_PAYMENT_DATE"
}
declare enum PaymentStatus$1 {
    /** Payment status undefined */
    UNDEFINED = "UNDEFINED",
    /** Payment has been paid */
    PAID = "PAID",
    /** Payment has been refunded */
    REFUNDED = "REFUNDED",
    /** Recurring payment has failed */
    FAILED = "FAILED",
    /** Payment has not been paid */
    UNPAID = "UNPAID",
    /** Billing has been initialized, but actual charge is yet to be made. Can happen for free trial and PayPal */
    PENDING = "PENDING",
    /** Used in cases where the plan is free */
    NOT_APPLICABLE = "NOT_APPLICABLE"
}
interface PausePeriod$1 {
    /**
     * Status of the pause period. One of:
     *
     * + `ACTIVE`: Status while the order is [paused](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/pause-order).
     * + `ENDED`: Status when the order is [resumed](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/resume-order).
     */
    status?: Status$1;
    /** Start date and time of the pause period. */
    pauseDate?: Date;
    /**
     * End date and time of the pause period.
     *
     * Omitted while the pause period remains `ACTIVE`.
     */
    resumeDate?: Date;
}
declare enum Status$1 {
    UNDEFINED = "UNDEFINED",
    /** Order suspension is active */
    ACTIVE = "ACTIVE",
    /** Order suspension has ended */
    ENDED = "ENDED"
}
/**
 * Current cycle will be empty when order is cancelled, expired or order start date is in the future
 * Current cycle start and end dates take into account free trial days and suspensions
 */
interface CurrentCycle$1 {
    /**
     * Index of the current payment cycle in the order.
     *
     * `0` when order is in a free trial period. In all other cases, the index starts with `1`.
     */
    index?: number;
    /** Start date and time for the current payment cycle. */
    startedDate?: Date;
    /** End date and time for the current payment cycle. */
    endedDate?: Date;
}
interface FormData$1 {
    /**
     * ID of the order form associated with the plan at checkout.
     *
     * Learn more about [forms](https://dev.wix.com/docs/rest/api-reference/wix-forms/form-submissions/introduction).
     */
    formId?: string | null;
    /** ID of a submission to the plan's order form at checkout. Every time a visitor completes the checkout process for a plan, a new submission is created. */
    submissionId?: string | null;
    /**
     * Data submitted to the plan's order form at checkout.
     * @readonly
     */
    submissionData?: Record<string, any>;
}
interface MemberGetOrderRequest$1 {
    /** Order ID. */
    id: string;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set$1;
}
declare enum Set$1 {
    /** Same behavior as BASIC */
    UNKNOWN_SET = "UNKNOWN_SET",
    /**
     * Returns fields of the entity that are available in the database.
     * By default a field is available in the database unless explicitly specified in the documentation
     */
    BASIC = "BASIC",
    /**
     * Returns all fields in the entity.
     * This might make additional calls to gather the full entity
     */
    FULL = "FULL"
}
interface MemberGetOrderResponse$1 {
    /** Requested order. */
    order?: Order$1;
}
interface MemberListOrdersRequest$1 {
    /** Filter by plan IDs. */
    planIds?: string[];
    /** Filter for orders where auto renewal was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatus$1[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatus$1[];
    /** Limit the number of pricing plans returned. Default limit is 50. */
    limit?: number | null;
    /** Number of entries to offset. */
    offset?: number | null;
    /** Sorting direction (defaults to ASC) and field to sort by. [See available fields here](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort). */
    sorting?: Sorting$3;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set$1;
}
interface Sorting$3 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$3;
}
declare enum SortOrder$3 {
    ASC = "ASC",
    DESC = "DESC"
}
interface MemberListOrdersResponse$1 {
    /** Requested orders. */
    orders?: Order$1[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2$3;
}
interface PagingMetadataV2$3 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors$3;
}
interface Cursors$3 {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface RequestCancellationRequest$1 {
    /** Order ID. */
    id: string;
    /** Required. Whether to cancel the order effective immediately or at the next payment date. One-time orders can only be canceled immediately. */
    effectiveAt: CancellationEffectiveAt$1;
}
interface RequestCancellationResponse$1 {
}
interface CreateOfflineOrderRequest$1 {
    /** ID of the plan being ordered. See [Plans for more information about plan IDs](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans). */
    planId: string;
    /** ID of the member ordering the plan. See [Members for more information about member IDs](https://dev.wix.com/api/rest/members/members). */
    memberId: string;
    /**
     * Start date and time for the ordered plan.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /**
     * Whether the order is paid.
     *
     * Default: `false`
     */
    paid?: boolean | null;
    /**
     * Coupon code to apply.
     *
     * See [Coupons to learn more](https://dev.wix.com/api/rest/coupons).
     */
    couponCode?: string | null;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
interface CreateOfflineOrderResponse$1 {
    /** Order. */
    order?: Order$1;
}
interface GetOfflineOrderPreviewRequest$1 {
    /** ID of the plan of the previewed order. See [Plans for more information about plan IDs](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans). */
    planId: string;
    /** Member ID of the buyer the previewed order is for. See [Members for more information about member IDs](https://dev.wix.com/api/rest/members/members). */
    memberId: string;
    /**
     * Start date and time for plan of the previewed order.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /** Coupon code to apply. See [Coupons to learn more](https://dev.wix.com/api/rest/coupons). */
    couponCode?: string | null;
}
interface GetOfflineOrderPreviewResponse$1 {
    /** The previewed order, as if the plan had been ordered. */
    order?: Order$1;
    /**
     * Whether this previewed order would exceed the permitted amount of purchases available
     * for this plan for this buyer.
     *
     * Always `false` for plans that do not have purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
interface GetPricePreviewRequest$1 {
    /** ID of plan to preview. */
    planId: string;
    /**
     * Coupon code to apply.
     *
     * See Coupons [to learn more](https://dev.wix.com/api/rest/coupons).
     */
    couponCode?: string | null;
}
interface GetPricePreviewResponse$1 {
    /**
     * __Deprecated.__ Use `prices` instead. This property will be removed on September 30, 2022.
     * @deprecated __Deprecated.__ Use `prices` instead. This property will be removed on September 30, 2022.
     * @replacedBy prices
     * @targetRemovalDate 2022-10-01
     */
    price?: PriceDetails$1;
    /** Pricing details. */
    prices?: SpannedPrice$1[];
}
interface GetOrderRequest$1 {
    /** Order ID. */
    id: string;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set$1;
}
interface GetOrderResponse$1 {
    /** Order. */
    order?: Order$1;
}
interface ListOrdersRequest$1 {
    /** Filter by a buyer's member ID. See [Members to learn more about a site's members](https://dev.wix.com/api/rest/members/members). */
    buyerIds?: string[];
    /** Filter by plan IDs. See [Plans to learn more about pricing plans](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans). */
    planIds?: string[];
    /** Filter by whether or not the auto-renewal of recurring orders was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatus$1[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatus$1[];
    /**
     * Number of orders to return. See [Pagination](https://dev.wix.com/api/rest/getting-started/sorting-and-paging#getting-started_sorting-and-paging_paging) for more information.
     *
     * Max: `50`
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `DESC`
     */
    sorting?: Sorting$3;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set$1;
}
interface ListOrdersResponse$1 {
    /** List of orders. */
    orders?: Order$1[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2$3;
}
interface PostponeEndDateRequest$1 {
    /** Order ID. */
    id: string;
    /**
     * New end date and time.
     *
     * Must be later than the current end date and time.
     */
    endDate: Date;
}
interface PostponeEndDateResponse$1 {
}
interface CancelOrderRequest$1 {
    /** Order ID. */
    id: string;
    /** __Required.__ When the order will be canceled. One-time orders can only be canceled `IMMEDIATELY`. */
    effectiveAt: CancellationEffectiveAt$1;
}
interface CancelOrderResponse$1 {
}
interface MarkAsPaidRequest$1 {
    /** Order ID. */
    id: string;
}
interface MarkAsPaidResponse$1 {
}
interface PauseOrderRequest$1 {
    /** Order ID. */
    id: string;
}
interface PauseOrderResponse$1 {
}
interface ResumeOrderRequest$1 {
    /** Order ID. */
    id: string;
}
interface ResumeOrderResponse$1 {
}
interface BuyerNonNullableFields$1 {
    memberId: string;
    contactId: string;
}
interface DurationNonNullableFields$3 {
    unit: PeriodUnit$3;
}
interface RecurrenceNonNullableFields$3 {
    cycleDuration?: DurationNonNullableFields$3;
}
interface TaxNonNullableFields$1 {
    name: string;
    includedInPrice: boolean;
    rate: string;
    amount: string;
}
interface CouponNonNullableFields$1 {
    code: string;
    amount: string;
    id: string;
}
interface PriceDetailsNonNullableFields$1 {
    subscription?: RecurrenceNonNullableFields$3;
    singlePaymentForDuration?: DurationNonNullableFields$3;
    subtotal: string;
    discount: string;
    tax?: TaxNonNullableFields$1;
    total: string;
    planPrice: string;
    currency: string;
    coupon?: CouponNonNullableFields$1;
}
interface PriceDurationNonNullableFields$1 {
    cycleFrom: number;
}
interface FeeNonNullableFields$3 {
    name: string;
    amount: string;
}
interface PriceNonNullableFields$1 {
    subtotal: string;
    coupon?: CouponNonNullableFields$1;
    discount: string;
    tax?: TaxNonNullableFields$1;
    total: string;
    currency: string;
    fees: FeeNonNullableFields$3[];
    proration: string;
}
interface SpannedPriceNonNullableFields$1 {
    duration?: PriceDurationNonNullableFields$1;
    price?: PriceNonNullableFields$1;
}
interface PricingDetailsNonNullableFields$1 {
    subscription?: RecurrenceNonNullableFields$3;
    singlePaymentForDuration?: DurationNonNullableFields$3;
    prices: SpannedPriceNonNullableFields$1[];
}
interface CancellationNonNullableFields$1 {
    cause: CancellationCause$1;
    effectiveAt: CancellationEffectiveAt$1;
}
interface PausePeriodNonNullableFields$1 {
    status: Status$1;
}
interface CurrentCycleNonNullableFields$1 {
    index: number;
}
interface OrderCycleNonNullableFields$1 {
    index: number;
}
interface OrderNonNullableFields$1 {
    id: string;
    planId: string;
    subscriptionId: string;
    buyer?: BuyerNonNullableFields$1;
    priceDetails?: PriceDetailsNonNullableFields$1;
    pricing?: PricingDetailsNonNullableFields$1;
    type: OrderType$1;
    orderMethod: OrderMethod$1;
    status: OrderStatus$1;
    cancellation?: CancellationNonNullableFields$1;
    lastPaymentStatus: PaymentStatus$1;
    pausePeriods: PausePeriodNonNullableFields$1[];
    currentCycle?: CurrentCycleNonNullableFields$1;
    cycles: OrderCycleNonNullableFields$1[];
    planName: string;
    planDescription: string;
    planPrice: string;
    statusNew: OrderStatus$1;
}
interface MemberGetOrderResponseNonNullableFields$1 {
    order?: OrderNonNullableFields$1;
}
interface MemberListOrdersResponseNonNullableFields$1 {
    orders: OrderNonNullableFields$1[];
}
interface CreateOfflineOrderResponseNonNullableFields$1 {
    order?: OrderNonNullableFields$1;
}
interface GetOfflineOrderPreviewResponseNonNullableFields$1 {
    order?: OrderNonNullableFields$1;
    purchaseLimitExceeded: boolean;
}
interface GetPricePreviewResponseNonNullableFields$1 {
    price?: PriceDetailsNonNullableFields$1;
    prices: SpannedPriceNonNullableFields$1[];
}
interface GetOrderResponseNonNullableFields$1 {
    order?: OrderNonNullableFields$1;
}
interface ListOrdersResponseNonNullableFields$1 {
    orders: OrderNonNullableFields$1[];
}

/**
 * An order object includes all of the details related to the purchase of a Pricing Plan.
 * You can manage existing orders, create offline orders, and preview orders not yet purchased.
 *
 * Orders are based on pricing models based on the payment and duration cycles for each plan. See here to
 * [learn more about pricing models](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/introduction#wix-pricing-plans_pricing-plans_introduction_pricing-models).
 */
interface Order {
    /**
     * Order ID.
     * @readonly
     */
    _id?: string;
    /**
     * ID of the plan purchased with the order.
     * @readonly
     */
    planId?: string;
    /**
     * ID of the related Wix subscription.
     *
     * Every pricing plan order corresponds to a Wix subscription, including orders for single payment plans. See a [Pricing Plans overview](https://support.wix.com/en/article/pricing-plans-an-overview#create-plans-to-suit-your-business).
     * @readonly
     */
    subscriptionId?: string;
    /**
     * Wix Pay order ID.
     *
     * Provided by Wix whether the order is created online or offline. The field is omitted when the order is free.
     * @readonly
     */
    wixPayOrderId?: string | null;
    /**
     * The buyer's IDs. Includes `memberId` and `contactId`.
     *
     * Currently, Pricing Plan purchases are limited to members only. `contactId` is returned,
     * but a buyer will not be able to purchase a plan without a `memberId`.
     * @readonly
     */
    buyer?: Buyer;
    /**
     * @internal
     * @internal
     * @readonly
     * @deprecated __Deprecated.__ Use `pricing` instead. This property will be removed on September 30, 2022.
     * @replacedBy pricing
     * @targetRemovalDate 2022-10-01
     */
    priceDetails?: PriceDetails;
    /**
     * Pricing model, price, and payment schedule for the order.
     * @readonly
     */
    pricing?: PricingDetails;
    /**
     * How the order was processed. Supported values:
     * + `"ONLINE"`: The buyer purchased the plan using the site.
     * + `"OFFLINE"`: The buyer made a manual, offline purchase without using the site.
     * @readonly
     */
    type?: OrderType;
    /**
     * Status of the order. Supported values:
     * + `DRAFT`: Order has been initiated but payment hasn't been processed yet. The plan isn't yet available for use to the buyer.
     * + `PENDING`: Order has been purchased and its start date is set in the future.
     * + `ACTIVE`: Order has been processed. The plan is available for use.
     * + `PAUSED`: Order, and use of the plan, is [paused](#pauseorder). The order, and use of the plan, can be [resumed](#resumeorder).
     * + `ENDED`: Order has completed its duration and is no longer available for use.
     * + `CANCELED`: Order has been [canceled](#cancelorder).
     * @readonly
     */
    status?: OrderStatus;
    /**
     * Whether the order will be canceled at the next payment date.
     *
     * If `true`, the order status will be `CANCELED` and the next payment won't be charged. Omitted for single payment orders.
     * @readonly
     */
    autoRenewCanceled?: boolean | null;
    /**
     * Details about the cancellation of an order.
     *
     *
     * @readonly
     */
    cancellation?: Cancellation;
    /**
     * Status of the last payment for the order.
     * Updated automatically for online orders. Updated manually by the site owner for offline orders.
     *
     * Supported values:
     * + `PAID`: The last payment was paid.
     * + `REFUNDED`: The last payment was refunded.
     * + `FAILED`: The last payment transaction didn't complete.
     * + `UNPAID`: The last payment wasn't paid.
     * + `PENDING`: Awaiting payment.
     * + `NOT_APPLICABLE`: No payment was necessary. For example, for free plans or free trials.
     * @readonly
     */
    lastPaymentStatus?: PaymentStatus;
    /**
     * Start date and time for the ordered plan.
     * @readonly
     */
    startDate?: Date;
    /**
     * Current end date and time for the ordered plan.
     *
     * `endDate` may be updated over the course of an order. If the order is [paused](#pauseorder),
     * it will have a later `endDate` once it [resumes](#resumeorder). `endDate` may also be [postponed](#postponeenddate).
     *
     * Omitted if the order is valid until canceled and still `ACTIVE`.
     * @readonly
     */
    endDate?: Date;
    /**
     * List of periods during which the order is paused.
     * @readonly
     */
    pausePeriods?: PausePeriod[];
    /**
     * Free trial period for the order, in days.
     *
     * Only available for recurring plans.
     * @readonly
     */
    freeTrialDays?: number | null;
    /**
     * Earliest end date and time that the plan for the order can expire.
     *
     * Calculated by using the original end date plus any pause periods. Omitted if the order is active until canceled. Reserved for future use.
     * @readonly
     */
    earliestEndDate?: Date;
    /**
     * Current payment cycle for the order.
     *
     * `currentCycle` will be omitted if the order's status is `CANCELED` or `ENDED`, or if the `startDate` hasn't passed yet.
     * @readonly
     */
    currentCycle?: CurrentCycle;
    /**
     * Plan name at the time of purchase.
     * @readonly
     */
    planName?: string;
    /**
     * Plan description at the time of purchase
     * @readonly
     */
    planDescription?: string;
    /**
     * Plan price as it was at the moment of order creation.
     * @readonly
     */
    planPrice?: string;
    /**
     * Date and time the order was created.
     * @readonly
     */
    _createdDate?: Date;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    _updatedDate?: Date;
    /**
     * Information about the form submitted during the plan's checkout.
     * @readonly
     */
    formData?: FormData;
}
interface Buyer {
    /**
     * Member ID for a buyer.
     * @readonly
     */
    memberId?: string;
    /**
     * Contact ID for a buyer.
     * @readonly
     */
    contactId?: string;
}
interface PriceDetails extends PriceDetailsPricingModelOneOf {
    /** Order has recurring payments. */
    subscription?: Recurrence$2;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration$2;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
    /** Price of the order excluding tax, specified as a monetary amount. for example, `"9.99"`. */
    subtotal?: string;
    /** Total discount applied. */
    discount?: string;
    /** Tax applied. */
    tax?: Tax;
    /**
     * Price after tax and discount is applied, specified as a monetary amount. For example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     */
    total?: string;
    /** Plan price as it was at the moment of order creation. */
    planPrice?: string;
    /** Currency code. Must be valid ISO 4217 currency code (e.g., USD). */
    currency?: string;
    /** Free trial period for the order in days. Only available for recurring plans. */
    freeTrialDays?: number | null;
    /** Coupon applied to the order. Empty means no coupon was applied. */
    coupon?: Coupon;
}
/** @oneof */
interface PriceDetailsPricingModelOneOf {
    /** Order has recurring payments. */
    subscription?: Recurrence$2;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration$2;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
}
interface Tax {
    /** Name of the tax. For example, VAT. */
    name?: string;
    /** Whether tax is included in the original price. When `false`, tax is added at checkout. */
    includedInPrice?: boolean;
    /** Tax rate percentage, as a number between 0 and 100. For example, a 7% tax rate is `"7.00"`. */
    rate?: string;
    /** Total tax, specified as a monetary amount. For example, `"3.99"`. */
    amount?: string;
}
/** An object specifying how often and for how long payments recur (may be forever). */
interface Recurrence$2 {
    /** Length of one payment cycle. */
    cycleDuration?: Duration$2;
    /**
     * Amount of payment cycles this subscription is valid for.
     *
     * `0` for unlimited or until-canceled.
     */
    cycleCount?: number | null;
}
/** A duration expressed in number of time units. */
interface Duration$2 {
    /** The amount of a duration `unit` in a single payment cycle. */
    count?: number | null;
    /** Unit of time for the cycle duration. */
    unit?: PeriodUnit$2;
}
declare enum PeriodUnit$2 {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface Coupon {
    /** Code of the applied coupon. */
    code?: string;
    /** Total discount of the coupon, as a monetary amount. */
    amount?: string;
    /**
     * Coupon ID.
     * @readonly
     */
    _id?: string;
}
interface PricingDetails extends PricingDetailsPricingModelOneOf {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence$2;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration$2;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
    /**
     * Pricing details for all pricing models.
     * @readonly
     */
    prices?: SpannedPrice[];
}
/** @oneof */
interface PricingDetailsPricingModelOneOf {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence$2;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration$2;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
}
interface SpannedPrice {
    /**
     * Cycle duration to apply `price` for.
     *
     * Use with all pricing models.
     * Can apply the same price to multiple payment cycles.
     */
    duration?: PriceDuration;
    /** Order price. */
    price?: Price;
}
interface PriceDuration {
    /**
     * Price starts to apply with this cycle.
     *
     * `1` is the first payment cycle for all pricing models.
     */
    cycleFrom?: number;
    /**
     * Amount of cycles to apply price for.
     *
     * For `subscription` pricing models with a finite number of cycles, the `numberOfCycles` is the same as `pricing.subscription.cycleCount`.
     *
     * For `subscription` pricing models that are unlimited or until-canceled, the `numberOfCycles` is not returned.
     *
     * For `singlePaymentForDuration` and `singlePaymentUnlimited` pricing models, the `numberOfCycles` is `1`.
     */
    numberOfCycles?: number | null;
}
interface Price {
    /** Price of the order excluding tax, specified as a monetary amount. For example, `"9.99"`. */
    subtotal?: string;
    /** Coupon applied to the order. */
    coupon?: Coupon;
    /** Total discount applied to the order. */
    discount?: string;
    /**
     * Tax applied to the order.
     *
     * Tax is only applied if the site [has it configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection).
     */
    tax?: Tax;
    /**
     * Price after tax and discount is applied. Specified as a monetary amount, for example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     */
    total?: string;
    /**
     * Three-letter currency code in
     * [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     */
    currency?: string;
    /** Price change after billing date was change and price was adjusted. Could be positive and negative values. */
    proration?: string;
}
declare enum OrderType {
    UNDEFINED = "UNDEFINED",
    /** Payments made by the buyer */
    ONLINE = "ONLINE",
    /** Payments managed manually by the site owner */
    OFFLINE = "OFFLINE",
    /** Payments managed externally */
    EXTERNAL = "EXTERNAL"
}
declare enum OrderMethod {
    UNKNOWN = "UNKNOWN",
    /** Mail Order / Telephone Order transaction */
    MOTO = "MOTO",
    /** Point of Sale transaction */
    POS = "POS"
}
declare enum OrderStatus {
    /** Order status undefined */
    UNDEFINED = "UNDEFINED",
    /** Order created, but hasn't been paid for yet. Filtered out in ListOrders response by default. */
    DRAFT = "DRAFT",
    /** Order has been paid for, but the start date is in the future */
    PENDING = "PENDING",
    /** Order is active */
    ACTIVE = "ACTIVE",
    /** Order is paused until site owner resumes it */
    PAUSED = "PAUSED",
    /** Order has ended */
    ENDED = "ENDED",
    /** Order has been canceled */
    CANCELED = "CANCELED"
}
interface Cancellation {
    /** Date and time the cancellation was requested. */
    requestedDate?: Date;
    /**
     * Reason for the cancellation. One of:
     * + `OWNER_ACTION`: Site owner canceled the order.
     * + `MEMBER_ACTION`: Buyer initiated the cancellation.
     * + `PAYMENT_FAILURE`: Payment transaction failed.
     * + `PAYMENT_SETUP_FAILURE`: Buyer's payment details weren't set up correctly.
     * + `UNKNOWN`: Reason for the cancellation is unknown.
     */
    cause?: CancellationCause;
    /**
     * When the cancellation takes effect. Set when cancelling the order. One of:
     * + `IMMEDIATELY`: Cancellation occurs immediately and the buyer can no longer use the plan.
     * + `NEXT_PAYMENT_DATE`: Cancellation occurs at the next payment date and time. Buyer can continue to use the plan until that date and time.
     */
    effectiveAt?: CancellationEffectiveAt;
}
declare enum CancellationCause {
    /** Cancellation initiator undefined */
    UNDEFINED = "UNDEFINED",
    /** Order was canceled by site owner (default if canceled by user or service identity) */
    OWNER_ACTION = "OWNER_ACTION",
    /** Order was canceled by member (default if canceled by member identity) */
    MEMBER_ACTION = "MEMBER_ACTION",
    /** Order was canceled because of payment failure */
    PAYMENT_FAILURE = "PAYMENT_FAILURE",
    /** Order was canceled because of payment setup failure */
    PAYMENT_SETUP_FAILURE = "PAYMENT_SETUP_FAILURE",
    /** Order was cancelled because of an unknown reason. It's not possible to know with certain payment providers (e.g. paypal) */
    UNKNOWN = "UNKNOWN"
}
declare enum CancellationEffectiveAt {
    /** Cancellation time undefined */
    UNDEFINED = "UNDEFINED",
    /** Will cancel the order now, i.e. update validUntil to the current date */
    IMMEDIATELY = "IMMEDIATELY",
    /** Will cancel the order at the date when next payment should have been made */
    NEXT_PAYMENT_DATE = "NEXT_PAYMENT_DATE"
}
declare enum PaymentStatus {
    /** Payment status undefined */
    UNDEFINED = "UNDEFINED",
    /** Payment has been paid */
    PAID = "PAID",
    /** Payment has been refunded */
    REFUNDED = "REFUNDED",
    /** Recurring payment has failed */
    FAILED = "FAILED",
    /** Payment has not been paid */
    UNPAID = "UNPAID",
    /** Billing has been initialized, but actual charge is yet to be made. Can happen for free trial and PayPal */
    PENDING = "PENDING",
    /** Used in cases where the plan is free */
    NOT_APPLICABLE = "NOT_APPLICABLE"
}
interface PausePeriod {
    /**
     * Status of the pause period. Supported values:
     * + `ACTIVE`: Status while the order is [paused](#pauseorder).
     * + `ENDED`: Status when the order is [resumed](#resumeorder).
     */
    status?: Status;
    /** Start date and time of the pause period. */
    pauseDate?: Date;
    /**
     * End date and time of the pause period.
     *
     * Omitted while the pause period remains `ACTIVE`.
     */
    resumeDate?: Date;
}
declare enum Status {
    UNDEFINED = "UNDEFINED",
    /** Order suspension is active */
    ACTIVE = "ACTIVE",
    /** Order suspension has ended */
    ENDED = "ENDED"
}
/**
 * Current cycle will be empty when order is cancelled, expired or order start date is in the future
 * Current cycle start and end dates take into account free trial days and suspensions
 */
interface CurrentCycle {
    /**
     * Index of the current payment cycle in the order.
     *
     * `0` when order is in a free trial period. In all other cases, the index starts with `1`.
     */
    index?: number;
    /** Start date and time for the current payment cycle. */
    startedDate?: Date;
    /** End date and time for the current payment cycle. */
    endedDate?: Date;
}
interface FormData {
    /** ID of the form associated with the plan at checkout. */
    formId?: string | null;
    /** ID of a submission to the plan's order form at checkout. Every time a visitor completes the checkout process for a plan, a new submission is created. */
    submissionId?: string | null;
    /**
     * Data submitted to the plan's order form at checkout.
     *
     * This field is returned when a method's `fieldset` is set to `"FULL"`.
     *
     * @readonly
     */
    submissionData?: Record<string, any>;
}
interface MemberGetOrderRequest {
    /** Order ID. */
    _id: string;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
declare enum Set {
    /** Same behavior as BASIC */
    UNKNOWN_SET = "UNKNOWN_SET",
    /**
     * Returns fields of the entity that are available in the database.
     * By default a field is available in the database unless explicitly specified in the documentation
     */
    BASIC = "BASIC",
    /**
     * Returns all fields in the entity.
     * This might make additional calls to gather the full entity
     */
    FULL = "FULL"
}
interface MemberGetOrderResponse {
    /** Requested order. */
    order?: Order;
}
interface MemberListOrdersRequest {
    /** Filter by plan IDs. */
    planIds?: string[];
    /** Filter for orders where auto renewal was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatus[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatus[];
    /** Limit the number of pricing plans returned. Default limit is 50. */
    limit?: number | null;
    /** Number of entries to offset. */
    offset?: number | null;
    /** Sorting direction (defaults to ASC) and field to sort by. [See available fields here](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort). */
    sorting?: Sorting$2;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface Sorting$2 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$2;
}
declare enum SortOrder$2 {
    ASC = "ASC",
    DESC = "DESC"
}
interface MemberListOrdersResponse {
    /** List of orders. */
    orders?: Order[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2$2;
}
interface PagingMetadataV2$2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors$2;
}
interface Cursors$2 {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface RequestCancellationRequest {
    /** Order ID. */
    _id: string;
    /**
     * Whether to cancel the order immediately or at the next payment date.
     * One-time payment orders can only be canceled immediately.
     *
     * Supported values:
     * - `"IMMEDIATELY"`: Indicates that the order should be canceled immediately.
     * - `"NEXT_PAYMENT_DATE"`: Indicates that the order be canceled at the next payment date.
     */
    effectiveAt: CancellationEffectiveAt;
}
interface RequestCancellationResponse {
}
interface CreateOfflineOrderRequest {
    /** ID of the plan being ordered. */
    planId: string;
    /** ID of the member ordering the plan. */
    memberId: string;
    /**
     * Start date and time for the ordered plan.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /**
     * Whether the order is paid.
     *
     * Default: `false`
     */
    paid?: boolean | null;
    /**
     * Coupon code to apply.
     *
     * See [Coupons to learn more](https://dev.wix.com/api/rest/coupons).
     */
    couponCode?: string | null;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
interface CreateOfflineOrderResponse {
    /** Order. */
    order?: Order;
}
interface GetOfflineOrderPreviewRequest {
    /** ID of the plan of the previewed order. See [Plans for more information about plan IDs](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans). */
    planId: string;
    /** Member ID of the buyer the previewed order is for. */
    memberId: string;
    /**
     * Start date and time for plan of the previewed order.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /** Coupon code to apply. See [Coupons to learn more](https://dev.wix.com/api/rest/coupons). */
    couponCode?: string | null;
}
interface GetOfflineOrderPreviewResponse {
    /** The previewed order, as if the plan had been ordered. */
    order?: Order;
    /**
     * Whether this previewed order would exceed the permitted amount of purchases available
     * for this plan for this buyer.
     *
     * Always `false` for plans that do not have purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
interface GetPricePreviewRequest {
    /** ID of plan to preview. */
    planId: string;
    /**
     * Coupon code to apply.
     *
     * See Coupons [to learn more](https://dev.wix.com/api/rest/coupons).
     */
    couponCode?: string | null;
}
interface GetPricePreviewResponse {
    /**
     * @internal
     * @internal
     * @deprecated __Deprecated.__ Use `prices` instead. This property will be removed on September 30, 2022.
     * @replacedBy prices
     * @targetRemovalDate 2022-10-01
     */
    price?: PriceDetails;
    /** Pricing details. */
    prices?: SpannedPrice[];
}
interface GetOrderRequest {
    /** Order ID. */
    _id: string;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface GetOrderResponse {
    /** Order. */
    order?: Order;
}
interface ListOrdersRequest {
    /** Filter by a buyer's member ID. See [Members to learn more about a site's members](https://dev.wix.com/api/rest/members/members). */
    buyerIds?: string[];
    /** Filter by plan IDs. See [Plans to learn more about pricing plans](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans). */
    planIds?: string[];
    /** Filter by whether or not the auto-renewal of recurring orders was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatus[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatus[];
    /**
     * Number of orders to return. See [Pagination](https://dev.wix.com/api/rest/getting-started/sorting-and-paging#getting-started_sorting-and-paging_paging) for more information.
     *
     * Max: `50`
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `DESC`
     */
    sorting?: Sorting$2;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface ListOrdersResponse {
    /** List of orders. */
    orders?: Order[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2$2;
}
interface PostponeEndDateRequest {
    /** Order ID. */
    _id: string;
    /**
     * New end date and time.
     *
     * Must be later than the current end date and time.
     */
    endDate: Date;
}
interface PostponeEndDateResponse {
}
interface CancelOrderRequest {
    /** Order ID. */
    _id: string;
    /**
     * When the order is canceled.
     *
     * One time orders can only be canceled immediately. Supported values:
     * - `"IMMEDIATELY"`: The order is canceled immediately.
     * - `"NEXT_PAYMENT_DATE"`: The order is canceled at the next payment date.
     */
    effectiveAt: CancellationEffectiveAt;
}
interface CancelOrderResponse {
}
interface MarkAsPaidRequest {
    /** Order ID. */
    _id: string;
}
interface MarkAsPaidResponse {
}
interface PauseOrderRequest {
    /** Order ID. */
    _id: string;
}
interface PauseOrderResponse {
}
interface ResumeOrderRequest {
    /** Order ID. */
    _id: string;
}
interface ResumeOrderResponse {
}
interface BuyerNonNullableFields {
    memberId: string;
    contactId: string;
}
interface DurationNonNullableFields$2 {
    unit: PeriodUnit$2;
}
interface RecurrenceNonNullableFields$2 {
    cycleDuration?: DurationNonNullableFields$2;
}
interface TaxNonNullableFields {
    name: string;
    includedInPrice: boolean;
    rate: string;
    amount: string;
}
interface CouponNonNullableFields {
    code: string;
    amount: string;
    _id: string;
}
interface PriceDetailsNonNullableFields {
    subscription?: RecurrenceNonNullableFields$2;
    singlePaymentForDuration?: DurationNonNullableFields$2;
    subtotal: string;
    discount: string;
    tax?: TaxNonNullableFields;
    total: string;
    planPrice: string;
    currency: string;
    coupon?: CouponNonNullableFields;
}
interface PriceDurationNonNullableFields {
    cycleFrom: number;
}
interface FeeNonNullableFields$2 {
    name: string;
    amount: string;
}
interface PriceNonNullableFields {
    subtotal: string;
    coupon?: CouponNonNullableFields;
    discount: string;
    tax?: TaxNonNullableFields;
    total: string;
    currency: string;
    fees: FeeNonNullableFields$2[];
    proration: string;
}
interface SpannedPriceNonNullableFields {
    duration?: PriceDurationNonNullableFields;
    price?: PriceNonNullableFields;
}
interface PricingDetailsNonNullableFields {
    subscription?: RecurrenceNonNullableFields$2;
    singlePaymentForDuration?: DurationNonNullableFields$2;
    prices: SpannedPriceNonNullableFields[];
}
interface CancellationNonNullableFields {
    cause: CancellationCause;
    effectiveAt: CancellationEffectiveAt;
}
interface PausePeriodNonNullableFields {
    status: Status;
}
interface CurrentCycleNonNullableFields {
    index: number;
}
interface OrderCycleNonNullableFields {
    index: number;
}
interface OrderNonNullableFields {
    _id: string;
    planId: string;
    subscriptionId: string;
    buyer?: BuyerNonNullableFields;
    priceDetails?: PriceDetailsNonNullableFields;
    pricing?: PricingDetailsNonNullableFields;
    type: OrderType;
    orderMethod: OrderMethod;
    status: OrderStatus;
    cancellation?: CancellationNonNullableFields;
    lastPaymentStatus: PaymentStatus;
    pausePeriods: PausePeriodNonNullableFields[];
    currentCycle?: CurrentCycleNonNullableFields;
    cycles: OrderCycleNonNullableFields[];
    planName: string;
    planDescription: string;
    planPrice: string;
    statusNew: OrderStatus;
}
interface MemberGetOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
interface MemberListOrdersResponseNonNullableFields {
    orders: OrderNonNullableFields[];
}
interface CreateOfflineOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
interface GetOfflineOrderPreviewResponseNonNullableFields {
    order?: OrderNonNullableFields;
    purchaseLimitExceeded: boolean;
}
interface GetPricePreviewResponseNonNullableFields {
    price?: PriceDetailsNonNullableFields;
    prices: SpannedPriceNonNullableFields[];
}
interface GetOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
interface ListOrdersResponseNonNullableFields {
    orders: OrderNonNullableFields[];
}

type __PublicMethodMetaInfo$1<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function memberGetOrder(): __PublicMethodMetaInfo$1<'GET', {
    id: string;
}, MemberGetOrderRequest, MemberGetOrderRequest$1, MemberGetOrderResponse & MemberGetOrderResponseNonNullableFields, MemberGetOrderResponse$1 & MemberGetOrderResponseNonNullableFields$1>;
declare function memberListOrders(): __PublicMethodMetaInfo$1<'GET', {}, MemberListOrdersRequest, MemberListOrdersRequest$1, MemberListOrdersResponse & MemberListOrdersResponseNonNullableFields, MemberListOrdersResponse$1 & MemberListOrdersResponseNonNullableFields$1>;
declare function requestCancellation(): __PublicMethodMetaInfo$1<'POST', {
    id: string;
}, RequestCancellationRequest, RequestCancellationRequest$1, RequestCancellationResponse, RequestCancellationResponse$1>;
declare function createOfflineOrder(): __PublicMethodMetaInfo$1<'POST', {}, CreateOfflineOrderRequest, CreateOfflineOrderRequest$1, CreateOfflineOrderResponse & CreateOfflineOrderResponseNonNullableFields, CreateOfflineOrderResponse$1 & CreateOfflineOrderResponseNonNullableFields$1>;
declare function getOfflineOrderPreview(): __PublicMethodMetaInfo$1<'POST', {}, GetOfflineOrderPreviewRequest, GetOfflineOrderPreviewRequest$1, GetOfflineOrderPreviewResponse & GetOfflineOrderPreviewResponseNonNullableFields, GetOfflineOrderPreviewResponse$1 & GetOfflineOrderPreviewResponseNonNullableFields$1>;
declare function getPricePreview(): __PublicMethodMetaInfo$1<'POST', {}, GetPricePreviewRequest, GetPricePreviewRequest$1, GetPricePreviewResponse & GetPricePreviewResponseNonNullableFields, GetPricePreviewResponse$1 & GetPricePreviewResponseNonNullableFields$1>;
declare function managementGetOrder(): __PublicMethodMetaInfo$1<'GET', {
    id: string;
}, GetOrderRequest, GetOrderRequest$1, GetOrderResponse & GetOrderResponseNonNullableFields, GetOrderResponse$1 & GetOrderResponseNonNullableFields$1>;
declare function managementListOrders(): __PublicMethodMetaInfo$1<'GET', {}, ListOrdersRequest, ListOrdersRequest$1, ListOrdersResponse & ListOrdersResponseNonNullableFields, ListOrdersResponse$1 & ListOrdersResponseNonNullableFields$1>;
declare function postponeEndDate(): __PublicMethodMetaInfo$1<'PATCH', {
    id: string;
}, PostponeEndDateRequest, PostponeEndDateRequest$1, PostponeEndDateResponse, PostponeEndDateResponse$1>;
declare function cancelOrder(): __PublicMethodMetaInfo$1<'POST', {
    id: string;
}, CancelOrderRequest, CancelOrderRequest$1, CancelOrderResponse, CancelOrderResponse$1>;
declare function markAsPaid(): __PublicMethodMetaInfo$1<'POST', {
    id: string;
}, MarkAsPaidRequest, MarkAsPaidRequest$1, MarkAsPaidResponse, MarkAsPaidResponse$1>;
declare function pauseOrder(): __PublicMethodMetaInfo$1<'POST', {
    id: string;
}, PauseOrderRequest, PauseOrderRequest$1, PauseOrderResponse, PauseOrderResponse$1>;
declare function resumeOrder(): __PublicMethodMetaInfo$1<'POST', {
    id: string;
}, ResumeOrderRequest, ResumeOrderRequest$1, ResumeOrderResponse, ResumeOrderResponse$1>;

declare const meta$1_cancelOrder: typeof cancelOrder;
declare const meta$1_createOfflineOrder: typeof createOfflineOrder;
declare const meta$1_getOfflineOrderPreview: typeof getOfflineOrderPreview;
declare const meta$1_getPricePreview: typeof getPricePreview;
declare const meta$1_managementGetOrder: typeof managementGetOrder;
declare const meta$1_managementListOrders: typeof managementListOrders;
declare const meta$1_markAsPaid: typeof markAsPaid;
declare const meta$1_memberGetOrder: typeof memberGetOrder;
declare const meta$1_memberListOrders: typeof memberListOrders;
declare const meta$1_pauseOrder: typeof pauseOrder;
declare const meta$1_postponeEndDate: typeof postponeEndDate;
declare const meta$1_requestCancellation: typeof requestCancellation;
declare const meta$1_resumeOrder: typeof resumeOrder;
declare namespace meta$1 {
  export { type __PublicMethodMetaInfo$1 as __PublicMethodMetaInfo, meta$1_cancelOrder as cancelOrder, meta$1_createOfflineOrder as createOfflineOrder, meta$1_getOfflineOrderPreview as getOfflineOrderPreview, meta$1_getPricePreview as getPricePreview, meta$1_managementGetOrder as managementGetOrder, meta$1_managementListOrders as managementListOrders, meta$1_markAsPaid as markAsPaid, meta$1_memberGetOrder as memberGetOrder, meta$1_memberListOrders as memberListOrders, meta$1_pauseOrder as pauseOrder, meta$1_postponeEndDate as postponeEndDate, meta$1_requestCancellation as requestCancellation, meta$1_resumeOrder as resumeOrder };
}

/** Information about the pricing plan. */
interface Plan$1 {
    /**
     * Plan ID.
     * @readonly
     */
    id?: string;
    /** Plan name. */
    name?: string | null;
    /** Plan description. */
    description?: string | null;
    /** What is included with this plan (e.g., 1 weekly entrance to a specific class). */
    perks?: StringList$1;
    /** Plan price, payment schedule, and expiration. */
    pricing?: Pricing$1;
    /** Whether the plan is public (visible to site visitors and members). */
    public?: boolean | null;
    /**
     * Whether the plan is archived. Archived plans are not visible and can't be purchased anymore, but existing purchases remain in effect.
     * @readonly
     */
    archived?: boolean;
    /**
     * Whether the plan is marked as primary.
     * @readonly
     */
    primary?: boolean;
    /**
     * Whether the plan has any orders (including pending and unpaid orders).
     * @readonly
     */
    hasOrders?: boolean;
    /**
     * Date plan was created.
     * @readonly
     */
    createdDate?: Date;
    /**
     * Date plan was last updated.
     * @readonly
     */
    updatedDate?: Date;
    /**
     * URL-friendly version of plan name. Unique across all plans in the same site.
     * @readonly
     */
    slug?: string | null;
    /**
     * Number of times the same buyer can purchase the plan. Currently limited to support:
     * - Empty value or a value of `0`, meaning no limitation.
     * - Value of `1`, meaning limited to one purchase per buyer.
     */
    maxPurchasesPerBuyer?: number | null;
    /** Whether the buyer can start the plan at a later date. Defaults to false. */
    allowFutureStartDate?: boolean | null;
    /** Whether the buyer is allowed to cancel their plan. Defaults to false. */
    buyerCanCancel?: boolean | null;
    /** Any terms and conditions that apply to the plan. This information will be displayed during checkout. */
    termsAndConditions?: string | null;
    /**
     * ID of the form associated with the plan at checkout.
     *
     * Learn more about [forms](https://support.wix.com/en/article/wix-forms-an-overview).
     */
    formId?: string | null;
}
/** This wrapper type exist in order to distinguish an empty string list from no list at all in update requests. */
interface StringList$1 {
    values?: string[];
}
/** Plan pricing information. Includes the price of the plan and payment details. */
interface Pricing$1 extends PricingPricingModelOneOf$1 {
    /** Plan has recurring payments. */
    subscription?: Recurrence$1;
    /** One time payment, plan is valid for the specified duration. */
    singlePaymentForDuration?: Duration$1;
    /** One time payment, plan is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
    /** Amount for a single payment (or the whole subscription if it's not a recurring plan) */
    price?: Money$1;
    /** Free trial period for the plan in days. It’s available only for recurring plans. Set to 0 to remove free trial. */
    freeTrialDays?: number | null;
}
/** @oneof */
interface PricingPricingModelOneOf$1 {
    /** Plan has recurring payments. */
    subscription?: Recurrence$1;
    /** One time payment, plan is valid for the specified duration. */
    singlePaymentForDuration?: Duration$1;
    /** One time payment, plan is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
}
/** An object specifying how often and for how long payments recur (may be forever). */
interface Recurrence$1 {
    /** Length of one payment cycle. */
    cycleDuration?: Duration$1;
    /**
     * Amount of payment cycles this subscription is valid for.
     *
     * `0` for unlimited or until-canceled.
     */
    cycleCount?: number | null;
}
/** A duration expressed in number of time units. */
interface Duration$1 {
    /** The amount of a duration `unit` in a single payment cycle. */
    count?: number | null;
    /** Unit of time for the cycle duration. */
    unit?: PeriodUnit$1;
}
declare enum PeriodUnit$1 {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface Money$1 {
    /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). */
    value?: string;
    /** Currency code. Must be valid ISO 4217 currency code (e.g., USD). */
    currency?: string;
}
declare enum AppliedAt$1 {
    UNKNOWN_CHARGE_EVENT = "UNKNOWN_CHARGE_EVENT",
    /** Will charge the fee on first payment. If order has a free trial meaning it will charge after the free trial. */
    FIRST_PAYMENT = "FIRST_PAYMENT"
}
interface ListPublicPlansRequest$1 {
    /** Number of items to list. Defaults to 75. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
    limit?: number | null;
    /** Number of items to skip. Defaults to 0. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
    offset?: number | null;
    /** IDs of plans to list. Non-existent IDs will be ignored and won't cause errors. You can pass a maximum of 100 IDs. */
    planIds?: string[];
}
interface ListPublicPlansResponse$1 {
    /** List of public pricing plans. */
    plans?: PublicPlan$1[];
    /** Object containing paging-related data (number of plans returned, offset). */
    pagingMetadata?: PagingMetadataV2$1;
}
/** Public plan entity containing information about the pricing plan. Can be read by any site member or visitor. */
interface PublicPlan$1 {
    /** Plan ID. */
    id?: string;
    /** Plan name. */
    name?: string | null;
    /** Plan description. */
    description?: string | null;
    /** What is included with this plan (e.g., 1 weekly entrance to a specific class). */
    perks?: StringList$1;
    /** Plan price, payment schedule, and expiration. */
    pricing?: Pricing$1;
    /** Whether the plan is marked as primary. */
    primary?: boolean;
    /** Date plan was created. */
    createdDate?: Date;
    /** Date plan was last updated. */
    updatedDate?: Date;
    /** URL-friendly version of plan name. Unique across all plans in the same site. */
    slug?: string | null;
    /** Number of times the same buyer can purchase the plan. An empty value or a value of zero means no limitation. */
    maxPurchasesPerBuyer?: number | null;
    /** Whether the buyer can start the plan at a later date. Defaults to false. */
    allowFutureStartDate?: boolean | null;
    /** Whether the buyer is allowed to cancel their plan. Defaults to false. */
    buyerCanCancel?: boolean | null;
    /** Any terms and conditions that apply to the plan. This information will be displayed during checkout. */
    termsAndConditions?: string | null;
    /**
     * ID of the form associated with the plan at checkout.
     *
     * Learn more about [forms](https://support.wix.com/en/article/wix-forms-an-overview).
     */
    formId?: string | null;
}
interface PagingMetadataV2$1 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors$1;
}
interface Cursors$1 {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface QueryPublicPlansRequest$1 {
    /** Query */
    query?: QueryV2$1;
}
interface QueryV2$1 {
    /** A filter object. See [supported fields and operators](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/filter-and-sort#wix-pricing-plans_pricing-plans_plans_filter-and-sort_query-public-plans) */
    filter?: Record<string, any> | null;
    /** Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}] */
    sort?: Sorting$1[];
    /** Pointer to page of results using offset. Can not be used together with 'cursorPaging' */
    paging?: Paging$1;
}
interface Sorting$1 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$1;
}
declare enum SortOrder$1 {
    ASC = "ASC",
    DESC = "DESC"
}
interface Paging$1 {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface QueryPublicPlansResponse$1 {
    /** List of public pricing plans that match the specified query. */
    plans?: PublicPlan$1[];
    /** Object containing paging-related data (number of plans returned, offset). */
    pagingMetadata?: PagingMetadataV2$1;
}
interface GetPlanRequest$1 {
    /** Plan ID. */
    id: string;
}
interface GetPlanResponse$1 {
    /** Pricing plan. */
    plan?: Plan$1;
}
interface ListPlansRequest$1 {
    /** Archived filter. Defaults to ACTIVE (not archived) only. */
    archived?: ArchivedFilter$1;
    /** Visibility filter. Defaults to PUBLIC_AND_HIDDEN (meaning, both are listed). */
    public?: PublicFilter$1;
    /** Number of pricing plans to list. Defaults to 75. */
    limit?: number | null;
    /** Number of pricing plans to skip. Defaults to 0. */
    offset?: number | null;
    /** Plan ID filter. Non-existent IDs are ignored, and won't cause errors. You can pass a maximum of 100 IDs. */
    planIds?: string[];
}
declare enum ArchivedFilter$1 {
    /** Returns all plans that are active. */
    ACTIVE = "ACTIVE",
    /** Returns all plans that are archived. */
    ARCHIVED = "ARCHIVED",
    /** Returns all plans that are active and archived. */
    ARCHIVED_AND_ACTIVE = "ARCHIVED_AND_ACTIVE"
}
declare enum PublicFilter$1 {
    /** Returns all public and hidden plans. */
    PUBLIC_AND_HIDDEN = "PUBLIC_AND_HIDDEN",
    /** Returns only public plans. */
    PUBLIC = "PUBLIC",
    /** Returns only hidden plans. */
    HIDDEN = "HIDDEN"
}
interface ListPlansResponse$1 {
    /** List of all public and hidden pricing plans. */
    plans?: Plan$1[];
    /** Object containing paging-related data (number of plans returned, offset). */
    pagingMetadata?: PagingMetadataV2$1;
}
interface GetPlanStatsRequest$1 {
}
interface GetPlanStatsResponse$1 {
    /** Total number of plans created, including active plans (both public and hidden) and archived plans. */
    totalPlans?: number;
}
interface CreatePlanRequest$1 {
    /** Plan to be created. */
    plan: Plan$1;
}
interface CreatePlanResponse$1 {
    /** Plan that was created. */
    plan?: Plan$1;
}
interface UpdatePlanRequest$1 {
    /** Plan to be updated. */
    plan: Plan$1;
}
interface UpdatePlanResponse$1 {
    /** Plan that was updated. */
    plan?: Plan$1;
}
interface SetPlanVisibilityRequest$1 {
    /** Plan id. */
    id: string;
    /** If true, the Pricing Plan is visible. */
    visible: boolean;
}
interface SetPlanVisibilityResponse$1 {
    /** Pricing plan. */
    plan?: Plan$1;
}
interface MakePlanPrimaryRequest$1 {
    id: string;
}
interface MakePlanPrimaryResponse$1 {
    /** Pricing plan. */
    plan?: Plan$1;
}
interface ClearPrimaryRequest$1 {
}
interface ClearPrimaryResponse$1 {
}
interface ArchivePlanRequest$1 {
    id: string;
}
interface ArchivePlanResponse$1 {
    /** Archived plan. */
    plan?: Plan$1;
}
interface StringListNonNullableFields$1 {
    values: string[];
}
interface DurationNonNullableFields$1 {
    unit: PeriodUnit$1;
}
interface RecurrenceNonNullableFields$1 {
    cycleDuration?: DurationNonNullableFields$1;
}
interface MoneyNonNullableFields$1 {
    value: string;
    currency: string;
}
interface FeeNonNullableFields$1 {
    name: string;
    amount: string;
}
interface FeeConfigNonNullableFields$1 {
    fee?: FeeNonNullableFields$1;
    appliedAt: AppliedAt$1;
}
interface PricingNonNullableFields$1 {
    subscription?: RecurrenceNonNullableFields$1;
    singlePaymentForDuration?: DurationNonNullableFields$1;
    price?: MoneyNonNullableFields$1;
    feeConfigs: FeeConfigNonNullableFields$1[];
}
interface PublicPlanNonNullableFields$1 {
    id: string;
    perks?: StringListNonNullableFields$1;
    pricing?: PricingNonNullableFields$1;
    primary: boolean;
}
interface ListPublicPlansResponseNonNullableFields$1 {
    plans: PublicPlanNonNullableFields$1[];
}
interface QueryPublicPlansResponseNonNullableFields$1 {
    plans: PublicPlanNonNullableFields$1[];
}
interface PlanNonNullableFields$1 {
    id: string;
    perks?: StringListNonNullableFields$1;
    pricing?: PricingNonNullableFields$1;
    archived: boolean;
    primary: boolean;
    hasOrders: boolean;
}
interface GetPlanResponseNonNullableFields$1 {
    plan?: PlanNonNullableFields$1;
}
interface ListPlansResponseNonNullableFields$1 {
    plans: PlanNonNullableFields$1[];
}
interface GetPlanStatsResponseNonNullableFields$1 {
    totalPlans: number;
}
interface CreatePlanResponseNonNullableFields$1 {
    plan?: PlanNonNullableFields$1;
}
interface UpdatePlanResponseNonNullableFields$1 {
    plan?: PlanNonNullableFields$1;
}
interface SetPlanVisibilityResponseNonNullableFields$1 {
    plan?: PlanNonNullableFields$1;
}
interface MakePlanPrimaryResponseNonNullableFields$1 {
    plan?: PlanNonNullableFields$1;
}
interface ArchivePlanResponseNonNullableFields$1 {
    plan?: PlanNonNullableFields$1;
}

/** Information about the pricing plan. */
interface Plan {
    /**
     * Plan ID.
     * @readonly
     */
    _id?: string;
    /** Plan name. */
    name?: string | null;
    /** Plan description. */
    description?: string | null;
    /**
     * List of text strings that promote what is included with this plan.
     *
     * For example, "Plenty of parking" or "Free gift on your birthday".
     */
    perks?: StringList;
    /** Plan price, payment schedule, and expiration. */
    pricing?: Pricing;
    /** Whether the plan is public (visible to site visitors and members). */
    public?: boolean | null;
    /**
     * Whether the plan is archived. Archived plans are not visible and can't be purchased anymore, but existing purchases remain in effect.
     * @readonly
     */
    archived?: boolean;
    /**
     * Whether the plan is marked as primary. If `true`, the plan is highlighted on the site with a custom ribbon.
     *
     * Default: `false`.
     * @readonly
     */
    primary?: boolean;
    /**
     * Whether the plan has any orders (including pending and unpaid orders).
     * @readonly
     */
    hasOrders?: boolean;
    /**
     * Date plan was created.
     * @readonly
     */
    _createdDate?: Date;
    /**
     * Date plan was last updated.
     * @readonly
     */
    _updatedDate?: Date;
    /**
     * URL-friendly version of plan name. Unique across all plans in the same site.
     * @readonly
     */
    slug?: string | null;
    /**
     * Number of times the same buyer can purchase the plan. Currently limited to support:
     * - Empty value or a value of `0`, meaning no limitation.
     * - Value of `1`, meaning limited to one purchase per buyer.
     */
    maxPurchasesPerBuyer?: number | null;
    /**
     * Whether the buyer can start the plan at a later date.
     *
     * Default: `false`.
     *
     */
    allowFutureStartDate?: boolean | null;
    /**
     * Whether the buyer is allowed to cancel their plan. If `false`, calling the [`requestCancellation()`](https://www.wix.com/velo/reference/wix-pricing-plans-v2/orders/requestcancellation) function returns an error.
     *
     * Default: `true`.
     *
     */
    buyerCanCancel?: boolean | null;
    /** Any terms and conditions that apply to the plan. This information will be displayed during checkout. */
    termsAndConditions?: string | null;
    /** ID of the form associated with the plan at checkout. */
    formId?: string | null;
}
/** This wrapper type exist in order to distinguish an empty string list from no list at all in update requests. */
interface StringList {
    values?: string[];
}
/** Plan pricing information. Includes the price of the plan and payment details. */
interface Pricing extends PricingPricingModelOneOf {
    /**
     * Pricing model indicating that the plan has recurring payments.
     *
     * Note: This type of subscription is not a "Wix subscription," which encompasses various types of subscriptions, such as Wix Stores subscriptions, Wix invoice subscriptions, and *all* pricing plan models.
     */
    subscription?: Recurrence;
    /** Pricing model indicating a single payment per cycle and the length of the cycle. The cycle is the duration of the plan, not a payment cycle. */
    singlePaymentForDuration?: Duration;
    /** Pricing model indicating the plan is paid in one single payment. The plan is valid until canceled.   */
    singlePaymentUnlimited?: boolean | null;
    /** Amount for a single payment. For subscriptions, this is the amount to pay each payment cycle and it is required. For plans that are not recurring plans, it is the single payment amount for the whole subscription.  */
    price?: Money;
    /** Free trial period for the plan in days. Available only for recurring plans, meaning plans whose pricing model is `subscription`. Set to `0` to remove the free trial.  */
    freeTrialDays?: number | null;
}
/** @oneof */
interface PricingPricingModelOneOf {
    /** Plan has recurring payments. */
    subscription?: Recurrence;
    /** One time payment, plan is valid for the specified duration. */
    singlePaymentForDuration?: Duration;
    /** One time payment, plan is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
}
/** An object specifying how often and for how long payments recur (may be forever). */
interface Recurrence {
    /** Length of one payment cycle. For example, 1 month to have monthly payments. Multiply `cycleDuration`'s `count` by `cycleCount` to get the subscription duration. Currently, only a value of `1` is supported.  */
    cycleDuration?: Duration;
    /**
     * Amount of payment cycles the subscription is valid for.
     *
     * `0` for unlimited plans or for plans that are valid until canceled.
     */
    cycleCount?: number | null;
}
/** A duration expressed in number of time units. */
interface Duration {
    /** Number of days days, months, weeks, or years in a single payment cycle. Currently limited to support only `1`.  */
    count?: number | null;
    /** Unit of time for the cycle duration. */
    unit?: PeriodUnit;
}
declare enum PeriodUnit {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface Money {
    /** Monetary amount. Decimal string with a period as a decimal separator. For example, `'3.99'`. Cannot be a negative value.   */
    value?: string;
    /**
     * Currency code. Three-letter currency code in
     * [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format. For example, `'USD'`.
     */
    currency?: string;
}
declare enum AppliedAt {
    UNKNOWN_CHARGE_EVENT = "UNKNOWN_CHARGE_EVENT",
    /** Will charge the fee on first payment. If order has a free trial meaning it will charge after the free trial. */
    FIRST_PAYMENT = "FIRST_PAYMENT"
}
interface ListPublicPlansRequest {
    /**
     * Number of pricing plans to list.
     *
     * Default: `75`.
     */
    limit?: number | null;
    /**
     * Number of pricing plans to skip.
     *
     * Default: `0`.
     */
    offset?: number | null;
    /** IDs of public plans to list. If non-existent IDs are specified, they are ignored and don't cause errors. If no IDs are specified, all public are listed according to the [order](#arrangeplans) displayed in the Dashboard. You can pass a maximum of 100 IDs.  */
    planIds?: string[];
}
interface ListPublicPlansResponse {
    /** List of public pricing plans. */
    plans?: PublicPlan[];
    /** Details on the paged set of public pricing plans returned.  */
    pagingMetadata?: PagingMetadataV2;
}
/** Public plan entity containing information about the pricing plan. Can be read by any site member or visitor. */
interface PublicPlan {
    /** Plan ID. */
    _id?: string;
    /** Plan name. */
    name?: string | null;
    /** Plan description. */
    description?: string | null;
    /** What is included with this plan (e.g., 1 weekly entrance to a specific class). */
    perks?: StringList;
    /** Plan price, payment schedule, and expiration. */
    pricing?: Pricing;
    /** Whether the plan is marked as primary. */
    primary?: boolean;
    /** Date plan was created. */
    _createdDate?: Date;
    /** Date plan was last updated. */
    _updatedDate?: Date;
    /** URL-friendly version of plan name. Unique across all plans in the same site. */
    slug?: string | null;
    /** Number of times the same buyer can purchase the plan. An empty value or a value of zero means no limitation. */
    maxPurchasesPerBuyer?: number | null;
    /** Whether the buyer can start the plan at a later date. Defaults to false. */
    allowFutureStartDate?: boolean | null;
    /** Whether the buyer is allowed to cancel their plan. Defaults to false. */
    buyerCanCancel?: boolean | null;
    /** Any terms and conditions that apply to the plan. This information will be displayed during checkout. */
    termsAndConditions?: string | null;
    /** ID of the form associated with the plan at checkout. */
    formId?: string | null;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface QueryPublicPlansRequest {
    /** Query */
    query?: QueryV2;
}
interface QueryV2 {
    /** A filter object. See [supported fields and operators](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/filter-and-sort#wix-pricing-plans_pricing-plans_plans_filter-and-sort_query-public-plans) */
    filter?: Record<string, any> | null;
    /** Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}] */
    sort?: Sorting[];
    /** Pointer to page of results using offset. Can not be used together with 'cursorPaging' */
    paging?: Paging;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface QueryPublicPlansResponse {
    /** List of public pricing plans that match the specified query. */
    plans?: PublicPlan[];
    /** Object containing paging-related data (number of plans returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
interface GetPlanRequest {
    /** Plan ID. */
    _id: string;
}
interface GetPlanResponse {
    /** Pricing plan info.  */
    plan?: Plan;
}
interface ListPlansRequest {
    /**
     * Archived filter.
     *
     * Default: `ACTIVE` (not archived).
     */
    archived?: ArchivedFilter;
    /**
     * Visibility filter.
     *
     * Default: `PUBLIC_AND_HIDDEN` (meaning, both public and hidden plans are listed).
     *
     */
    public?: PublicFilter;
    /**
     * Number of pricing plans to list.
     *
     * Default: `75`.
     */
    limit?: number | null;
    /**
     * Number of pricing plans to skip.
     *
     * Default: `0`.
     */
    offset?: number | null;
    /** IDs of plans to list. If non-existent IDs are specified, they are ignored and don't cause errors. If no IDs are specified, all public and hidden plans (based on `options`) are listed according to the [order](#arrangeplans) displayed in the Dashboard. You can pass a maximum of 100 IDs.  */
    planIds?: string[];
}
declare enum ArchivedFilter {
    /** Returns all plans that are active. */
    ACTIVE = "ACTIVE",
    /** Returns all plans that are archived. */
    ARCHIVED = "ARCHIVED",
    /** Returns all plans that are active and archived. */
    ARCHIVED_AND_ACTIVE = "ARCHIVED_AND_ACTIVE"
}
declare enum PublicFilter {
    /** Returns all public and hidden plans. */
    PUBLIC_AND_HIDDEN = "PUBLIC_AND_HIDDEN",
    /** Returns only public plans. */
    PUBLIC = "PUBLIC",
    /** Returns only hidden plans. */
    HIDDEN = "HIDDEN"
}
interface ListPlansResponse {
    /** List of all public and hidden pricing plans. */
    plans?: Plan[];
    /** Details on the paged set of pricing plans returned.  */
    pagingMetadata?: PagingMetadataV2;
}
interface GetPlanStatsRequest {
}
interface GetPlanStatsResponse {
    /** Total number of plans created, including active plans (both public and hidden) and archived plans. */
    totalPlans?: number;
}
interface CreatePlanRequest {
    /** Information for the plan being created. */
    plan: Plan;
}
interface CreatePlanResponse {
    /** Plan info.  */
    plan?: Plan;
}
interface UpdatePlanRequest {
    /** Plan info to update. */
    plan: Plan;
}
interface UpdatePlanResponse {
    /** Updated plan info. */
    plan?: Plan;
}
interface SetPlanVisibilityRequest {
    /** The ID of the plan to either display or hide on the site page.  */
    _id: string;
    /** Whether to set the plan as visible. */
    visible: boolean;
}
interface SetPlanVisibilityResponse {
    /** Plan info.  */
    plan?: Plan;
}
interface MakePlanPrimaryRequest {
    /** ID of the pricing plan to set as the primary plan. */
    _id: string;
}
interface MakePlanPrimaryResponse {
    /** Primary plan info. */
    plan?: Plan;
}
interface ClearPrimaryRequest {
}
interface ClearPrimaryResponse {
}
interface ArchivePlanRequest {
    _id: string;
}
interface ArchivePlanResponse {
    /** Archived plan info.  */
    plan?: Plan;
}
interface StringListNonNullableFields {
    values: string[];
}
interface DurationNonNullableFields {
    unit: PeriodUnit;
}
interface RecurrenceNonNullableFields {
    cycleDuration?: DurationNonNullableFields;
}
interface MoneyNonNullableFields {
    value: string;
    currency: string;
}
interface FeeNonNullableFields {
    name: string;
    amount: string;
}
interface FeeConfigNonNullableFields {
    fee?: FeeNonNullableFields;
    appliedAt: AppliedAt;
}
interface PricingNonNullableFields {
    subscription?: RecurrenceNonNullableFields;
    singlePaymentForDuration?: DurationNonNullableFields;
    price?: MoneyNonNullableFields;
    feeConfigs: FeeConfigNonNullableFields[];
}
interface PublicPlanNonNullableFields {
    _id: string;
    perks?: StringListNonNullableFields;
    pricing?: PricingNonNullableFields;
    primary: boolean;
}
interface ListPublicPlansResponseNonNullableFields {
    plans: PublicPlanNonNullableFields[];
}
interface QueryPublicPlansResponseNonNullableFields {
    plans: PublicPlanNonNullableFields[];
}
interface PlanNonNullableFields {
    _id: string;
    perks?: StringListNonNullableFields;
    pricing?: PricingNonNullableFields;
    archived: boolean;
    primary: boolean;
    hasOrders: boolean;
}
interface GetPlanResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface ListPlansResponseNonNullableFields {
    plans: PlanNonNullableFields[];
}
interface GetPlanStatsResponseNonNullableFields {
    totalPlans: number;
}
interface CreatePlanResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface UpdatePlanResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface SetPlanVisibilityResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface MakePlanPrimaryResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface ArchivePlanResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function listPublicPlans(): __PublicMethodMetaInfo<'GET', {}, ListPublicPlansRequest, ListPublicPlansRequest$1, ListPublicPlansResponse & ListPublicPlansResponseNonNullableFields, ListPublicPlansResponse$1 & ListPublicPlansResponseNonNullableFields$1>;
declare function queryPublicPlans(): __PublicMethodMetaInfo<'POST', {}, QueryPublicPlansRequest, QueryPublicPlansRequest$1, QueryPublicPlansResponse & QueryPublicPlansResponseNonNullableFields, QueryPublicPlansResponse$1 & QueryPublicPlansResponseNonNullableFields$1>;
declare function getPlan(): __PublicMethodMetaInfo<'GET', {
    id: string;
}, GetPlanRequest, GetPlanRequest$1, GetPlanResponse & GetPlanResponseNonNullableFields, GetPlanResponse$1 & GetPlanResponseNonNullableFields$1>;
declare function listPlans(): __PublicMethodMetaInfo<'GET', {}, ListPlansRequest, ListPlansRequest$1, ListPlansResponse & ListPlansResponseNonNullableFields, ListPlansResponse$1 & ListPlansResponseNonNullableFields$1>;
declare function getPlanStats(): __PublicMethodMetaInfo<'GET', {}, GetPlanStatsRequest, GetPlanStatsRequest$1, GetPlanStatsResponse & GetPlanStatsResponseNonNullableFields, GetPlanStatsResponse$1 & GetPlanStatsResponseNonNullableFields$1>;
declare function createPlan(): __PublicMethodMetaInfo<'POST', {}, CreatePlanRequest, CreatePlanRequest$1, CreatePlanResponse & CreatePlanResponseNonNullableFields, CreatePlanResponse$1 & CreatePlanResponseNonNullableFields$1>;
declare function updatePlan(): __PublicMethodMetaInfo<'PATCH', {
    planId: string;
}, UpdatePlanRequest, UpdatePlanRequest$1, UpdatePlanResponse & UpdatePlanResponseNonNullableFields, UpdatePlanResponse$1 & UpdatePlanResponseNonNullableFields$1>;
declare function setPlanVisibility(): __PublicMethodMetaInfo<'PUT', {
    id: string;
}, SetPlanVisibilityRequest, SetPlanVisibilityRequest$1, SetPlanVisibilityResponse & SetPlanVisibilityResponseNonNullableFields, SetPlanVisibilityResponse$1 & SetPlanVisibilityResponseNonNullableFields$1>;
declare function makePlanPrimary(): __PublicMethodMetaInfo<'POST', {
    id: string;
}, MakePlanPrimaryRequest, MakePlanPrimaryRequest$1, MakePlanPrimaryResponse & MakePlanPrimaryResponseNonNullableFields, MakePlanPrimaryResponse$1 & MakePlanPrimaryResponseNonNullableFields$1>;
declare function clearPrimary(): __PublicMethodMetaInfo<'POST', {}, ClearPrimaryRequest, ClearPrimaryRequest$1, ClearPrimaryResponse, ClearPrimaryResponse$1>;
declare function archivePlan(): __PublicMethodMetaInfo<'POST', {
    id: string;
}, ArchivePlanRequest, ArchivePlanRequest$1, ArchivePlanResponse & ArchivePlanResponseNonNullableFields, ArchivePlanResponse$1 & ArchivePlanResponseNonNullableFields$1>;

type meta___PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = __PublicMethodMetaInfo<K, M, T, S, Q, R>;
declare const meta_archivePlan: typeof archivePlan;
declare const meta_clearPrimary: typeof clearPrimary;
declare const meta_createPlan: typeof createPlan;
declare const meta_getPlan: typeof getPlan;
declare const meta_getPlanStats: typeof getPlanStats;
declare const meta_listPlans: typeof listPlans;
declare const meta_listPublicPlans: typeof listPublicPlans;
declare const meta_makePlanPrimary: typeof makePlanPrimary;
declare const meta_queryPublicPlans: typeof queryPublicPlans;
declare const meta_setPlanVisibility: typeof setPlanVisibility;
declare const meta_updatePlan: typeof updatePlan;
declare namespace meta {
  export { type meta___PublicMethodMetaInfo as __PublicMethodMetaInfo, meta_archivePlan as archivePlan, meta_clearPrimary as clearPrimary, meta_createPlan as createPlan, meta_getPlan as getPlan, meta_getPlanStats as getPlanStats, meta_listPlans as listPlans, meta_listPublicPlans as listPublicPlans, meta_makePlanPrimary as makePlanPrimary, meta_queryPublicPlans as queryPublicPlans, meta_setPlanVisibility as setPlanVisibility, meta_updatePlan as updatePlan };
}

export { meta$1 as orders, meta as plans };
