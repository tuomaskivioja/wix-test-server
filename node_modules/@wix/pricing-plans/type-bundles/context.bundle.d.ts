type HostModule$1<T, H extends Host$1> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI$1<T extends HostModule$1<any, any>> = T extends HostModule$1<infer U, any> ? U : never;
type Host$1<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor$1<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient$1) => T;
interface HttpClient$1 {
    request<TResponse, TData = any>(req: RequestOptionsFactory$1<TResponse, TData>): Promise<HttpResponse$1<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory$1<TResponse = any, TData = any> = (context: any) => RequestOptions$1<TResponse, TData>;
type HttpResponse$1<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions$1<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata$1;
type APIMetadata$1 = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction$1<T extends RESTFunctionDescriptor$1> = T extends RESTFunctionDescriptor$1<infer U> ? U : never;
type EventDefinition$3<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition$3<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition$3<Payload, Type>;
type EventHandler$3<T extends EventDefinition$3> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition$3<T extends EventDefinition$3<any, string>> = (handler: EventHandler$3<T>) => void;

type ServicePluginMethodInput$1 = {
    request: any;
    metadata: any;
};
type ServicePluginContract$1 = Record<string, (payload: ServicePluginMethodInput$1) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata$1 = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput$1;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition$1<Contract extends ServicePluginContract$1> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata$1[];
    __contract: Contract;
};
declare function ServicePluginDefinition$1<Contract extends ServicePluginContract$1>(componentType: string, methods: ServicePluginMethodMetadata$1[]): ServicePluginDefinition$1<Contract>;
type BuildServicePluginDefinition$1<T extends ServicePluginDefinition$1<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE$1 = "wix_spi_error";

type RequestContext$1 = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer$1 = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method$1 = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions$1<T = any> = {
    _?: T;
    url?: string;
    method?: Method$1;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer$1 | ResponseTransformer$1[];
};
type AmbassadorFactory$1<Request, Response> = (payload: Request) => ((context: RequestContext$1) => AmbassadorRequestOptions$1<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor$1<Request = any, Response = any> = AmbassadorFactory$1<Request, Response>;
type BuildAmbassadorFunction$1<T extends AmbassadorFunctionDescriptor$1> = T extends AmbassadorFunctionDescriptor$1<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol$1: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject$1 = {[emptyObjectSymbol$1]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual$1<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter$1<KeyType, ExcludeType> = IsEqual$1<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions$1 = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except$1<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions$1 = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter$1<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys$1<Base, Condition> = NonNullable<
// Wrap in `NonNullable` to strip away the `undefined` type from the produced union.
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key since the condition passes.
		? Key
	// Discard this key since the condition fails.
		: never;

	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base]
>;

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept$1<Base, Condition> = Except$1<
Base,
ConditionalKeys$1<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors$1 = RESTFunctionDescriptor$1 | AmbassadorFunctionDescriptor$1 | HostModule$1<any, any> | EventDefinition$3<any> | ServicePluginDefinition$1<any> | {
    [key: string]: Descriptors$1 | PublicMetadata$1 | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors$1<T extends Descriptors$1, H extends Host$1<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE$1;
    } ? never : T extends AmbassadorFunctionDescriptor$1 ? BuildAmbassadorFunction$1<T> : T extends RESTFunctionDescriptor$1 ? BuildRESTFunction$1<T> : T extends EventDefinition$3<any> ? BuildEventDefinition$3<T> : T extends ServicePluginDefinition$1<any> ? BuildServicePluginDefinition$1<T> : T extends HostModule$1<any, any> ? HostModuleAPI$1<T> : ConditionalExcept$1<{
        [Key in keyof T]: T[Key] extends Descriptors$1 ? BuildDescriptors$1<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject$1>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata$1 = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext$1<T extends Descriptors$1> = globalThis.ContextualClient extends {
    host: Host$1;
} ? BuildDescriptors$1<T, globalThis.ContextualClient['host']> : T;

/**
 * An order object includes all of the details related to the purchase of a Pricing Plan.
 * You can manage existing orders, create offline orders, and preview orders not yet purchased.
 *
 * Orders are based on pricing models based on the payment and duration cycles for each plan. See here to
 * [learn more about pricing models](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/introduction#wix-pricing-plans_pricing-plans_introduction_pricing-models).
 */
interface Order {
    /**
     * Order ID.
     * @readonly
     */
    _id?: string;
    /**
     * ID of the plan purchased with the order.
     * @readonly
     */
    planId?: string;
    /**
     * ID of the related Wix subscription.
     *
     * Every pricing plan order corresponds to a Wix subscription, including orders for single payment plans. See a [Pricing Plans overview](https://support.wix.com/en/article/pricing-plans-an-overview#create-plans-to-suit-your-business).
     * @readonly
     */
    subscriptionId?: string;
    /**
     * Wix Pay order ID.
     *
     * Provided by Wix whether the order is created online or offline. The field is omitted when the order is free.
     * @readonly
     */
    wixPayOrderId?: string | null;
    /**
     * The buyer's IDs. Includes `memberId` and `contactId`.
     *
     * Currently, Pricing Plan purchases are limited to members only. `contactId` is returned,
     * but a buyer will not be able to purchase a plan without a `memberId`.
     * @readonly
     */
    buyer?: Buyer;
    /**
     * @internal
     * @internal
     * @readonly
     * @deprecated __Deprecated.__ Use `pricing` instead. This property will be removed on September 30, 2022.
     * @replacedBy pricing
     * @targetRemovalDate 2022-10-01
     */
    priceDetails?: PriceDetails;
    /**
     * Pricing model, price, and payment schedule for the order.
     * @readonly
     */
    pricing?: PricingDetails;
    /**
     * How the order was processed. Supported values:
     * + `"ONLINE"`: The buyer purchased the plan using the site.
     * + `"OFFLINE"`: The buyer made a manual, offline purchase without using the site.
     * @readonly
     */
    type?: OrderType;
    /**
     * Status of the order. Supported values:
     * + `DRAFT`: Order has been initiated but payment hasn't been processed yet. The plan isn't yet available for use to the buyer.
     * + `PENDING`: Order has been purchased and its start date is set in the future.
     * + `ACTIVE`: Order has been processed. The plan is available for use.
     * + `PAUSED`: Order, and use of the plan, is [paused](#pauseorder). The order, and use of the plan, can be [resumed](#resumeorder).
     * + `ENDED`: Order has completed its duration and is no longer available for use.
     * + `CANCELED`: Order has been [canceled](#cancelorder).
     * @readonly
     */
    status?: OrderStatus;
    /**
     * Whether the order will be canceled at the next payment date.
     *
     * If `true`, the order status will be `CANCELED` and the next payment won't be charged. Omitted for single payment orders.
     * @readonly
     */
    autoRenewCanceled?: boolean | null;
    /**
     * Details about the cancellation of an order.
     *
     *
     * @readonly
     */
    cancellation?: Cancellation;
    /**
     * Status of the last payment for the order.
     * Updated automatically for online orders. Updated manually by the site owner for offline orders.
     *
     * Supported values:
     * + `PAID`: The last payment was paid.
     * + `REFUNDED`: The last payment was refunded.
     * + `FAILED`: The last payment transaction didn't complete.
     * + `UNPAID`: The last payment wasn't paid.
     * + `PENDING`: Awaiting payment.
     * + `NOT_APPLICABLE`: No payment was necessary. For example, for free plans or free trials.
     * @readonly
     */
    lastPaymentStatus?: PaymentStatus;
    /**
     * Start date and time for the ordered plan.
     * @readonly
     */
    startDate?: Date;
    /**
     * Current end date and time for the ordered plan.
     *
     * `endDate` may be updated over the course of an order. If the order is [paused](#pauseorder),
     * it will have a later `endDate` once it [resumes](#resumeorder). `endDate` may also be [postponed](#postponeenddate).
     *
     * Omitted if the order is valid until canceled and still `ACTIVE`.
     * @readonly
     */
    endDate?: Date;
    /**
     * List of periods during which the order is paused.
     * @readonly
     */
    pausePeriods?: PausePeriod[];
    /**
     * Free trial period for the order, in days.
     *
     * Only available for recurring plans.
     * @readonly
     */
    freeTrialDays?: number | null;
    /**
     * Earliest end date and time that the plan for the order can expire.
     *
     * Calculated by using the original end date plus any pause periods. Omitted if the order is active until canceled. Reserved for future use.
     * @readonly
     */
    earliestEndDate?: Date;
    /**
     * Current payment cycle for the order.
     *
     * `currentCycle` will be omitted if the order's status is `CANCELED` or `ENDED`, or if the `startDate` hasn't passed yet.
     * @readonly
     */
    currentCycle?: CurrentCycle;
    /**
     * Plan name at the time of purchase.
     * @readonly
     */
    planName?: string;
    /**
     * Plan description at the time of purchase
     * @readonly
     */
    planDescription?: string;
    /**
     * Plan price as it was at the moment of order creation.
     * @readonly
     */
    planPrice?: string;
    /**
     * Date and time the order was created.
     * @readonly
     */
    _createdDate?: Date;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    _updatedDate?: Date;
    /**
     * Information about the form submitted during the plan's checkout.
     * @readonly
     */
    formData?: FormData;
}
interface Buyer {
    /**
     * Member ID for a buyer.
     * @readonly
     */
    memberId?: string;
    /**
     * Contact ID for a buyer.
     * @readonly
     */
    contactId?: string;
}
interface PriceDetails extends PriceDetailsPricingModelOneOf {
    /** Order has recurring payments. */
    subscription?: Recurrence$1;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration$1;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
    /** Price of the order excluding tax, specified as a monetary amount. for example, `"9.99"`. */
    subtotal?: string;
    /** Total discount applied. */
    discount?: string;
    /** Tax applied. */
    tax?: Tax;
    /**
     * Price after tax and discount is applied, specified as a monetary amount. For example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     */
    total?: string;
    /** Plan price as it was at the moment of order creation. */
    planPrice?: string;
    /** Currency code. Must be valid ISO 4217 currency code (e.g., USD). */
    currency?: string;
    /** Free trial period for the order in days. Only available for recurring plans. */
    freeTrialDays?: number | null;
    /** Coupon applied to the order. Empty means no coupon was applied. */
    coupon?: Coupon;
}
/** @oneof */
interface PriceDetailsPricingModelOneOf {
    /** Order has recurring payments. */
    subscription?: Recurrence$1;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration$1;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
}
interface Tax {
    /** Name of the tax. For example, VAT. */
    name?: string;
    /** Whether tax is included in the original price. When `false`, tax is added at checkout. */
    includedInPrice?: boolean;
    /** Tax rate percentage, as a number between 0 and 100. For example, a 7% tax rate is `"7.00"`. */
    rate?: string;
    /** Total tax, specified as a monetary amount. For example, `"3.99"`. */
    amount?: string;
}
/** An object specifying how often and for how long payments recur (may be forever). */
interface Recurrence$1 {
    /** Length of one payment cycle. */
    cycleDuration?: Duration$1;
    /**
     * Amount of payment cycles this subscription is valid for.
     *
     * `0` for unlimited or until-canceled.
     */
    cycleCount?: number | null;
}
/** A duration expressed in number of time units. */
interface Duration$1 {
    /** The amount of a duration `unit` in a single payment cycle. */
    count?: number | null;
    /** Unit of time for the cycle duration. */
    unit?: PeriodUnit$1;
}
declare enum PeriodUnit$1 {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface Coupon {
    /** Code of the applied coupon. */
    code?: string;
    /** Total discount of the coupon, as a monetary amount. */
    amount?: string;
    /**
     * Coupon ID.
     * @readonly
     */
    _id?: string;
}
interface PricingDetails extends PricingDetailsPricingModelOneOf {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence$1;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration$1;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
    /**
     * Pricing details for all pricing models.
     * @readonly
     */
    prices?: SpannedPrice[];
}
/** @oneof */
interface PricingDetailsPricingModelOneOf {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence$1;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration$1;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
}
interface SpannedPrice {
    /**
     * Cycle duration to apply `price` for.
     *
     * Use with all pricing models.
     * Can apply the same price to multiple payment cycles.
     */
    duration?: PriceDuration;
    /** Order price. */
    price?: Price;
}
interface PriceDuration {
    /**
     * Price starts to apply with this cycle.
     *
     * `1` is the first payment cycle for all pricing models.
     */
    cycleFrom?: number;
    /**
     * Amount of cycles to apply price for.
     *
     * For `subscription` pricing models with a finite number of cycles, the `numberOfCycles` is the same as `pricing.subscription.cycleCount`.
     *
     * For `subscription` pricing models that are unlimited or until-canceled, the `numberOfCycles` is not returned.
     *
     * For `singlePaymentForDuration` and `singlePaymentUnlimited` pricing models, the `numberOfCycles` is `1`.
     */
    numberOfCycles?: number | null;
}
interface Price {
    /** Price of the order excluding tax, specified as a monetary amount. For example, `"9.99"`. */
    subtotal?: string;
    /** Coupon applied to the order. */
    coupon?: Coupon;
    /** Total discount applied to the order. */
    discount?: string;
    /**
     * Tax applied to the order.
     *
     * Tax is only applied if the site [has it configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection).
     */
    tax?: Tax;
    /**
     * Price after tax and discount is applied. Specified as a monetary amount, for example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     */
    total?: string;
    /**
     * Three-letter currency code in
     * [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     */
    currency?: string;
    /** Price change after billing date was change and price was adjusted. Could be positive and negative values. */
    proration?: string;
}
interface Fee$1 {
    /** Fee name */
    name?: string;
    /** Amount of fee to be charged */
    amount?: string;
}
declare enum OrderType {
    UNDEFINED = "UNDEFINED",
    /** Payments made by the buyer */
    ONLINE = "ONLINE",
    /** Payments managed manually by the site owner */
    OFFLINE = "OFFLINE",
    /** Payments managed externally */
    EXTERNAL = "EXTERNAL"
}
declare enum OrderMethod {
    UNKNOWN = "UNKNOWN",
    /** Mail Order / Telephone Order transaction */
    MOTO = "MOTO",
    /** Point of Sale transaction */
    POS = "POS"
}
declare enum OrderStatus {
    /** Order status undefined */
    UNDEFINED = "UNDEFINED",
    /** Order created, but hasn't been paid for yet. Filtered out in ListOrders response by default. */
    DRAFT = "DRAFT",
    /** Order has been paid for, but the start date is in the future */
    PENDING = "PENDING",
    /** Order is active */
    ACTIVE = "ACTIVE",
    /** Order is paused until site owner resumes it */
    PAUSED = "PAUSED",
    /** Order has ended */
    ENDED = "ENDED",
    /** Order has been canceled */
    CANCELED = "CANCELED"
}
interface Cancellation {
    /** Date and time the cancellation was requested. */
    requestedDate?: Date;
    /**
     * Reason for the cancellation. One of:
     * + `OWNER_ACTION`: Site owner canceled the order.
     * + `MEMBER_ACTION`: Buyer initiated the cancellation.
     * + `PAYMENT_FAILURE`: Payment transaction failed.
     * + `PAYMENT_SETUP_FAILURE`: Buyer's payment details weren't set up correctly.
     * + `UNKNOWN`: Reason for the cancellation is unknown.
     */
    cause?: CancellationCause;
    /**
     * When the cancellation takes effect. Set when cancelling the order. One of:
     * + `IMMEDIATELY`: Cancellation occurs immediately and the buyer can no longer use the plan.
     * + `NEXT_PAYMENT_DATE`: Cancellation occurs at the next payment date and time. Buyer can continue to use the plan until that date and time.
     */
    effectiveAt?: CancellationEffectiveAt;
}
declare enum CancellationCause {
    /** Cancellation initiator undefined */
    UNDEFINED = "UNDEFINED",
    /** Order was canceled by site owner (default if canceled by user or service identity) */
    OWNER_ACTION = "OWNER_ACTION",
    /** Order was canceled by member (default if canceled by member identity) */
    MEMBER_ACTION = "MEMBER_ACTION",
    /** Order was canceled because of payment failure */
    PAYMENT_FAILURE = "PAYMENT_FAILURE",
    /** Order was canceled because of payment setup failure */
    PAYMENT_SETUP_FAILURE = "PAYMENT_SETUP_FAILURE",
    /** Order was cancelled because of an unknown reason. It's not possible to know with certain payment providers (e.g. paypal) */
    UNKNOWN = "UNKNOWN"
}
declare enum CancellationEffectiveAt {
    /** Cancellation time undefined */
    UNDEFINED = "UNDEFINED",
    /** Will cancel the order now, i.e. update validUntil to the current date */
    IMMEDIATELY = "IMMEDIATELY",
    /** Will cancel the order at the date when next payment should have been made */
    NEXT_PAYMENT_DATE = "NEXT_PAYMENT_DATE"
}
declare enum PaymentStatus {
    /** Payment status undefined */
    UNDEFINED = "UNDEFINED",
    /** Payment has been paid */
    PAID = "PAID",
    /** Payment has been refunded */
    REFUNDED = "REFUNDED",
    /** Recurring payment has failed */
    FAILED = "FAILED",
    /** Payment has not been paid */
    UNPAID = "UNPAID",
    /** Billing has been initialized, but actual charge is yet to be made. Can happen for free trial and PayPal */
    PENDING = "PENDING",
    /** Used in cases where the plan is free */
    NOT_APPLICABLE = "NOT_APPLICABLE"
}
interface PausePeriod {
    /**
     * Status of the pause period. Supported values:
     * + `ACTIVE`: Status while the order is [paused](#pauseorder).
     * + `ENDED`: Status when the order is [resumed](#resumeorder).
     */
    status?: Status;
    /** Start date and time of the pause period. */
    pauseDate?: Date;
    /**
     * End date and time of the pause period.
     *
     * Omitted while the pause period remains `ACTIVE`.
     */
    resumeDate?: Date;
}
declare enum Status {
    UNDEFINED = "UNDEFINED",
    /** Order suspension is active */
    ACTIVE = "ACTIVE",
    /** Order suspension has ended */
    ENDED = "ENDED"
}
/**
 * Current cycle will be empty when order is cancelled, expired or order start date is in the future
 * Current cycle start and end dates take into account free trial days and suspensions
 */
interface CurrentCycle {
    /**
     * Index of the current payment cycle in the order.
     *
     * `0` when order is in a free trial period. In all other cases, the index starts with `1`.
     */
    index?: number;
    /** Start date and time for the current payment cycle. */
    startedDate?: Date;
    /** End date and time for the current payment cycle. */
    endedDate?: Date;
}
/** Order cycle start and end dates take into account free trial days and suspensions */
interface OrderCycle {
    /**
     * Index of this cycle in the order.
     *
     * `0` when order is in a free trial period. In all other cases, the index starts with `1`.
     */
    index?: number;
    /** Start date and time for this order cycle. */
    startedDate?: Date;
    /** End date and time for this order cycle. */
    endedDate?: Date;
}
interface FormData {
    /** ID of the form associated with the plan at checkout. */
    formId?: string | null;
    /** ID of a submission to the plan's order form at checkout. Every time a visitor completes the checkout process for a plan, a new submission is created. */
    submissionId?: string | null;
    /**
     * Data submitted to the plan's order form at checkout.
     *
     * This field is returned when a method's `fieldset` is set to `"FULL"`.
     *
     * @readonly
     */
    submissionData?: Record<string, any>;
}
interface DomainEvent$1 extends DomainEventBodyOneOf$1 {
    createdEvent?: EntityCreatedEvent$1;
    updatedEvent?: EntityUpdatedEvent$1;
    deletedEvent?: EntityDeletedEvent$1;
    actionEvent?: ActionEvent$1;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf$1 {
    createdEvent?: EntityCreatedEvent$1;
    updatedEvent?: EntityUpdatedEvent$1;
    deletedEvent?: EntityDeletedEvent$1;
    actionEvent?: ActionEvent$1;
}
interface EntityCreatedEvent$1 {
    entity?: string;
}
interface RestoreInfo$1 {
    deletedDate?: Date;
}
interface EntityUpdatedEvent$1 {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent$1 {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
interface ActionEvent$1 {
    body?: string;
}
interface Empty {
}
interface MemberGetOrderRequest {
    /** Order ID. */
    _id: string;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
declare enum Set {
    /** Same behavior as BASIC */
    UNKNOWN_SET = "UNKNOWN_SET",
    /**
     * Returns fields of the entity that are available in the database.
     * By default a field is available in the database unless explicitly specified in the documentation
     */
    BASIC = "BASIC",
    /**
     * Returns all fields in the entity.
     * This might make additional calls to gather the full entity
     */
    FULL = "FULL"
}
interface MemberGetOrderResponse {
    /** Requested order. */
    order?: Order;
}
interface MemberListOrdersRequest {
    /** Filter by plan IDs. */
    planIds?: string[];
    /** Filter for orders where auto renewal was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatus[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatus[];
    /** Limit the number of pricing plans returned. Default limit is 50. */
    limit?: number | null;
    /** Number of entries to offset. */
    offset?: number | null;
    /** Sorting direction (defaults to ASC) and field to sort by. [See available fields here](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort). */
    sorting?: Sorting$1;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface Sorting$1 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$1;
}
declare enum SortOrder$1 {
    ASC = "ASC",
    DESC = "DESC"
}
interface MemberListOrdersResponse {
    /** List of orders. */
    orders?: Order[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2$1;
}
interface PagingMetadataV2$1 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors$1;
}
interface Cursors$1 {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
/**
 * TODO: Write orders filter and sort docs page
 * Retrieves a list of up to 1,000 orders, based on the provided paging, [sorting, and filtering](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort).
 */
interface QueryOrdersRequest {
    /** [See available fields here](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort). */
    query?: QueryV2$1;
}
interface QueryV2$1 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging$1;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting$1[];
    /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
    fields?: string[];
    /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
    fieldsets?: string[];
}
/** @oneof */
interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging$1;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Paging$1 {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryOrdersResponse {
    /** Order data. */
    plans?: Order[];
    /** Paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2$1;
}
interface RequestCancellationRequest {
    /** Order ID. */
    _id: string;
    /**
     * Whether to cancel the order immediately or at the next payment date.
     * One-time payment orders can only be canceled immediately.
     *
     * Supported values:
     * - `"IMMEDIATELY"`: Indicates that the order should be canceled immediately.
     * - `"NEXT_PAYMENT_DATE"`: Indicates that the order be canceled at the next payment date.
     */
    effectiveAt: CancellationEffectiveAt;
}
interface RequestCancellationResponse {
}
/**
 * Emitted when an order is canceled immediately or when cycle ends for an order with canceled auto renewal
 *
 * To determine the specific reason of the cancellation check `order.cancellation.cause` field.
 */
interface OrderCanceled {
    /** Canceled order. */
    order?: Order;
}
interface MessageEnvelope$1 {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData$1;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData$1 extends IdentificationDataIdOneOf$1 {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType$1;
}
/** @oneof */
interface IdentificationDataIdOneOf$1 {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
declare enum WebhookIdentityType$1 {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface CreateOnlineOrderRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Provided if checkout is initiated on buyer's behalf. */
    onBehalf?: OnBehalf;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
interface OnBehalf {
    /** Member ID. */
    memberId?: string;
    /** Method by which checkout is initiated on buyer's behalf */
    orderMethod?: OrderMethod;
}
interface CreateOnlineOrderResponse {
    /** Order. */
    order?: Order;
}
interface CouponsError {
    /** Coupon code. */
    couponCode?: string;
    /** Plan ID. */
    planId?: string;
}
interface CreateGuestOnlineOrderRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Captcha data to prove you are not a robot */
    captcha?: Captcha;
    /** Visitor info */
    guest?: Guest;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
interface Captcha {
    /** Token from captcha */
    token?: string;
}
interface Guest {
    /** Email for checkout */
    email?: string;
}
interface CreateGuestOnlineOrderResponse {
    /** Order. */
    order?: Order;
}
interface CreateOfflineOrderRequest {
    /** ID of the plan being ordered. */
    planId: string;
    /** ID of the member ordering the plan. */
    memberId: string;
    /**
     * Start date and time for the ordered plan.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /**
     * Whether the order is paid.
     *
     * Default: `false`
     */
    paid?: boolean | null;
    /**
     * Coupon code to apply.
     *
     * See [Coupons to learn more](https://dev.wix.com/api/rest/coupons).
     */
    couponCode?: string | null;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
interface CreateOfflineOrderResponse {
    /** Order. */
    order?: Order;
}
interface CreateExternalOrderRequest {
    /** Plan ID. */
    planId?: string;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
interface CreateExternalOrderResponse {
    /** Created order */
    order?: Order;
}
interface GetOnlineOrderPreviewRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
}
interface GetOnlineOrderPreviewResponse {
    /** Will be missing if limit is exceeded */
    order?: Order;
    /**
     * Whether the purchase limit has already been reached for this plan by this member.
     * Always false for plans without purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
interface GetGuestOnlineOrderPreviewRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Email for checkout */
    email?: string;
}
interface GetGuestOnlineOrderPreviewResponse {
    /** Will be missing if limit is exceeded */
    order?: Order;
    /**
     * Whether the purchase limit has already been reached for this plan by this email.
     * Always false for plans without purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
interface GetOfflineOrderPreviewRequest {
    /** ID of the plan of the previewed order. See [Plans for more information about plan IDs](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans). */
    planId: string;
    /** Member ID of the buyer the previewed order is for. */
    memberId: string;
    /**
     * Start date and time for plan of the previewed order.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /** Coupon code to apply. See [Coupons to learn more](https://dev.wix.com/api/rest/coupons). */
    couponCode?: string | null;
}
interface GetOfflineOrderPreviewResponse {
    /** The previewed order, as if the plan had been ordered. */
    order?: Order;
    /**
     * Whether this previewed order would exceed the permitted amount of purchases available
     * for this plan for this buyer.
     *
     * Always `false` for plans that do not have purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
interface GetPricePreviewRequest {
    /** ID of plan to preview. */
    planId: string;
    /**
     * Coupon code to apply.
     *
     * See Coupons [to learn more](https://dev.wix.com/api/rest/coupons).
     */
    couponCode?: string | null;
}
interface GetPricePreviewResponse {
    /**
     * @internal
     * @internal
     * @deprecated __Deprecated.__ Use `prices` instead. This property will be removed on September 30, 2022.
     * @replacedBy prices
     * @targetRemovalDate 2022-10-01
     */
    price?: PriceDetails;
    /** Pricing details. */
    prices?: SpannedPrice[];
}
interface ChangeStartDateRequest {
    /** Draft order ID. */
    orderId?: string;
    /** New valid from date (timestamp). */
    startDate?: Date;
}
interface ChangeStartDateResponse {
    /** Updated draft order. */
    order?: Order;
}
interface OrderStartDateChanged {
    /** Order whose `startDate` changed. */
    order?: Order;
}
interface ApplyCouponRequest {
    /** Draft order ID. */
    orderId?: string;
    /** Coupon code to apply. */
    couponCode?: string;
}
interface ApplyCouponResponse {
    /** Order with applied coupon and recalculated tax. */
    order?: Order;
}
interface SetSubmissionRequest {
    /** Order ID. */
    orderId?: string;
    /** Submission ID. */
    submissionId?: string;
}
interface SetSubmissionResponse {
    /** Order with submission id */
    order?: Order;
}
interface OrderPurchased {
    /** Order that was paid for. If a free or an offline order, the order that was created. */
    order?: Order;
}
interface OrderStarted {
    /** Order that reached its `startDate`. */
    order?: Order;
}
/**
 * Triggered at the start of a new payment cycle for an existing order.
 *
 * This webhook does not trigger at the initial start of an offline order.
 */
interface OrderCycleStarted {
    /** Order whose new cycle started. */
    order?: Order;
    /** Number of the payment cycle will be 0 when the order is in the free trial period. In other cases, the cycle number starts from 1. */
    cycleNumber?: number;
}
/** Emitted when a recurring order is canceled for the next payment cycle */
interface OrderAutoRenewCanceled {
    /** Order that is canceled, effective at the end of the current payment cycle. */
    order?: Order;
}
interface OrderEnded {
    /** Order that ended. */
    order?: Order;
}
interface GetOrderRequest {
    /** Order ID. */
    _id: string;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface GetOrderResponse {
    /** Order. */
    order?: Order;
}
interface ListOrdersRequest {
    /** Filter by a buyer's member ID. See [Members to learn more about a site's members](https://dev.wix.com/api/rest/members/members). */
    buyerIds?: string[];
    /** Filter by plan IDs. See [Plans to learn more about pricing plans](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans). */
    planIds?: string[];
    /** Filter by whether or not the auto-renewal of recurring orders was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatus[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatus[];
    /**
     * Number of orders to return. See [Pagination](https://dev.wix.com/api/rest/getting-started/sorting-and-paging#getting-started_sorting-and-paging_paging) for more information.
     *
     * Max: `50`
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `DESC`
     */
    sorting?: Sorting$1;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface ListOrdersResponse {
    /** List of orders. */
    orders?: Order[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2$1;
}
interface OrdersQueryOrdersRequest {
    /** [See available fields here](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort). */
    query?: QueryV2$1;
}
interface OrdersQueryOrdersResponse {
    /** Retrieved orders. */
    plans?: Order[];
    /** Paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2$1;
}
interface GetOrdersStatsRequest {
}
interface GetOrdersStatsResponse {
    /** Total number of orders. */
    totalOrderCount?: number;
    /** Number of active orders. */
    activeOrderCount?: number;
}
interface GetAvailableOrderActionsRequest {
    /** Order ID. */
    _id?: string;
}
interface GetAvailableOrderActionsResponse {
    /** Whether the order can be suspended. */
    suspendable?: boolean;
    /** If the order cannot be suspended, a reason is returned here. */
    notSuspendableReason?: ReasonNotSuspendable;
    /** Whether the order can be canceled by the buyer. */
    cancelableByBuyer?: boolean;
}
declare enum ReasonNotSuspendable {
    /** Reason unknown */
    UNDEFINED = "UNDEFINED",
    /** Saved in the database but is awaiting payment. Non-active orders cannot be suspended */
    PENDING = "PENDING",
    /** Trial orders cannot be suspended */
    TRIAL = "TRIAL",
    /** Canceled orders cannot be suspended */
    CANCELED = "CANCELED",
    /** Ended orders cannot be suspended */
    ENDED = "ENDED",
    /** Paid for orders with future start dates cannot be suspended */
    NOT_STARTED = "NOT_STARTED",
    /** Order is already suspended */
    ALREADY_SUSPENDED = "ALREADY_SUSPENDED",
    /** Orders based on recurring payments using older Stripe versions cannot be suspended */
    OLD_STRIPE = "OLD_STRIPE"
}
interface PostponeEndDateRequest {
    /** Order ID. */
    _id: string;
    /**
     * New end date and time.
     *
     * Must be later than the current end date and time.
     */
    endDate: Date;
}
interface PostponeEndDateResponse {
}
interface OrderEndDatePostponed {
    /** Order whose `endDate` was postponed. */
    order?: Order;
}
interface CancelOrderRequest {
    /** Order ID. */
    _id: string;
    /**
     * When the order is canceled.
     *
     * One time orders can only be canceled immediately. Supported values:
     * - `"IMMEDIATELY"`: The order is canceled immediately.
     * - `"NEXT_PAYMENT_DATE"`: The order is canceled at the next payment date.
     */
    effectiveAt: CancellationEffectiveAt;
}
interface CancelOrderResponse {
}
interface MarkAsPaidRequest {
    /** Order ID. */
    _id: string;
}
interface MarkAsPaidResponse {
}
interface OrderMarkedAsPaid {
    /** Order that was marked as paid. */
    order?: Order;
}
interface PauseOrderRequest {
    /** Order ID. */
    _id: string;
}
interface PauseOrderResponse {
}
interface OrderPaused {
    /** Paused order. */
    order?: Order;
}
interface BulkPauseOrderRequest {
    /** List of Order IDs. */
    ids?: string[];
    /** Set to true to return Order entity in response. */
    returnFullEntity?: boolean;
}
interface BulkPauseOrderResponse {
    /** Orders that were paused. */
    results?: BulkOrderResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$1;
}
interface BulkOrderResult {
    /** Item metadata */
    itemMetadata?: ItemMetadata$1;
    /** The order. */
    order?: Order;
}
interface ItemMetadata$1 {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$1;
}
interface ApplicationError$1 {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata$1 {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface ResumeOrderRequest {
    /** Order ID. */
    _id: string;
}
interface ResumeOrderResponse {
}
interface OrderResumed {
    /** Resumed order. */
    order?: Order;
}
interface BulkResumeOrderRequest {
    /** List of Order IDs. */
    ids?: string[];
    /** Set to true to return Order entity in response. */
    returnFullEntity?: boolean;
}
interface BulkResumeOrderResponse {
    /** Orders that were resumed. */
    results?: BulkOrderResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$1;
}
interface BuyerNonNullableFields {
    memberId: string;
    contactId: string;
}
interface DurationNonNullableFields$1 {
    unit: PeriodUnit$1;
}
interface RecurrenceNonNullableFields$1 {
    cycleDuration?: DurationNonNullableFields$1;
}
interface TaxNonNullableFields {
    name: string;
    includedInPrice: boolean;
    rate: string;
    amount: string;
}
interface CouponNonNullableFields {
    code: string;
    amount: string;
    _id: string;
}
interface PriceDetailsNonNullableFields {
    subscription?: RecurrenceNonNullableFields$1;
    singlePaymentForDuration?: DurationNonNullableFields$1;
    subtotal: string;
    discount: string;
    tax?: TaxNonNullableFields;
    total: string;
    planPrice: string;
    currency: string;
    coupon?: CouponNonNullableFields;
}
interface PriceDurationNonNullableFields {
    cycleFrom: number;
}
interface FeeNonNullableFields$1 {
    name: string;
    amount: string;
}
interface PriceNonNullableFields {
    subtotal: string;
    coupon?: CouponNonNullableFields;
    discount: string;
    tax?: TaxNonNullableFields;
    total: string;
    currency: string;
    fees: FeeNonNullableFields$1[];
    proration: string;
}
interface SpannedPriceNonNullableFields {
    duration?: PriceDurationNonNullableFields;
    price?: PriceNonNullableFields;
}
interface PricingDetailsNonNullableFields {
    subscription?: RecurrenceNonNullableFields$1;
    singlePaymentForDuration?: DurationNonNullableFields$1;
    prices: SpannedPriceNonNullableFields[];
}
interface CancellationNonNullableFields {
    cause: CancellationCause;
    effectiveAt: CancellationEffectiveAt;
}
interface PausePeriodNonNullableFields {
    status: Status;
}
interface CurrentCycleNonNullableFields {
    index: number;
}
interface OrderCycleNonNullableFields {
    index: number;
}
interface OrderNonNullableFields {
    _id: string;
    planId: string;
    subscriptionId: string;
    buyer?: BuyerNonNullableFields;
    priceDetails?: PriceDetailsNonNullableFields;
    pricing?: PricingDetailsNonNullableFields;
    type: OrderType;
    orderMethod: OrderMethod;
    status: OrderStatus;
    cancellation?: CancellationNonNullableFields;
    lastPaymentStatus: PaymentStatus;
    pausePeriods: PausePeriodNonNullableFields[];
    currentCycle?: CurrentCycleNonNullableFields;
    cycles: OrderCycleNonNullableFields[];
    planName: string;
    planDescription: string;
    planPrice: string;
    statusNew: OrderStatus;
}
interface MemberGetOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
interface MemberListOrdersResponseNonNullableFields {
    orders: OrderNonNullableFields[];
}
interface CreateOfflineOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
interface GetOfflineOrderPreviewResponseNonNullableFields {
    order?: OrderNonNullableFields;
    purchaseLimitExceeded: boolean;
}
interface GetPricePreviewResponseNonNullableFields {
    price?: PriceDetailsNonNullableFields;
    prices: SpannedPriceNonNullableFields[];
}
interface GetOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
interface ListOrdersResponseNonNullableFields {
    orders: OrderNonNullableFields[];
}
interface BaseEventMetadata$1 {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData$1;
}
interface EventMetadata$1 extends BaseEventMetadata$1 {
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
interface OrderCanceledEnvelope {
    data: OrderCanceled;
    metadata: EventMetadata$1;
}
interface OrderCreatedEnvelope {
    entity: Order;
    metadata: EventMetadata$1;
}
interface OrderUpdatedEnvelope {
    entity: Order;
    metadata: EventMetadata$1;
}
interface OrderStartDateChangedEnvelope {
    data: OrderStartDateChanged;
    metadata: EventMetadata$1;
}
interface OrderPurchasedEnvelope {
    data: OrderPurchased;
    metadata: EventMetadata$1;
}
interface OrderStartedEnvelope {
    data: OrderStarted;
    metadata: EventMetadata$1;
}
interface OrderCycleStartedEnvelope {
    data: OrderCycleStarted;
    metadata: EventMetadata$1;
}
interface OrderAutoRenewCanceledEnvelope {
    data: OrderAutoRenewCanceled;
    metadata: EventMetadata$1;
}
interface OrderEndedEnvelope {
    data: OrderEnded;
    metadata: EventMetadata$1;
}
interface OrderEndDatePostponedEnvelope {
    data: OrderEndDatePostponed;
    metadata: EventMetadata$1;
}
interface OrderMarkedAsPaidEnvelope {
    data: OrderMarkedAsPaid;
    metadata: EventMetadata$1;
}
interface OrderPausedEnvelope {
    data: OrderPaused;
    metadata: EventMetadata$1;
}
interface OrderResumedEnvelope {
    data: OrderResumed;
    metadata: EventMetadata$1;
}
interface MemberGetOrderOptions {
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface MemberListOrdersOptions {
    /** Filter by plan IDs. */
    planIds?: string[];
    /** Filter for orders where auto renewal was canceled. */
    autoRenewCanceled?: boolean | null;
    /**
     * Filter by the order status. Supported values:
     * + `DRAFT`: Order has been initiated but payment hasn't been processed yet. The plan isn't yet available for use to the buyer.
     * + `PENDING`: Order has been purchased and its start date is set in the future.
     * + `ACTIVE`: Order has been processed. The plan is available for use.
     * + `PAUSED`: Order, and use of the plan, is [paused](#pauseorder). The order, and use of the plan, can be [resumed](#resumeorder).
     * + `ENDED`: Order has completed its duration and is no longer available for use.
     * + `CANCELED`: Order has been [canceled](#cancelorder).
     */
    orderStatuses?: OrderStatus[];
    /**
     * Key Path to edit
     * ManagementListOrdersOptions.paymentStatuses
     * Production value
     * Filter by payment status.
     * Override
     * Filter by payment status.
     *
     * Supported values:
     * + `PAID`: The last payment was paid.
     * + `REFUNDED`: The last payment was refunded.
     * + `FAILED`: The last payment transaction didn't complete.
     * + `UNPAID`: The last payment wasn't paid.
     * + `PENDING`: Awaiting payment.
     * + `NOT_APPLICABLE`: No payment was necessary. For example, for free plans or free trials.
     * Mark down view
     * Filter by payment status.
     *
     * Supported values:
     *
     * PAID: The last payment was paid.
     * REFUNDED: The last payment was refunded.
     * FAILED: The last payment transaction didn't complete.
     * UNPAID: The last payment wasn't paid.
     * PENDING: Awaiting payment.
     * NOT_APPLICABLE: No payment was necessary. For example, for free plans or free trials.
     */
    paymentStatuses?: PaymentStatus[];
    /**
     * Number of pricing plan orders to return.
     *
     * Default: `50`
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `ASC`
     */
    sorting?: Sorting$1;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface CreateOfflineOrderOptions {
    /**
     * Start date and time for the ordered plan.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /**
     * Whether the order is paid.
     *
     * Default: `false`
     */
    paid?: boolean | null;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Form submission ID that was submitted together with the order. */
    submissionId?: string | null;
}
interface GetOfflineOrderPreviewOptions {
    /**
     * Start date and time for plan of the previewed order.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
}
interface GetPricePreviewOptions {
    /** Coupon code to apply.  */
    couponCode?: string | null;
}
interface ManagementGetOrderOptions {
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface ManagementListOrdersOptions {
    /** Filter by specific member IDs of buyers who ordered a pricing plan. */
    buyerIds?: string[];
    /** Filter by specific IDs of plans that were ordered.  */
    planIds?: string[];
    /** Filter by whether or not the auto-renewal of recurring orders was canceled. */
    autoRenewCanceled?: boolean | null;
    /**
     * Filter by the order status. Supported values:
     * + `DRAFT`: Order has been initiated but payment hasn't been processed yet. The plan isn't yet available for use to the buyer.
     * + `PENDING`: Order has been purchased and its start date is set in the future.
     * + `ACTIVE`: Order has been processed. The plan is available for use.
     * + `PAUSED`: Order, and use of the plan, is [paused](#pauseorder). The order, and use of the plan, can be [resumed](#resumeorder).
     * + `ENDED`: Order has completed its duration and is no longer available for use.
     * + `CANCELED`: Order has been [canceled](#cancelorder).
     */
    orderStatuses?: OrderStatus[];
    /**
     * Filter by payment status.
     *
     * Supported values:
     * + `PAID`: The last payment was paid.
     * + `REFUNDED`: The last payment was refunded.
     * + `FAILED`: The last payment transaction didn't complete.
     * + `UNPAID`: The last payment wasn't paid.
     * + `PENDING`: Awaiting payment.
     * + `NOT_APPLICABLE`: No payment was necessary. For example, for free plans or free trials.
     */
    paymentStatuses?: PaymentStatus[];
    /**
     * Number of pricing plan orders to return.
     *
     * Default: `50`
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `DESC`
     */
    sorting?: Sorting$1;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}

declare function memberGetOrder$1(httpClient: HttpClient$1): MemberGetOrderSignature;
interface MemberGetOrderSignature {
    /**
     * Gets an order by ID for the currently logged-in member.
     *
     * The `memberGetOrder()` function returns a Promise that resolves to information about a specified order for the currently logged-in member.
     * @param - Order ID.
     * @param - Options for getting a logged-in member's order.
     * @returns Requested order.
     */
    (_id: string, options?: MemberGetOrderOptions | undefined): Promise<Order & OrderNonNullableFields>;
}
declare function memberListOrders$1(httpClient: HttpClient$1): MemberListOrdersSignature;
interface MemberListOrdersSignature {
    /**
     * Lists orders for the currently logged-in member.
     *
     * The `memberListOrders()` function returns a Promise that resolves to a list of up to 100 pricing plan orders.
     * @param - Filtering, sorting, and pagination options.
     */
    (options?: MemberListOrdersOptions | undefined): Promise<MemberListOrdersResponse & MemberListOrdersResponseNonNullableFields>;
}
declare function requestCancellation$1(httpClient: HttpClient$1): RequestCancellationSignature;
interface RequestCancellationSignature {
    /**
     * Starts the process of canceling an order.
     *
     *
     * The `requestCancellation()` function returns a Promise that resolves when the order cancellation is successfully requested.
     *
     * For orders with recurring payments, a cancellation can be set to occur either immediately or at the next payment date. For orders with one-time payments, a cancellation occurs immediately after the request is processed.
     *
     * Requesting an order cancellation starts the cancellation process. There may be some operations that continue to be processed before the status of the order is changed to `"CANCELED"`. For example, payments might need to be refunded before the order is fully canceled.
     *
     * #### Canceling during the free trial period.
     *
     * When a buyer cancels their order during the free trial period, the buyer's subscription expires at the end of the free trial period and they won't be billed. The buyer may continue using the benefits until the end of the free trial period.
     *
     * @param - Order ID.
     * @param - Whether to cancel the order immediately or at the next payment date.
     * One-time payment orders can only be canceled immediately.
     *
     * Supported values:
     * - `"IMMEDIATELY"`: Indicates that the order should be canceled immediately.
     * - `"NEXT_PAYMENT_DATE"`: Indicates that the order be canceled at the next payment date.
     * @param - Options for requesting a cancellation.
     * @returns Fulfilled - When the cancellation process is started.
     */
    (_id: string, effectiveAt: CancellationEffectiveAt): Promise<void>;
}
declare function createOfflineOrder$1(httpClient: HttpClient$1): CreateOfflineOrderSignature;
interface CreateOfflineOrderSignature {
    /**
     * Creates an order for a buyer who purchased the plan with an offline transaction.
     *
     * The `createOfflineOrder()` function returns a Promise that resolves to an `order` object when the order has been created.
     *
     * Payment of an offline order is handled in 1 of 2 ways.
     * - When creating the order, select `true` in the `paid` request parameter.
     * - After creation, with the [`markAsPaid()`](#markaspaid) function.
     *
     * When creating a non-free offline order:
     * - The order's status is set to `"PENDING"` if the start date is in the future. Otherwise, the status is set to `"ACTIVE"`.
     * The order's last payment status is set to `"UNPAID"` or `"PAID"`.
     *
     * When creating a free offline order:
     * - The order's status is set to `"PENDING"` if the start date is in the future. Otherwise, the status is set to `"ACTIVE"`.
     * - The order's last payment status is set to `"NOT_APPLICABLE"`.
     * @param - ID of the member ordering the plan.
     * @param - Options for creating an offline order.
     * @param - ID of the plan being ordered. See [Plans for more information about plan IDs](plans)
     * @returns Fulfilled - The order of the plan.
     */
    (planId: string, memberId: string, options?: CreateOfflineOrderOptions | undefined): Promise<CreateOfflineOrderResponse & CreateOfflineOrderResponseNonNullableFields>;
}
declare function getOfflineOrderPreview$1(httpClient: HttpClient$1): GetOfflineOrderPreviewSignature;
interface GetOfflineOrderPreviewSignature {
    /**
     * Provides a preview of an offline order as if it was purchased.
     *
     * The `getOfflineOrderPreview()` function returns a Promise that resolves to a temporary preview of the offline order.
     *
     * The preview uses the same logic as purchasing a plan, but the preview is not saved. Because an order is not actually created, the preview's `_id` and `subscriptionId` properties are displayed as a string of multiple zero characters (`000000-0000`).
     *
     * If [taxes are configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection) for the site, taxes are applied to the preview. If not, `tax` previews as `null`.
     *
     * You can preview the order to check purchase limitations, but the limitations are not enforced for the preview. If a pricing plan has a limit on the amount of purchases per buyer, that limit is not considered for generating the preview. But, if that limit has been reached and this order would then exceed the amount of purchases permitted for this buyer, then `purchaseLimitExceeded` will return as `true`. Thus function is not available to the buyer. You specify the member ID for the buyer whose order should be previewed. To get a general price preview for a plan that's not buyer-specific, use the [`getPricePreview()`](#getpricepreview) function.
     * @param - Member ID of the buyer the previewed order is for.
     * @param - Options for previewing the offline order.
     * @param - ID of the plan of the previewed order.
     * @returns Fulfilled - A preview of the order.
     */
    (planId: string, memberId: string, options?: GetOfflineOrderPreviewOptions | undefined): Promise<GetOfflineOrderPreviewResponse & GetOfflineOrderPreviewResponseNonNullableFields>;
}
declare function getPricePreview$1(httpClient: HttpClient$1): GetPricePreviewSignature;
interface GetPricePreviewSignature {
    /**
     * Retrieves a preview of an order's pricing as if it was purchased.
     *
     * The `getPricePreview()` function returns a Promise that resolves to a temporary preview of the order's price.
     *
     * The price preview uses the same logic for calculating prices as used when purchasing a plan, but the preview is not saved. If [taxes are configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection) for the site, taxes are applied to the preview. If not, the `tax` previews as `null`.
     *
     * Buyers do not have to be logged in to preview the price, as such, the details returned by this function are not buyer-specific. To generate a preview of a purchase for a specific-buyer, use the [`getOfflineOrderPreview()`](#getofflineorderpreview).
     * @param - ID of plan to preview.
     * @param - Options for getting a price preview.
     * @returns Fulfilled - A preview of the pricing for the order.
     */
    (planId: string, options?: GetPricePreviewOptions | undefined): Promise<GetPricePreviewResponse & GetPricePreviewResponseNonNullableFields>;
}
declare function managementGetOrder$1(httpClient: HttpClient$1): ManagementGetOrderSignature;
interface ManagementGetOrderSignature {
    /**
     * Retrieves an order by ID.
     *
     * The `managementGetOrder()` function returns a Promise that resolves to information about the specified order.
     * @param - Order ID.
     * @param - Options to use when getting an order.
     */
    (_id: string, options?: ManagementGetOrderOptions | undefined): Promise<GetOrderResponse & GetOrderResponseNonNullableFields>;
}
declare function managementListOrders$1(httpClient: HttpClient$1): ManagementListOrdersSignature;
interface ManagementListOrdersSignature {
    /**
     * Lists pricing plan orders.
     *
     * The `managementListOrders()` function returns a Promise that resolves to a list of up to 50 pricing plan orders. You can specify options for filtering, sorting, and paginating the results.
     *
     * This function returns the orders on the site. To list orders for the currently logged-in member, use [`memberListOrders()`](#memberlistorders).
     * @param - Filtering, sorting, and pagination options.
     */
    (options?: ManagementListOrdersOptions | undefined): Promise<ListOrdersResponse & ListOrdersResponseNonNullableFields>;
}
declare function postponeEndDate$1(httpClient: HttpClient$1): PostponeEndDateSignature;
interface PostponeEndDateSignature {
    /**
     * Extends the duration of a pricing plan order by postponing the order's `endDate`.
     *
     * The `postponeEndDate()` function returns a Promise that resolves when the order's end date is successfully changed.
     *
     * The new end date and time must be later than the order's current `endDate`.
     *
     * Postponing the end date of an order does not impact payments. For example, if the pricing plan is for a membership to an online lecture series, and you want to extend the duration of the series because the lecturer could not attend some sessions, you can postpone the end date of the orders for all relevant participants. The participants will not be billed additionally.
     *
     * Postponing an order causes the following changes:
     * - The `endDate` for the order is adjusted to the new end date.
     * @param - Order ID.
     * @param - New end date and time.
     *
     * Must be later than the current end date and time.
     * @param - Options for postponing the end date of an order.
     * @returns Fulfilled - When the order's end date has been postponed or made earlier.
     */
    (_id: string, endDate: Date): Promise<void>;
}
declare function cancelOrder$1(httpClient: HttpClient$1): CancelOrderSignature;
interface CancelOrderSignature {
    /**
     * Cancels an existing order.
     *
     * The `cancelOrder()` function returns a Promise that resolves when the order is successfully canceled.
     *
     * For orders with recurring payments, a cancellation can be set to occur either `IMMEDIATELY` or at the `NEXT_PAYMENT_DATE`.
     * For orders with one-time payments, a cancellation occurs `IMMEDIATELY`.
     *
     * Canceling an order changes the order status to `CANCELED`.
     *
     * #### Canceling during the free trial period.
     *
     * When a site owner cancels an ordered plan during the free trial period, they choose to apply the cancellation `IMMEDIATELY` or at the `NEXT_PAYMENT_DATE`.
     *
     * Canceling `IMMEDIATELY` will end the subscription for the buyer
     * immediately, even during the free trial period and the buyer won't be billed.
     *
     * Canceling at the `NEXT_PAYMENT_DATE` allows the buyer to continue using the benefits of the subscription until the end of the free trial period. Then, the subscription ends and the buyer is not billed.
     * @param - Order ID.
     * @param - When the order is canceled.
     *
     * One time orders can only be canceled immediately. Supported values:
     * - `"IMMEDIATELY"`: The order is canceled immediately.
     * - `"NEXT_PAYMENT_DATE"`: The order is canceled at the next payment date.
     * @param - Options for canceling orders.
     * @returns Fulfilled - When the order is canceled.
     */
    (_id: string, effectiveAt: CancellationEffectiveAt): Promise<void>;
}
declare function markAsPaid$1(httpClient: HttpClient$1): MarkAsPaidSignature;
interface MarkAsPaidSignature {
    /**
     * Marks an offline order as paid.
     *
     * The `markAsPaid()` function returns a Promise that resolves when the offline order is successfully marked as paid.
     *
     * The entire order is marked as paid, even if the order's payments are recurring.
     *
     * >**Note:** Marking separate payment cycles as paid is not yet supported. Subsequent offline payments do trigger events and emails, but are not registered as additional offline payments.
     *
     * Marking an offline order as paid causes the following changes:
     * - The order's `lastPaymentStatus` changes to `"PAID"`.
     * - The order's status changes to either `"PENDING"` or `"ACTIVE"`, depending on the order's `startDate`.
     *
     * An error occurs if you attempt to:
     * - Mark an already-paid, offline order as paid. You cannot make an offline order as paid twice.
     * - Mark an online order as paid. The `markAsPaid()` function is supported for offline orders only.
     * @param - Order ID.
     * @returns Fulfilled - When the order is marked as paid.
     */
    (_id: string): Promise<void>;
}
declare function pauseOrder$1(httpClient: HttpClient$1): PauseOrderSignature;
interface PauseOrderSignature {
    /**
     * Pauses a pricing plan order.
     *
     * The `pauseOrder()` function returns a Promise that resolves when the order is successfully paused.
     *
     * For orders with recurring payments, `pauseOrder()` also pauses the payment schedule. Buyers are not charged when an order is paused. Use `pauseOrder()`, for example, if the buyer is away and would like to put their pricing plan membership on hold until they return. Pausing an order affects the end date of the order by adding the time the order is paused to the `endDate`. You can only pause orders with an `"ACTIVE`" status.
     *
     * Pausing an order causes the following changes:
     * - The order status changes to `"PAUSED"`.
     * - The `pausePeriods` array is updated.
     *
     * The `endDate` and the `earliestEndDate` for the order are adjusted to include the pause period when the order is resumed.
     *
     * Paused orders can be continued with the [`resumeOrder()`](#resumeorder) function.
     * @param - Order ID.
     * @returns Fulfilled - When the order is paused.
     */
    (_id: string): Promise<void>;
}
declare function resumeOrder$1(httpClient: HttpClient$1): ResumeOrderSignature;
interface ResumeOrderSignature {
    /**
     * Resumes a paused pricing plan order.
     *
     * The `resumeOrder()` function returns a Promise that resolves when a paused order is successfully resumed.
     *
     * For orders with recurring payments, `resumeOrder()` also restarts the payment schedule.
     *
     * Resuming an order causes the following changes:
     * - The order status changes to `"ACTIVE"`.
     * - The `pausePeriods` array is updated.
     * - The `endDate` for the order is adjusted to include the pause period.
     * - The `earliestEndDate` is adjusted to include the pause period. (This property is reserved for future use).
     * @param - Order ID.
     * @returns Fulfilled - When the order is resumed.
     */
    (_id: string): Promise<void>;
}
declare const onOrderCanceled$1: EventDefinition$3<OrderCanceledEnvelope, "wix.pricing_plans.v2.order_canceled">;
declare const onOrderCreated$1: EventDefinition$3<OrderCreatedEnvelope, "wix.pricing_plans.v2.order_created">;
declare const onOrderUpdated$1: EventDefinition$3<OrderUpdatedEnvelope, "wix.pricing_plans.v2.order_updated">;
declare const onOrderStartDateChanged$1: EventDefinition$3<OrderStartDateChangedEnvelope, "wix.pricing_plans.v2.order_start_date_changed">;
declare const onOrderPurchased$1: EventDefinition$3<OrderPurchasedEnvelope, "wix.pricing_plans.v2.order_purchased">;
declare const onOrderStarted$1: EventDefinition$3<OrderStartedEnvelope, "wix.pricing_plans.v2.order_started">;
declare const onOrderCycleStarted$1: EventDefinition$3<OrderCycleStartedEnvelope, "wix.pricing_plans.v2.order_cycle_started">;
declare const onOrderAutoRenewCanceled$1: EventDefinition$3<OrderAutoRenewCanceledEnvelope, "wix.pricing_plans.v2.order_auto_renew_canceled">;
declare const onOrderEnded$1: EventDefinition$3<OrderEndedEnvelope, "wix.pricing_plans.v2.order_ended">;
declare const onOrderEndDatePostponed$1: EventDefinition$3<OrderEndDatePostponedEnvelope, "wix.pricing_plans.v2.order_end_date_postponed">;
declare const onOrderMarkedAsPaid$1: EventDefinition$3<OrderMarkedAsPaidEnvelope, "wix.pricing_plans.v2.order_marked_as_paid">;
declare const onOrderPaused$1: EventDefinition$3<OrderPausedEnvelope, "wix.pricing_plans.v2.order_paused">;
declare const onOrderResumed$1: EventDefinition$3<OrderResumedEnvelope, "wix.pricing_plans.v2.order_resumed">;

type EventDefinition$2<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition$2<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition$2<Payload, Type>;
type EventHandler$2<T extends EventDefinition$2> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition$2<T extends EventDefinition$2<any, string>> = (handler: EventHandler$2<T>) => void;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare function createEventModule$1<T extends EventDefinition$2<any, string>>(eventDefinition: T): BuildEventDefinition$2<T> & T;

declare const memberGetOrder: MaybeContext$1<BuildRESTFunction$1<typeof memberGetOrder$1> & typeof memberGetOrder$1>;
declare const memberListOrders: MaybeContext$1<BuildRESTFunction$1<typeof memberListOrders$1> & typeof memberListOrders$1>;
declare const requestCancellation: MaybeContext$1<BuildRESTFunction$1<typeof requestCancellation$1> & typeof requestCancellation$1>;
declare const createOfflineOrder: MaybeContext$1<BuildRESTFunction$1<typeof createOfflineOrder$1> & typeof createOfflineOrder$1>;
declare const getOfflineOrderPreview: MaybeContext$1<BuildRESTFunction$1<typeof getOfflineOrderPreview$1> & typeof getOfflineOrderPreview$1>;
declare const getPricePreview: MaybeContext$1<BuildRESTFunction$1<typeof getPricePreview$1> & typeof getPricePreview$1>;
declare const managementGetOrder: MaybeContext$1<BuildRESTFunction$1<typeof managementGetOrder$1> & typeof managementGetOrder$1>;
declare const managementListOrders: MaybeContext$1<BuildRESTFunction$1<typeof managementListOrders$1> & typeof managementListOrders$1>;
declare const postponeEndDate: MaybeContext$1<BuildRESTFunction$1<typeof postponeEndDate$1> & typeof postponeEndDate$1>;
declare const cancelOrder: MaybeContext$1<BuildRESTFunction$1<typeof cancelOrder$1> & typeof cancelOrder$1>;
declare const markAsPaid: MaybeContext$1<BuildRESTFunction$1<typeof markAsPaid$1> & typeof markAsPaid$1>;
declare const pauseOrder: MaybeContext$1<BuildRESTFunction$1<typeof pauseOrder$1> & typeof pauseOrder$1>;
declare const resumeOrder: MaybeContext$1<BuildRESTFunction$1<typeof resumeOrder$1> & typeof resumeOrder$1>;

type _publicOnOrderCanceledType = typeof onOrderCanceled$1;
/**
 * Triggered when an order is canceled.
 *
 * This webhook is triggered either immediately or at the end of the current payment cycle, as follows:
 * + If the order is canceled and `effectiveAt` is set to `IMMEDIATELY`, the webhook is triggered immediately when canceled.
 * + If the order is canceled and `effectiveAt` is set to `NEXT_PAYMENT_DATE`, the webhook is triggered at the end of the current payment cycle. In this case, the [Order Auto Renew Canceled Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-auto-renew-canceled-webhook) is triggered immediately.
 */
declare const onOrderCanceled: ReturnType<typeof createEventModule$1<_publicOnOrderCanceledType>>;

type _publicOnOrderCreatedType = typeof onOrderCreated$1;
/**
 * Triggered when an order is created.
 */
declare const onOrderCreated: ReturnType<typeof createEventModule$1<_publicOnOrderCreatedType>>;

type _publicOnOrderUpdatedType = typeof onOrderUpdated$1;
/**
 * Triggered when an order is updated.
 *
 * Order Updated Webhook is triggered when any of the following happens:
 * + Order is paid for. [Order Purchased Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-purchased-webhook) is also triggered.
 * + Order reaches its start date or end date. [Order Started Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-started-webhook) and [Order Ended Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-ended-webhook), respectively, are also triggered.
 * + New payment cycle of an order starts. [Order Cycle Started Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-cycle-started-webhook) is also triggered.
 * + Offline order is marked as paid. [Order Marked As Paid Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-marked-as-paid-webhook) is also triggered.
 * + End date of the order is postponed. [Order End Date Postponed Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-end-date-postponed-webhook) is also triggered
 * + Order is paused, or a paused order is resumed. [Order Paused Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-paused-webhook)
 * and [Order Resumed Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-resumed-webhook), respectively, are also triggered.
 * + Order is canceled, either immediately or at the end of the payment cycle. [Order Canceled Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-canceled-webhook)
 * and [Order Auto Renew Canceled Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-auto-renew-canceled-webhook) are also triggered.
 */
declare const onOrderUpdated: ReturnType<typeof createEventModule$1<_publicOnOrderUpdatedType>>;

type _publicOnOrderStartDateChangedType = typeof onOrderStartDateChanged$1;
/**
 * Triggered when an order's `startDate` is changed.
 */
declare const onOrderStartDateChanged: ReturnType<typeof createEventModule$1<_publicOnOrderStartDateChangedType>>;

type _publicOnOrderPurchasedType = typeof onOrderPurchased$1;
/**
 * Triggered when an order is purchased.
 *
 * This webhook is triggered for any of the following events:
 * + Order is paid in full.
 * + At least 1 order cycle payment is paid for.
 * + Offline order is created, even if not yet marked as paid.
 * + Free order is created.
 */
declare const onOrderPurchased: ReturnType<typeof createEventModule$1<_publicOnOrderPurchasedType>>;

type _publicOnOrderStartedType = typeof onOrderStarted$1;
/**
 * Triggered when an order reaches its `startDate`. Applies to both purchased and free orders.
 */
declare const onOrderStarted: ReturnType<typeof createEventModule$1<_publicOnOrderStartedType>>;

type _publicOnOrderCycleStartedType = typeof onOrderCycleStarted$1;
/**
 * Triggered at the start of a new payment cycle for an existing order.
 *
 * This webhook is not triggered at the initial start of an offline order.
 */
declare const onOrderCycleStarted: ReturnType<typeof createEventModule$1<_publicOnOrderCycleStartedType>>;

type _publicOnOrderAutoRenewCanceledType = typeof onOrderAutoRenewCanceled$1;
/**
 * Triggered when an order is canceled and `effectiveAt` is set to `NEXT_PAYMENT_DATE`.
 *
 * This webhook is *not* triggered in the following scenarios:
 * + When an order is canceled and `effectiveAt` is set to `IMMEDIATELY`. Instead, at the time of cancellation, [Order Canceled](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-canceled-webhook) is triggered.
 * + When an order expires at the end of the current payment cycle because it was canceled and `effectiveAt` was set to `NEXT_PAYMENT_DATE`. Instead, at the time of expiration, [Order Canceled](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-canceled-webhook) and [Order Ended](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-ended-webhook) are triggered.
 */
declare const onOrderAutoRenewCanceled: ReturnType<typeof createEventModule$1<_publicOnOrderAutoRenewCanceledType>>;

type _publicOnOrderEndedType = typeof onOrderEnded$1;
/**
 * Triggered when an order ends.
 *
 * This webhook is triggered:
 * + When an order expires at the end of the current payment cycle.
 * + When an order is canceled and `effectiveAt` is set to `IMMEDIATELY`..
 */
declare const onOrderEnded: ReturnType<typeof createEventModule$1<_publicOnOrderEndedType>>;

type _publicOnOrderEndDatePostponedType = typeof onOrderEndDatePostponed$1;
/**
 * Triggered when an order's `endDate` is postponed.
 */
declare const onOrderEndDatePostponed: ReturnType<typeof createEventModule$1<_publicOnOrderEndDatePostponedType>>;

type _publicOnOrderMarkedAsPaidType = typeof onOrderMarkedAsPaid$1;
/**
 * Triggered when an offline order is marked as paid.
 */
declare const onOrderMarkedAsPaid: ReturnType<typeof createEventModule$1<_publicOnOrderMarkedAsPaidType>>;

type _publicOnOrderPausedType = typeof onOrderPaused$1;
/**
 * Triggered when an order is paused.
 */
declare const onOrderPaused: ReturnType<typeof createEventModule$1<_publicOnOrderPausedType>>;

type _publicOnOrderResumedType = typeof onOrderResumed$1;
/**
 * Triggered when a paused order is resumed.
 */
declare const onOrderResumed: ReturnType<typeof createEventModule$1<_publicOnOrderResumedType>>;

type context$1_ApplyCouponRequest = ApplyCouponRequest;
type context$1_ApplyCouponResponse = ApplyCouponResponse;
type context$1_BulkOrderResult = BulkOrderResult;
type context$1_BulkPauseOrderRequest = BulkPauseOrderRequest;
type context$1_BulkPauseOrderResponse = BulkPauseOrderResponse;
type context$1_BulkResumeOrderRequest = BulkResumeOrderRequest;
type context$1_BulkResumeOrderResponse = BulkResumeOrderResponse;
type context$1_Buyer = Buyer;
type context$1_CancelOrderRequest = CancelOrderRequest;
type context$1_CancelOrderResponse = CancelOrderResponse;
type context$1_Cancellation = Cancellation;
type context$1_CancellationCause = CancellationCause;
declare const context$1_CancellationCause: typeof CancellationCause;
type context$1_CancellationEffectiveAt = CancellationEffectiveAt;
declare const context$1_CancellationEffectiveAt: typeof CancellationEffectiveAt;
type context$1_Captcha = Captcha;
type context$1_ChangeStartDateRequest = ChangeStartDateRequest;
type context$1_ChangeStartDateResponse = ChangeStartDateResponse;
type context$1_Coupon = Coupon;
type context$1_CouponsError = CouponsError;
type context$1_CreateExternalOrderRequest = CreateExternalOrderRequest;
type context$1_CreateExternalOrderResponse = CreateExternalOrderResponse;
type context$1_CreateGuestOnlineOrderRequest = CreateGuestOnlineOrderRequest;
type context$1_CreateGuestOnlineOrderResponse = CreateGuestOnlineOrderResponse;
type context$1_CreateOfflineOrderOptions = CreateOfflineOrderOptions;
type context$1_CreateOfflineOrderRequest = CreateOfflineOrderRequest;
type context$1_CreateOfflineOrderResponse = CreateOfflineOrderResponse;
type context$1_CreateOfflineOrderResponseNonNullableFields = CreateOfflineOrderResponseNonNullableFields;
type context$1_CreateOnlineOrderRequest = CreateOnlineOrderRequest;
type context$1_CreateOnlineOrderResponse = CreateOnlineOrderResponse;
type context$1_CurrentCycle = CurrentCycle;
type context$1_CursorPaging = CursorPaging;
type context$1_Empty = Empty;
type context$1_FormData = FormData;
type context$1_GetAvailableOrderActionsRequest = GetAvailableOrderActionsRequest;
type context$1_GetAvailableOrderActionsResponse = GetAvailableOrderActionsResponse;
type context$1_GetGuestOnlineOrderPreviewRequest = GetGuestOnlineOrderPreviewRequest;
type context$1_GetGuestOnlineOrderPreviewResponse = GetGuestOnlineOrderPreviewResponse;
type context$1_GetOfflineOrderPreviewOptions = GetOfflineOrderPreviewOptions;
type context$1_GetOfflineOrderPreviewRequest = GetOfflineOrderPreviewRequest;
type context$1_GetOfflineOrderPreviewResponse = GetOfflineOrderPreviewResponse;
type context$1_GetOfflineOrderPreviewResponseNonNullableFields = GetOfflineOrderPreviewResponseNonNullableFields;
type context$1_GetOnlineOrderPreviewRequest = GetOnlineOrderPreviewRequest;
type context$1_GetOnlineOrderPreviewResponse = GetOnlineOrderPreviewResponse;
type context$1_GetOrderRequest = GetOrderRequest;
type context$1_GetOrderResponse = GetOrderResponse;
type context$1_GetOrderResponseNonNullableFields = GetOrderResponseNonNullableFields;
type context$1_GetOrdersStatsRequest = GetOrdersStatsRequest;
type context$1_GetOrdersStatsResponse = GetOrdersStatsResponse;
type context$1_GetPricePreviewOptions = GetPricePreviewOptions;
type context$1_GetPricePreviewRequest = GetPricePreviewRequest;
type context$1_GetPricePreviewResponse = GetPricePreviewResponse;
type context$1_GetPricePreviewResponseNonNullableFields = GetPricePreviewResponseNonNullableFields;
type context$1_Guest = Guest;
type context$1_ListOrdersRequest = ListOrdersRequest;
type context$1_ListOrdersResponse = ListOrdersResponse;
type context$1_ListOrdersResponseNonNullableFields = ListOrdersResponseNonNullableFields;
type context$1_ManagementGetOrderOptions = ManagementGetOrderOptions;
type context$1_ManagementListOrdersOptions = ManagementListOrdersOptions;
type context$1_MarkAsPaidRequest = MarkAsPaidRequest;
type context$1_MarkAsPaidResponse = MarkAsPaidResponse;
type context$1_MemberGetOrderOptions = MemberGetOrderOptions;
type context$1_MemberGetOrderRequest = MemberGetOrderRequest;
type context$1_MemberGetOrderResponse = MemberGetOrderResponse;
type context$1_MemberGetOrderResponseNonNullableFields = MemberGetOrderResponseNonNullableFields;
type context$1_MemberListOrdersOptions = MemberListOrdersOptions;
type context$1_MemberListOrdersRequest = MemberListOrdersRequest;
type context$1_MemberListOrdersResponse = MemberListOrdersResponse;
type context$1_MemberListOrdersResponseNonNullableFields = MemberListOrdersResponseNonNullableFields;
type context$1_OnBehalf = OnBehalf;
type context$1_Order = Order;
type context$1_OrderAutoRenewCanceled = OrderAutoRenewCanceled;
type context$1_OrderAutoRenewCanceledEnvelope = OrderAutoRenewCanceledEnvelope;
type context$1_OrderCanceled = OrderCanceled;
type context$1_OrderCanceledEnvelope = OrderCanceledEnvelope;
type context$1_OrderCreatedEnvelope = OrderCreatedEnvelope;
type context$1_OrderCycle = OrderCycle;
type context$1_OrderCycleStarted = OrderCycleStarted;
type context$1_OrderCycleStartedEnvelope = OrderCycleStartedEnvelope;
type context$1_OrderEndDatePostponed = OrderEndDatePostponed;
type context$1_OrderEndDatePostponedEnvelope = OrderEndDatePostponedEnvelope;
type context$1_OrderEnded = OrderEnded;
type context$1_OrderEndedEnvelope = OrderEndedEnvelope;
type context$1_OrderMarkedAsPaid = OrderMarkedAsPaid;
type context$1_OrderMarkedAsPaidEnvelope = OrderMarkedAsPaidEnvelope;
type context$1_OrderMethod = OrderMethod;
declare const context$1_OrderMethod: typeof OrderMethod;
type context$1_OrderNonNullableFields = OrderNonNullableFields;
type context$1_OrderPaused = OrderPaused;
type context$1_OrderPausedEnvelope = OrderPausedEnvelope;
type context$1_OrderPurchased = OrderPurchased;
type context$1_OrderPurchasedEnvelope = OrderPurchasedEnvelope;
type context$1_OrderResumed = OrderResumed;
type context$1_OrderResumedEnvelope = OrderResumedEnvelope;
type context$1_OrderStartDateChanged = OrderStartDateChanged;
type context$1_OrderStartDateChangedEnvelope = OrderStartDateChangedEnvelope;
type context$1_OrderStarted = OrderStarted;
type context$1_OrderStartedEnvelope = OrderStartedEnvelope;
type context$1_OrderStatus = OrderStatus;
declare const context$1_OrderStatus: typeof OrderStatus;
type context$1_OrderType = OrderType;
declare const context$1_OrderType: typeof OrderType;
type context$1_OrderUpdatedEnvelope = OrderUpdatedEnvelope;
type context$1_OrdersQueryOrdersRequest = OrdersQueryOrdersRequest;
type context$1_OrdersQueryOrdersResponse = OrdersQueryOrdersResponse;
type context$1_PauseOrderRequest = PauseOrderRequest;
type context$1_PauseOrderResponse = PauseOrderResponse;
type context$1_PausePeriod = PausePeriod;
type context$1_PaymentStatus = PaymentStatus;
declare const context$1_PaymentStatus: typeof PaymentStatus;
type context$1_PostponeEndDateRequest = PostponeEndDateRequest;
type context$1_PostponeEndDateResponse = PostponeEndDateResponse;
type context$1_Price = Price;
type context$1_PriceDetails = PriceDetails;
type context$1_PriceDetailsPricingModelOneOf = PriceDetailsPricingModelOneOf;
type context$1_PriceDuration = PriceDuration;
type context$1_PricingDetails = PricingDetails;
type context$1_PricingDetailsPricingModelOneOf = PricingDetailsPricingModelOneOf;
type context$1_QueryOrdersRequest = QueryOrdersRequest;
type context$1_QueryOrdersResponse = QueryOrdersResponse;
type context$1_QueryV2PagingMethodOneOf = QueryV2PagingMethodOneOf;
type context$1_ReasonNotSuspendable = ReasonNotSuspendable;
declare const context$1_ReasonNotSuspendable: typeof ReasonNotSuspendable;
type context$1_RequestCancellationRequest = RequestCancellationRequest;
type context$1_RequestCancellationResponse = RequestCancellationResponse;
type context$1_ResumeOrderRequest = ResumeOrderRequest;
type context$1_ResumeOrderResponse = ResumeOrderResponse;
type context$1_Set = Set;
declare const context$1_Set: typeof Set;
type context$1_SetSubmissionRequest = SetSubmissionRequest;
type context$1_SetSubmissionResponse = SetSubmissionResponse;
type context$1_SpannedPrice = SpannedPrice;
type context$1_Status = Status;
declare const context$1_Status: typeof Status;
type context$1_Tax = Tax;
type context$1__publicOnOrderAutoRenewCanceledType = _publicOnOrderAutoRenewCanceledType;
type context$1__publicOnOrderCanceledType = _publicOnOrderCanceledType;
type context$1__publicOnOrderCreatedType = _publicOnOrderCreatedType;
type context$1__publicOnOrderCycleStartedType = _publicOnOrderCycleStartedType;
type context$1__publicOnOrderEndDatePostponedType = _publicOnOrderEndDatePostponedType;
type context$1__publicOnOrderEndedType = _publicOnOrderEndedType;
type context$1__publicOnOrderMarkedAsPaidType = _publicOnOrderMarkedAsPaidType;
type context$1__publicOnOrderPausedType = _publicOnOrderPausedType;
type context$1__publicOnOrderPurchasedType = _publicOnOrderPurchasedType;
type context$1__publicOnOrderResumedType = _publicOnOrderResumedType;
type context$1__publicOnOrderStartDateChangedType = _publicOnOrderStartDateChangedType;
type context$1__publicOnOrderStartedType = _publicOnOrderStartedType;
type context$1__publicOnOrderUpdatedType = _publicOnOrderUpdatedType;
declare const context$1_cancelOrder: typeof cancelOrder;
declare const context$1_createOfflineOrder: typeof createOfflineOrder;
declare const context$1_getOfflineOrderPreview: typeof getOfflineOrderPreview;
declare const context$1_getPricePreview: typeof getPricePreview;
declare const context$1_managementGetOrder: typeof managementGetOrder;
declare const context$1_managementListOrders: typeof managementListOrders;
declare const context$1_markAsPaid: typeof markAsPaid;
declare const context$1_memberGetOrder: typeof memberGetOrder;
declare const context$1_memberListOrders: typeof memberListOrders;
declare const context$1_onOrderAutoRenewCanceled: typeof onOrderAutoRenewCanceled;
declare const context$1_onOrderCanceled: typeof onOrderCanceled;
declare const context$1_onOrderCreated: typeof onOrderCreated;
declare const context$1_onOrderCycleStarted: typeof onOrderCycleStarted;
declare const context$1_onOrderEndDatePostponed: typeof onOrderEndDatePostponed;
declare const context$1_onOrderEnded: typeof onOrderEnded;
declare const context$1_onOrderMarkedAsPaid: typeof onOrderMarkedAsPaid;
declare const context$1_onOrderPaused: typeof onOrderPaused;
declare const context$1_onOrderPurchased: typeof onOrderPurchased;
declare const context$1_onOrderResumed: typeof onOrderResumed;
declare const context$1_onOrderStartDateChanged: typeof onOrderStartDateChanged;
declare const context$1_onOrderStarted: typeof onOrderStarted;
declare const context$1_onOrderUpdated: typeof onOrderUpdated;
declare const context$1_pauseOrder: typeof pauseOrder;
declare const context$1_postponeEndDate: typeof postponeEndDate;
declare const context$1_requestCancellation: typeof requestCancellation;
declare const context$1_resumeOrder: typeof resumeOrder;
declare namespace context$1 {
  export { type ActionEvent$1 as ActionEvent, type ApplicationError$1 as ApplicationError, type context$1_ApplyCouponRequest as ApplyCouponRequest, type context$1_ApplyCouponResponse as ApplyCouponResponse, type BaseEventMetadata$1 as BaseEventMetadata, type BulkActionMetadata$1 as BulkActionMetadata, type context$1_BulkOrderResult as BulkOrderResult, type context$1_BulkPauseOrderRequest as BulkPauseOrderRequest, type context$1_BulkPauseOrderResponse as BulkPauseOrderResponse, type context$1_BulkResumeOrderRequest as BulkResumeOrderRequest, type context$1_BulkResumeOrderResponse as BulkResumeOrderResponse, type context$1_Buyer as Buyer, type context$1_CancelOrderRequest as CancelOrderRequest, type context$1_CancelOrderResponse as CancelOrderResponse, type context$1_Cancellation as Cancellation, context$1_CancellationCause as CancellationCause, context$1_CancellationEffectiveAt as CancellationEffectiveAt, type context$1_Captcha as Captcha, type context$1_ChangeStartDateRequest as ChangeStartDateRequest, type context$1_ChangeStartDateResponse as ChangeStartDateResponse, type context$1_Coupon as Coupon, type context$1_CouponsError as CouponsError, type context$1_CreateExternalOrderRequest as CreateExternalOrderRequest, type context$1_CreateExternalOrderResponse as CreateExternalOrderResponse, type context$1_CreateGuestOnlineOrderRequest as CreateGuestOnlineOrderRequest, type context$1_CreateGuestOnlineOrderResponse as CreateGuestOnlineOrderResponse, type context$1_CreateOfflineOrderOptions as CreateOfflineOrderOptions, type context$1_CreateOfflineOrderRequest as CreateOfflineOrderRequest, type context$1_CreateOfflineOrderResponse as CreateOfflineOrderResponse, type context$1_CreateOfflineOrderResponseNonNullableFields as CreateOfflineOrderResponseNonNullableFields, type context$1_CreateOnlineOrderRequest as CreateOnlineOrderRequest, type context$1_CreateOnlineOrderResponse as CreateOnlineOrderResponse, type context$1_CurrentCycle as CurrentCycle, type context$1_CursorPaging as CursorPaging, type Cursors$1 as Cursors, type DomainEvent$1 as DomainEvent, type DomainEventBodyOneOf$1 as DomainEventBodyOneOf, type Duration$1 as Duration, type context$1_Empty as Empty, type EntityCreatedEvent$1 as EntityCreatedEvent, type EntityDeletedEvent$1 as EntityDeletedEvent, type EntityUpdatedEvent$1 as EntityUpdatedEvent, type EventMetadata$1 as EventMetadata, type Fee$1 as Fee, type context$1_FormData as FormData, type context$1_GetAvailableOrderActionsRequest as GetAvailableOrderActionsRequest, type context$1_GetAvailableOrderActionsResponse as GetAvailableOrderActionsResponse, type context$1_GetGuestOnlineOrderPreviewRequest as GetGuestOnlineOrderPreviewRequest, type context$1_GetGuestOnlineOrderPreviewResponse as GetGuestOnlineOrderPreviewResponse, type context$1_GetOfflineOrderPreviewOptions as GetOfflineOrderPreviewOptions, type context$1_GetOfflineOrderPreviewRequest as GetOfflineOrderPreviewRequest, type context$1_GetOfflineOrderPreviewResponse as GetOfflineOrderPreviewResponse, type context$1_GetOfflineOrderPreviewResponseNonNullableFields as GetOfflineOrderPreviewResponseNonNullableFields, type context$1_GetOnlineOrderPreviewRequest as GetOnlineOrderPreviewRequest, type context$1_GetOnlineOrderPreviewResponse as GetOnlineOrderPreviewResponse, type context$1_GetOrderRequest as GetOrderRequest, type context$1_GetOrderResponse as GetOrderResponse, type context$1_GetOrderResponseNonNullableFields as GetOrderResponseNonNullableFields, type context$1_GetOrdersStatsRequest as GetOrdersStatsRequest, type context$1_GetOrdersStatsResponse as GetOrdersStatsResponse, type context$1_GetPricePreviewOptions as GetPricePreviewOptions, type context$1_GetPricePreviewRequest as GetPricePreviewRequest, type context$1_GetPricePreviewResponse as GetPricePreviewResponse, type context$1_GetPricePreviewResponseNonNullableFields as GetPricePreviewResponseNonNullableFields, type context$1_Guest as Guest, type IdentificationData$1 as IdentificationData, type IdentificationDataIdOneOf$1 as IdentificationDataIdOneOf, type ItemMetadata$1 as ItemMetadata, type context$1_ListOrdersRequest as ListOrdersRequest, type context$1_ListOrdersResponse as ListOrdersResponse, type context$1_ListOrdersResponseNonNullableFields as ListOrdersResponseNonNullableFields, type context$1_ManagementGetOrderOptions as ManagementGetOrderOptions, type context$1_ManagementListOrdersOptions as ManagementListOrdersOptions, type context$1_MarkAsPaidRequest as MarkAsPaidRequest, type context$1_MarkAsPaidResponse as MarkAsPaidResponse, type context$1_MemberGetOrderOptions as MemberGetOrderOptions, type context$1_MemberGetOrderRequest as MemberGetOrderRequest, type context$1_MemberGetOrderResponse as MemberGetOrderResponse, type context$1_MemberGetOrderResponseNonNullableFields as MemberGetOrderResponseNonNullableFields, type context$1_MemberListOrdersOptions as MemberListOrdersOptions, type context$1_MemberListOrdersRequest as MemberListOrdersRequest, type context$1_MemberListOrdersResponse as MemberListOrdersResponse, type context$1_MemberListOrdersResponseNonNullableFields as MemberListOrdersResponseNonNullableFields, type MessageEnvelope$1 as MessageEnvelope, type context$1_OnBehalf as OnBehalf, type context$1_Order as Order, type context$1_OrderAutoRenewCanceled as OrderAutoRenewCanceled, type context$1_OrderAutoRenewCanceledEnvelope as OrderAutoRenewCanceledEnvelope, type context$1_OrderCanceled as OrderCanceled, type context$1_OrderCanceledEnvelope as OrderCanceledEnvelope, type context$1_OrderCreatedEnvelope as OrderCreatedEnvelope, type context$1_OrderCycle as OrderCycle, type context$1_OrderCycleStarted as OrderCycleStarted, type context$1_OrderCycleStartedEnvelope as OrderCycleStartedEnvelope, type context$1_OrderEndDatePostponed as OrderEndDatePostponed, type context$1_OrderEndDatePostponedEnvelope as OrderEndDatePostponedEnvelope, type context$1_OrderEnded as OrderEnded, type context$1_OrderEndedEnvelope as OrderEndedEnvelope, type context$1_OrderMarkedAsPaid as OrderMarkedAsPaid, type context$1_OrderMarkedAsPaidEnvelope as OrderMarkedAsPaidEnvelope, context$1_OrderMethod as OrderMethod, type context$1_OrderNonNullableFields as OrderNonNullableFields, type context$1_OrderPaused as OrderPaused, type context$1_OrderPausedEnvelope as OrderPausedEnvelope, type context$1_OrderPurchased as OrderPurchased, type context$1_OrderPurchasedEnvelope as OrderPurchasedEnvelope, type context$1_OrderResumed as OrderResumed, type context$1_OrderResumedEnvelope as OrderResumedEnvelope, type context$1_OrderStartDateChanged as OrderStartDateChanged, type context$1_OrderStartDateChangedEnvelope as OrderStartDateChangedEnvelope, type context$1_OrderStarted as OrderStarted, type context$1_OrderStartedEnvelope as OrderStartedEnvelope, context$1_OrderStatus as OrderStatus, context$1_OrderType as OrderType, type context$1_OrderUpdatedEnvelope as OrderUpdatedEnvelope, type context$1_OrdersQueryOrdersRequest as OrdersQueryOrdersRequest, type context$1_OrdersQueryOrdersResponse as OrdersQueryOrdersResponse, type Paging$1 as Paging, type PagingMetadataV2$1 as PagingMetadataV2, type context$1_PauseOrderRequest as PauseOrderRequest, type context$1_PauseOrderResponse as PauseOrderResponse, type context$1_PausePeriod as PausePeriod, context$1_PaymentStatus as PaymentStatus, PeriodUnit$1 as PeriodUnit, type context$1_PostponeEndDateRequest as PostponeEndDateRequest, type context$1_PostponeEndDateResponse as PostponeEndDateResponse, type context$1_Price as Price, type context$1_PriceDetails as PriceDetails, type context$1_PriceDetailsPricingModelOneOf as PriceDetailsPricingModelOneOf, type context$1_PriceDuration as PriceDuration, type context$1_PricingDetails as PricingDetails, type context$1_PricingDetailsPricingModelOneOf as PricingDetailsPricingModelOneOf, type context$1_QueryOrdersRequest as QueryOrdersRequest, type context$1_QueryOrdersResponse as QueryOrdersResponse, type QueryV2$1 as QueryV2, type context$1_QueryV2PagingMethodOneOf as QueryV2PagingMethodOneOf, context$1_ReasonNotSuspendable as ReasonNotSuspendable, type Recurrence$1 as Recurrence, type context$1_RequestCancellationRequest as RequestCancellationRequest, type context$1_RequestCancellationResponse as RequestCancellationResponse, type RestoreInfo$1 as RestoreInfo, type context$1_ResumeOrderRequest as ResumeOrderRequest, type context$1_ResumeOrderResponse as ResumeOrderResponse, context$1_Set as Set, type context$1_SetSubmissionRequest as SetSubmissionRequest, type context$1_SetSubmissionResponse as SetSubmissionResponse, SortOrder$1 as SortOrder, type Sorting$1 as Sorting, type context$1_SpannedPrice as SpannedPrice, context$1_Status as Status, type context$1_Tax as Tax, WebhookIdentityType$1 as WebhookIdentityType, type context$1__publicOnOrderAutoRenewCanceledType as _publicOnOrderAutoRenewCanceledType, type context$1__publicOnOrderCanceledType as _publicOnOrderCanceledType, type context$1__publicOnOrderCreatedType as _publicOnOrderCreatedType, type context$1__publicOnOrderCycleStartedType as _publicOnOrderCycleStartedType, type context$1__publicOnOrderEndDatePostponedType as _publicOnOrderEndDatePostponedType, type context$1__publicOnOrderEndedType as _publicOnOrderEndedType, type context$1__publicOnOrderMarkedAsPaidType as _publicOnOrderMarkedAsPaidType, type context$1__publicOnOrderPausedType as _publicOnOrderPausedType, type context$1__publicOnOrderPurchasedType as _publicOnOrderPurchasedType, type context$1__publicOnOrderResumedType as _publicOnOrderResumedType, type context$1__publicOnOrderStartDateChangedType as _publicOnOrderStartDateChangedType, type context$1__publicOnOrderStartedType as _publicOnOrderStartedType, type context$1__publicOnOrderUpdatedType as _publicOnOrderUpdatedType, context$1_cancelOrder as cancelOrder, context$1_createOfflineOrder as createOfflineOrder, context$1_getOfflineOrderPreview as getOfflineOrderPreview, context$1_getPricePreview as getPricePreview, context$1_managementGetOrder as managementGetOrder, context$1_managementListOrders as managementListOrders, context$1_markAsPaid as markAsPaid, context$1_memberGetOrder as memberGetOrder, context$1_memberListOrders as memberListOrders, context$1_onOrderAutoRenewCanceled as onOrderAutoRenewCanceled, context$1_onOrderCanceled as onOrderCanceled, context$1_onOrderCreated as onOrderCreated, context$1_onOrderCycleStarted as onOrderCycleStarted, context$1_onOrderEndDatePostponed as onOrderEndDatePostponed, context$1_onOrderEnded as onOrderEnded, context$1_onOrderMarkedAsPaid as onOrderMarkedAsPaid, context$1_onOrderPaused as onOrderPaused, context$1_onOrderPurchased as onOrderPurchased, context$1_onOrderResumed as onOrderResumed, context$1_onOrderStartDateChanged as onOrderStartDateChanged, context$1_onOrderStarted as onOrderStarted, context$1_onOrderUpdated as onOrderUpdated, context$1_pauseOrder as pauseOrder, context$1_postponeEndDate as postponeEndDate, onOrderAutoRenewCanceled$1 as publicOnOrderAutoRenewCanceled, onOrderCanceled$1 as publicOnOrderCanceled, onOrderCreated$1 as publicOnOrderCreated, onOrderCycleStarted$1 as publicOnOrderCycleStarted, onOrderEndDatePostponed$1 as publicOnOrderEndDatePostponed, onOrderEnded$1 as publicOnOrderEnded, onOrderMarkedAsPaid$1 as publicOnOrderMarkedAsPaid, onOrderPaused$1 as publicOnOrderPaused, onOrderPurchased$1 as publicOnOrderPurchased, onOrderResumed$1 as publicOnOrderResumed, onOrderStartDateChanged$1 as publicOnOrderStartDateChanged, onOrderStarted$1 as publicOnOrderStarted, onOrderUpdated$1 as publicOnOrderUpdated, context$1_requestCancellation as requestCancellation, context$1_resumeOrder as resumeOrder };
}

type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition$1<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition$1<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition$1<Payload, Type>;
type EventHandler$1<T extends EventDefinition$1> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition$1<T extends EventDefinition$1<any, string>> = (handler: EventHandler$1<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> = NonNullable<
// Wrap in `NonNullable` to strip away the `undefined` type from the produced union.
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key since the condition passes.
		? Key
	// Discard this key since the condition fails.
		: never;

	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base]
>;

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition$1<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition$1<any> ? BuildEventDefinition$1<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

/** Information about the pricing plan. */
interface Plan {
    /**
     * Plan ID.
     * @readonly
     */
    _id?: string;
    /** Plan name. */
    name?: string | null;
    /** Plan description. */
    description?: string | null;
    /**
     * List of text strings that promote what is included with this plan.
     *
     * For example, "Plenty of parking" or "Free gift on your birthday".
     */
    perks?: StringList;
    /** Plan price, payment schedule, and expiration. */
    pricing?: Pricing;
    /** Whether the plan is public (visible to site visitors and members). */
    public?: boolean | null;
    /**
     * Whether the plan is archived. Archived plans are not visible and can't be purchased anymore, but existing purchases remain in effect.
     * @readonly
     */
    archived?: boolean;
    /**
     * Whether the plan is marked as primary. If `true`, the plan is highlighted on the site with a custom ribbon.
     *
     * Default: `false`.
     * @readonly
     */
    primary?: boolean;
    /**
     * Whether the plan has any orders (including pending and unpaid orders).
     * @readonly
     */
    hasOrders?: boolean;
    /**
     * Date plan was created.
     * @readonly
     */
    _createdDate?: Date;
    /**
     * Date plan was last updated.
     * @readonly
     */
    _updatedDate?: Date;
    /**
     * URL-friendly version of plan name. Unique across all plans in the same site.
     * @readonly
     */
    slug?: string | null;
    /**
     * Number of times the same buyer can purchase the plan. Currently limited to support:
     * - Empty value or a value of `0`, meaning no limitation.
     * - Value of `1`, meaning limited to one purchase per buyer.
     */
    maxPurchasesPerBuyer?: number | null;
    /**
     * Whether the buyer can start the plan at a later date.
     *
     * Default: `false`.
     *
     */
    allowFutureStartDate?: boolean | null;
    /**
     * Whether the buyer is allowed to cancel their plan. If `false`, calling the [`requestCancellation()`](https://www.wix.com/velo/reference/wix-pricing-plans-v2/orders/requestcancellation) function returns an error.
     *
     * Default: `true`.
     *
     */
    buyerCanCancel?: boolean | null;
    /** Any terms and conditions that apply to the plan. This information will be displayed during checkout. */
    termsAndConditions?: string | null;
    /** ID of the form associated with the plan at checkout. */
    formId?: string | null;
}
/** This wrapper type exist in order to distinguish an empty string list from no list at all in update requests. */
interface StringList {
    values?: string[];
}
/** Plan pricing information. Includes the price of the plan and payment details. */
interface Pricing extends PricingPricingModelOneOf {
    /**
     * Pricing model indicating that the plan has recurring payments.
     *
     * Note: This type of subscription is not a "Wix subscription," which encompasses various types of subscriptions, such as Wix Stores subscriptions, Wix invoice subscriptions, and *all* pricing plan models.
     */
    subscription?: Recurrence;
    /** Pricing model indicating a single payment per cycle and the length of the cycle. The cycle is the duration of the plan, not a payment cycle. */
    singlePaymentForDuration?: Duration;
    /** Pricing model indicating the plan is paid in one single payment. The plan is valid until canceled.   */
    singlePaymentUnlimited?: boolean | null;
    /** Amount for a single payment. For subscriptions, this is the amount to pay each payment cycle and it is required. For plans that are not recurring plans, it is the single payment amount for the whole subscription.  */
    price?: Money;
    /** Free trial period for the plan in days. Available only for recurring plans, meaning plans whose pricing model is `subscription`. Set to `0` to remove the free trial.  */
    freeTrialDays?: number | null;
}
/** @oneof */
interface PricingPricingModelOneOf {
    /** Plan has recurring payments. */
    subscription?: Recurrence;
    /** One time payment, plan is valid for the specified duration. */
    singlePaymentForDuration?: Duration;
    /** One time payment, plan is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
}
/** An object specifying how often and for how long payments recur (may be forever). */
interface Recurrence {
    /** Length of one payment cycle. For example, 1 month to have monthly payments. Multiply `cycleDuration`'s `count` by `cycleCount` to get the subscription duration. Currently, only a value of `1` is supported.  */
    cycleDuration?: Duration;
    /**
     * Amount of payment cycles the subscription is valid for.
     *
     * `0` for unlimited plans or for plans that are valid until canceled.
     */
    cycleCount?: number | null;
}
/** A duration expressed in number of time units. */
interface Duration {
    /** Number of days days, months, weeks, or years in a single payment cycle. Currently limited to support only `1`.  */
    count?: number | null;
    /** Unit of time for the cycle duration. */
    unit?: PeriodUnit;
}
declare enum PeriodUnit {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface Money {
    /** Monetary amount. Decimal string with a period as a decimal separator. For example, `'3.99'`. Cannot be a negative value.   */
    value?: string;
    /**
     * Currency code. Three-letter currency code in
     * [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format. For example, `'USD'`.
     */
    currency?: string;
}
interface FeeConfig {
    /** Fee configuration. */
    fee?: Fee;
    /** The time this fee will be charged */
    appliedAt?: AppliedAt;
}
interface Fee {
    /** Fee name */
    name?: string;
    /** Amount of fee to be charged */
    amount?: string;
}
declare enum AppliedAt {
    UNKNOWN_CHARGE_EVENT = "UNKNOWN_CHARGE_EVENT",
    /** Will charge the fee on first payment. If order has a free trial meaning it will charge after the free trial. */
    FIRST_PAYMENT = "FIRST_PAYMENT"
}
interface ListPublicPlansRequest {
    /**
     * Number of pricing plans to list.
     *
     * Default: `75`.
     */
    limit?: number | null;
    /**
     * Number of pricing plans to skip.
     *
     * Default: `0`.
     */
    offset?: number | null;
    /** IDs of public plans to list. If non-existent IDs are specified, they are ignored and don't cause errors. If no IDs are specified, all public are listed according to the [order](#arrangeplans) displayed in the Dashboard. You can pass a maximum of 100 IDs.  */
    planIds?: string[];
}
interface ListPublicPlansResponse {
    /** List of public pricing plans. */
    plans?: PublicPlan[];
    /** Details on the paged set of public pricing plans returned.  */
    pagingMetadata?: PagingMetadataV2;
}
/** Public plan entity containing information about the pricing plan. Can be read by any site member or visitor. */
interface PublicPlan {
    /** Plan ID. */
    _id?: string;
    /** Plan name. */
    name?: string | null;
    /** Plan description. */
    description?: string | null;
    /** What is included with this plan (e.g., 1 weekly entrance to a specific class). */
    perks?: StringList;
    /** Plan price, payment schedule, and expiration. */
    pricing?: Pricing;
    /** Whether the plan is marked as primary. */
    primary?: boolean;
    /** Date plan was created. */
    _createdDate?: Date;
    /** Date plan was last updated. */
    _updatedDate?: Date;
    /** URL-friendly version of plan name. Unique across all plans in the same site. */
    slug?: string | null;
    /** Number of times the same buyer can purchase the plan. An empty value or a value of zero means no limitation. */
    maxPurchasesPerBuyer?: number | null;
    /** Whether the buyer can start the plan at a later date. Defaults to false. */
    allowFutureStartDate?: boolean | null;
    /** Whether the buyer is allowed to cancel their plan. Defaults to false. */
    buyerCanCancel?: boolean | null;
    /** Any terms and conditions that apply to the plan. This information will be displayed during checkout. */
    termsAndConditions?: string | null;
    /** ID of the form associated with the plan at checkout. */
    formId?: string | null;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface QueryPublicPlansRequest {
    /** Query */
    query?: QueryV2;
}
interface QueryV2 {
    /** A filter object. See [supported fields and operators](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/filter-and-sort#wix-pricing-plans_pricing-plans_plans_filter-and-sort_query-public-plans) */
    filter?: Record<string, any> | null;
    /** Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}] */
    sort?: Sorting[];
    /** Pointer to page of results using offset. Can not be used together with 'cursorPaging' */
    paging?: Paging;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface QueryPublicPlansResponse {
    /** List of public pricing plans that match the specified query. */
    plans?: PublicPlan[];
    /** Object containing paging-related data (number of plans returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
interface GetPlanRequest {
    /** Plan ID. */
    _id: string;
}
interface GetPlanResponse {
    /** Pricing plan info.  */
    plan?: Plan;
}
interface ListPlansRequest {
    /**
     * Archived filter.
     *
     * Default: `ACTIVE` (not archived).
     */
    archived?: ArchivedFilter;
    /**
     * Visibility filter.
     *
     * Default: `PUBLIC_AND_HIDDEN` (meaning, both public and hidden plans are listed).
     *
     */
    public?: PublicFilter;
    /**
     * Number of pricing plans to list.
     *
     * Default: `75`.
     */
    limit?: number | null;
    /**
     * Number of pricing plans to skip.
     *
     * Default: `0`.
     */
    offset?: number | null;
    /** IDs of plans to list. If non-existent IDs are specified, they are ignored and don't cause errors. If no IDs are specified, all public and hidden plans (based on `options`) are listed according to the [order](#arrangeplans) displayed in the Dashboard. You can pass a maximum of 100 IDs.  */
    planIds?: string[];
}
declare enum ArchivedFilter {
    /** Returns all plans that are active. */
    ACTIVE = "ACTIVE",
    /** Returns all plans that are archived. */
    ARCHIVED = "ARCHIVED",
    /** Returns all plans that are active and archived. */
    ARCHIVED_AND_ACTIVE = "ARCHIVED_AND_ACTIVE"
}
declare enum PublicFilter {
    /** Returns all public and hidden plans. */
    PUBLIC_AND_HIDDEN = "PUBLIC_AND_HIDDEN",
    /** Returns only public plans. */
    PUBLIC = "PUBLIC",
    /** Returns only hidden plans. */
    HIDDEN = "HIDDEN"
}
interface ListPlansResponse {
    /** List of all public and hidden pricing plans. */
    plans?: Plan[];
    /** Details on the paged set of pricing plans returned.  */
    pagingMetadata?: PagingMetadataV2;
}
interface GetPlanStatsRequest {
}
interface GetPlanStatsResponse {
    /** Total number of plans created, including active plans (both public and hidden) and archived plans. */
    totalPlans?: number;
}
interface CreatePlanRequest {
    /** Information for the plan being created. */
    plan: Plan;
}
interface CreatePlanResponse {
    /** Plan info.  */
    plan?: Plan;
}
interface UpdatePlanRequest {
    /** Plan info to update. */
    plan: Plan;
}
interface UpdatePlanResponse {
    /** Updated plan info. */
    plan?: Plan;
}
interface BuyerCanCancelUpdated {
    /** Pricing plan. */
    plan?: Plan;
}
interface SetPlanVisibilityRequest {
    /** The ID of the plan to either display or hide on the site page.  */
    _id: string;
    /** Whether to set the plan as visible. */
    visible: boolean;
}
interface SetPlanVisibilityResponse {
    /** Plan info.  */
    plan?: Plan;
}
interface MakePlanPrimaryRequest {
    /** ID of the pricing plan to set as the primary plan. */
    _id: string;
}
interface MakePlanPrimaryResponse {
    /** Primary plan info. */
    plan?: Plan;
}
interface ClearPrimaryRequest {
}
interface ClearPrimaryResponse {
}
interface ArchivePlanRequest {
    _id: string;
}
interface ArchivePlanResponse {
    /** Archived plan info.  */
    plan?: Plan;
}
interface PlanArchived {
    /** Pricing plan. */
    plan?: Plan;
}
interface BulkArchivePlanRequest {
    /** List of Plan IDs. */
    ids?: string[];
    /** Set to true to return Plan entity in response. */
    returnFullEntity?: boolean;
}
interface BulkArchivePlanResponse {
    /** Plans to be archived. */
    results?: BulkPlanResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkPlanResult {
    /** Item metadata. */
    itemMetadata?: ItemMetadata;
    /** Pricing plan. */
    plan?: Plan;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface ArrangePlansRequest {
    /** IDs of all non-archived plans in the order you want them arranged. */
    ids?: string[];
}
interface ArrangePlansResponse {
}
interface CountPlansRequest {
    /** The filter. */
    filter?: Record<string, any> | null;
    /** If true, will count only visible plans (visible and not archived). If no value is given all site's plans will be counted. */
    visibility?: boolean | null;
}
interface CountPlansResponse {
    /** Number of plans in the response. */
    count?: number;
}
interface GetPlansPremiumStatusRequest {
}
interface GetPlansPremiumStatusResponse {
    /** True if site has non-free, non-template plans. */
    hasPaidPlans?: boolean;
    /** True if site has plans that were created before Pricing Plans became a premium app. */
    hasOldPlans?: boolean;
}
interface SearchPlansRequest {
    /** Query */
    query?: QueryV2;
    /** Search phrase for plan name */
    searchPhrase?: string | null;
}
interface SearchPlansResponse {
    /** List of pricing plans that match the specified filter and search phrase. */
    plans?: Plan[];
    /** Object containing paging-related data (number of plans returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface StringListNonNullableFields {
    values: string[];
}
interface DurationNonNullableFields {
    unit: PeriodUnit;
}
interface RecurrenceNonNullableFields {
    cycleDuration?: DurationNonNullableFields;
}
interface MoneyNonNullableFields {
    value: string;
    currency: string;
}
interface FeeNonNullableFields {
    name: string;
    amount: string;
}
interface FeeConfigNonNullableFields {
    fee?: FeeNonNullableFields;
    appliedAt: AppliedAt;
}
interface PricingNonNullableFields {
    subscription?: RecurrenceNonNullableFields;
    singlePaymentForDuration?: DurationNonNullableFields;
    price?: MoneyNonNullableFields;
    feeConfigs: FeeConfigNonNullableFields[];
}
interface PublicPlanNonNullableFields {
    _id: string;
    perks?: StringListNonNullableFields;
    pricing?: PricingNonNullableFields;
    primary: boolean;
}
interface ListPublicPlansResponseNonNullableFields {
    plans: PublicPlanNonNullableFields[];
}
interface QueryPublicPlansResponseNonNullableFields {
    plans: PublicPlanNonNullableFields[];
}
interface PlanNonNullableFields {
    _id: string;
    perks?: StringListNonNullableFields;
    pricing?: PricingNonNullableFields;
    archived: boolean;
    primary: boolean;
    hasOrders: boolean;
}
interface GetPlanResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface ListPlansResponseNonNullableFields {
    plans: PlanNonNullableFields[];
}
interface GetPlanStatsResponseNonNullableFields {
    totalPlans: number;
}
interface CreatePlanResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface UpdatePlanResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface SetPlanVisibilityResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface MakePlanPrimaryResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface ArchivePlanResponseNonNullableFields {
    plan?: PlanNonNullableFields;
}
interface BaseEventMetadata {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
interface PlanUpdatedEnvelope {
    entity: Plan;
    metadata: EventMetadata;
}
interface PlanCreatedEnvelope {
    entity: Plan;
    metadata: EventMetadata;
}
interface PlanBuyerCanCancelUpdatedEnvelope {
    data: BuyerCanCancelUpdated;
    metadata: EventMetadata;
}
interface PlanArchivedEnvelope {
    data: PlanArchived;
    metadata: EventMetadata;
}
interface ListPublicPlansOptions {
    /**
     * Number of pricing plans to list.
     *
     * Default: `75`.
     */
    limit?: number | null;
    /**
     * Number of pricing plans to skip.
     *
     * Default: `0`.
     */
    offset?: number | null;
    /** IDs of public plans to list. If non-existent IDs are specified, they are ignored and don't cause errors. If no IDs are specified, all public are listed according to the [order](#arrangeplans) displayed in the Dashboard. You can pass a maximum of 100 IDs.  */
    planIds?: string[];
}
interface QueryOffsetResult {
    currentPage: number | undefined;
    totalPages: number | undefined;
    totalCount: number | undefined;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface PlansQueryResult extends QueryOffsetResult {
    items: PublicPlan[];
    query: PlansQueryBuilder;
    next: () => Promise<PlansQueryResult>;
    prev: () => Promise<PlansQueryResult>;
}
interface PlansQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    eq: (propertyName: '_id' | 'primary' | '_createdDate' | '_updatedDate' | 'slug', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ne: (propertyName: '_id' | 'primary' | '_createdDate' | '_updatedDate' | 'slug', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ge: (propertyName: '_createdDate' | '_updatedDate', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    gt: (propertyName: '_createdDate' | '_updatedDate', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    le: (propertyName: '_createdDate' | '_updatedDate', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    lt: (propertyName: '_createdDate' | '_updatedDate', value: any) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     */
    startsWith: (propertyName: '_id' | 'slug', value: string) => PlansQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     */
    hasSome: (propertyName: '_id' | 'primary' | '_createdDate' | '_updatedDate' | 'slug', value: any[]) => PlansQueryBuilder;
    in: (propertyName: '_id' | 'primary' | '_createdDate' | '_updatedDate' | 'slug', value: any) => PlansQueryBuilder;
    exists: (propertyName: '_id' | 'primary' | '_createdDate' | '_updatedDate' | 'slug', value: boolean) => PlansQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    ascending: (...propertyNames: Array<'_id' | 'primary' | '_createdDate' | '_updatedDate' | 'slug'>) => PlansQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    descending: (...propertyNames: Array<'_id' | 'primary' | '_createdDate' | '_updatedDate' | 'slug'>) => PlansQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
    limit: (limit: number) => PlansQueryBuilder;
    /** @param skip - Number of items to skip in the query results before returning the results. */
    skip: (skip: number) => PlansQueryBuilder;
    find: () => Promise<PlansQueryResult>;
}
interface ListPlansOptions {
    /**
     * Archived filter.
     *
     * Default: `ACTIVE` (not archived).
     */
    archived?: ArchivedFilter;
    /**
     * Visibility filter.
     *
     * Default: `PUBLIC_AND_HIDDEN` (meaning, both public and hidden plans are listed).
     *
     */
    public?: PublicFilter;
    /**
     * Number of pricing plans to list.
     *
     * Default: `75`.
     */
    limit?: number | null;
    /**
     * Number of pricing plans to skip.
     *
     * Default: `0`.
     */
    offset?: number | null;
    /** IDs of plans to list. If non-existent IDs are specified, they are ignored and don't cause errors. If no IDs are specified, all public and hidden plans (based on `options`) are listed according to the [order](#arrangeplans) displayed in the Dashboard. You can pass a maximum of 100 IDs.  */
    planIds?: string[];
}
interface UpdatePlan {
    /**
     * Plan ID.
     * @readonly
     */
    _id?: string;
    /** Plan name. */
    name?: string | null;
    /** Plan description. */
    description?: string | null;
    /**
     * List of text strings that promote what is included with this plan.
     *
     * For example, "Plenty of parking" or "Free gift on your birthday".
     */
    perks?: StringList;
    /** Plan price, payment schedule, and expiration. */
    pricing?: Pricing;
    /** Whether the plan is public (visible to site visitors and members). */
    public?: boolean | null;
    /**
     * Whether the plan is archived. Archived plans are not visible and can't be purchased anymore, but existing purchases remain in effect.
     * @readonly
     */
    archived?: boolean;
    /**
     * Whether the plan is marked as primary. If `true`, the plan is highlighted on the site with a custom ribbon.
     *
     * Default: `false`.
     * @readonly
     */
    primary?: boolean;
    /**
     * Whether the plan has any orders (including pending and unpaid orders).
     * @readonly
     */
    hasOrders?: boolean;
    /**
     * Date plan was created.
     * @readonly
     */
    _createdDate?: Date;
    /**
     * Date plan was last updated.
     * @readonly
     */
    _updatedDate?: Date;
    /**
     * URL-friendly version of plan name. Unique across all plans in the same site.
     * @readonly
     */
    slug?: string | null;
    /**
     * Number of times the same buyer can purchase the plan. Currently limited to support:
     * - Empty value or a value of `0`, meaning no limitation.
     * - Value of `1`, meaning limited to one purchase per buyer.
     */
    maxPurchasesPerBuyer?: number | null;
    /**
     * Whether the buyer can start the plan at a later date.
     *
     * Default: `false`.
     *
     */
    allowFutureStartDate?: boolean | null;
    /**
     * Whether the buyer is allowed to cancel their plan. If `false`, calling the [`requestCancellation()`](https://www.wix.com/velo/reference/wix-pricing-plans-v2/orders/requestcancellation) function returns an error.
     *
     * Default: `true`.
     *
     */
    buyerCanCancel?: boolean | null;
    /** Any terms and conditions that apply to the plan. This information will be displayed during checkout. */
    termsAndConditions?: string | null;
    /** ID of the form associated with the plan at checkout. */
    formId?: string | null;
}

declare function listPublicPlans$1(httpClient: HttpClient): ListPublicPlansSignature;
interface ListPublicPlansSignature {
    /**
     * Retrieves a list of public pricing plans.
     *
     *
     * The `listPublicPlans()` function returns a Promise that resolves to a list of up to 100 public pricing plans. Public plans are visible plans that site visitors can see on the site and purchase.
     * @param - Options for filtering and paging the list of public plans.
     * @returns Fulfilled - List of public pricing plans.
     */
    (options?: ListPublicPlansOptions | undefined): Promise<ListPublicPlansResponse & ListPublicPlansResponseNonNullableFields>;
}
declare function queryPublicPlans$1(httpClient: HttpClient): QueryPublicPlansSignature;
interface QueryPublicPlansSignature {
    /**
     * Creates a query to retrieve a list of public pricing plans.
     *
     *
     * The `queryPublicPlans()` function builds a query to retrieve a list of up to 1,000 public plans and returns a [`PublicPlansQueryBuilder`](#plansquerybuilder) object.
     *
     * The returned object contains the query definition which is typically used to run the query using the [`find()`](#plansquerybuilder/find) function.
     *
     * You can refine the query by chaining `PublicPlansQueryBuilder` functions onto the query. `PublicPlansQueryBuilder` functions enable you to sort, filter, and control the results that `queryPublicPlans()` returns.
     *
     * `queryPublicPlans()` runs with the following `PublicPlansQueryBuilder` defaults that you can override:
     * - [`skip`](#plansquerybuilder/skip): `0`
     * - [`limit`](#plansquerybuilder/limit): `50`
     *
     * The functions that are chained to `queryPublicPlans()` are applied in the order they are called. For example, if you sort on the `_createdDate` property in ascending order and then on the `_id` property in ascending order, the results are sorted first by the created date of the items and then, if there are multiple results with the same date, the items are sorted by `_id` in ascending order, per created date value.
     *
     * The following `PublicPlansQueryBuilder` functions are supported for the `queryPublicPlans()` function. For a full description of the Plans object, see the object returned for the [`items`](#plansqueryresult/items) property in [`PublicPlansQueryResult`](#plansqueryresult).
     */
    (): PlansQueryBuilder;
}
declare function getPlan$1(httpClient: HttpClient): GetPlanSignature;
interface GetPlanSignature {
    /**
     * Retrieves a pricing plan by the specified ID.
     *
     * The `getPlan()` function returns a Promise that resolves to a plan whose ID matched the specified ID.
     * @param - Plan ID.
     * @returns Fulfilled - The retrieved plan's information.
     */
    (_id: string): Promise<Plan & PlanNonNullableFields>;
}
declare function listPlans$1(httpClient: HttpClient): ListPlansSignature;
interface ListPlansSignature {
    /**
     * Retrieves a list of pricing plans.
     *
     * The `listPlans()` function returns a Promise that resolves to a list of up to 100 pricing plans. This includes public, hidden, and archived plans.
     * @param - Options for filtering and paging the list of plans.
     * @returns Fulfilled - List of plans that match the given criteria.
     */
    (options?: ListPlansOptions | undefined): Promise<ListPlansResponse & ListPlansResponseNonNullableFields>;
}
declare function getPlanStats$1(httpClient: HttpClient): GetPlanStatsSignature;
interface GetPlanStatsSignature {
    /**
     * Retrieves statistics about the pricing plans.
     *
     *
     * The `getPlanStats()` function returns a Promise that resolves to statistics about the plan on the site.
     *
     * Currently this function provides only the total number of pricing plans, including archived plans.
     * @returns Fulfilled - Overall statistics about the pricing plans.
     */
    (): Promise<GetPlanStatsResponse & GetPlanStatsResponseNonNullableFields>;
}
declare function createPlan$1(httpClient: HttpClient): CreatePlanSignature;
interface CreatePlanSignature {
    /**
     * Creates a pricing plan.
     *
     *
     * The `createPlan()` function returns a Promise that resolves to a newly-created pricing plan after is has successfully been created.
     *
     * The passed `plan` object must contain a [pricing model](https://www.wix.com/velo/reference/wix-pricing-plans-v2/plans/pricing-models). A pricing model can be one of the following:
     * - **A subscription**: A subscription with recurring payment and how often the plan occurs. Subscriptions can have free trial days.
     * - **A plan that does not renew**: A single payment for a specific duration that doesn't renew.
     * - **An unlimited plan**: A single payment for an unlimited amount of time (until canceled).
     *
     * Pricing plans created by this function are available to the site owner in the Pricing Plans section in the Dashboard.
     * @param - Information for the plan being created.
     * @returns Fulfilled - The created plan.
     *
     * Rejected - Error message.
     */
    (plan: Plan): Promise<Plan & PlanNonNullableFields>;
}
declare function updatePlan$1(httpClient: HttpClient): UpdatePlanSignature;
interface UpdatePlanSignature {
    /**
     * Updates a pricing plan.
     *
     *
     * The `updatePlan()` function returns a Promise that resolves to an updated plan.
     *
     * Updating a plan does not impact existing purchases made for the plan. All purchases keep the details of the original plan that was active at the time of the purchase.
     * @param - ID of the plan to update.
     * @param - Options for updating the plan.
     * @returns Fulfilled - The updated plan.
     *
     * Rejected - Error message.
     */
    (_id: string, plan: UpdatePlan): Promise<Plan & PlanNonNullableFields>;
}
declare function setPlanVisibility$1(httpClient: HttpClient): SetPlanVisibilitySignature;
interface SetPlanVisibilitySignature {
    /**
     * Sets visibility for non-archived pricing plans.
     *
     * The `setPlanVisibility()` functions returns a Promise that resolves to a pricing plan when its visibility has successfully been set.
     *
     * By default, pricing plans are public, meaning they are visible. [Plans can be hidden](https://support.wix.com/en/article/pricing-plans-removing-a-plan-from-your-site#hiding-plans) so that site members and visitors cannot see or choose them.
     *
     * As opposed to archiving, setting visibility can be reversed. This means that a public plan can be hidden, and a hidden plan can be made public (visible).
     *
     * >**Note:** An archived plan always remains archived and cannot be made active again. When archiving a plan, its `public` property is automatically set to `false` so that it is hidden.
     *
     * Changing a plan's visibility does not impact existing orders for the plan. All orders for hidden plans are still active and keep their terms and payment options.
     * @param - Whether to set the plan as visible.
     * @param - The ID of the plan to either display or hide on the site page.
     * @param - Plan visibility options.
     * @returns Fulfilled - The plan's information.
     *
     * Rejected - Error message.
     */
    (_id: string, visible: boolean): Promise<SetPlanVisibilityResponse & SetPlanVisibilityResponseNonNullableFields>;
}
declare function makePlanPrimary$1(httpClient: HttpClient): MakePlanPrimarySignature;
interface MakePlanPrimarySignature {
    /**
     * Marks a pricing plan as the primary pricing plan.
     *
     *
     * The `makePlanPrimary()` function returns a Promise that resolves to the now primary pricing plan.
     *
     * Only a single plan can be marked as a primary plan at any given time. If there is an existing plan marked as primary, calling `makePlanPrimary()` causes the existing primary plan to lose its primary status.
     *
     * When viewing pricing plans on the site, the primary plan is highlighted with a customizable ribbon.
     * @param - ID of the pricing plan to set as the primary plan.
     * @returns Fulfilled - The primary plan.
     */
    (_id: string): Promise<MakePlanPrimaryResponse & MakePlanPrimaryResponseNonNullableFields>;
}
declare function clearPrimary$1(httpClient: HttpClient): ClearPrimarySignature;
interface ClearPrimarySignature {
    /**
     * Sets all pricing plans to no longer be primary.
     *
     * The `clearPrimary()` function returns a Promise that is resolved when there are no pricing plans marked as `primary`.
     *
     * After clearing the primary plan, when viewing pricing plans on the site, no plan is highlighted with a customizable ribbon.
     */
    (): Promise<void>;
}
declare function archivePlan$1(httpClient: HttpClient): ArchivePlanSignature;
interface ArchivePlanSignature {
    /**
     * Archives a single plan.
     *
     *
     * The `archivePlan()` function returns a Promise that resolves to the newly-archived plan.
     *
     * When a plan is archived, the plan
     * - Is no longer available for display or selection by visitors. This is because the plan's `public` property is automatically set to `false`.
     * - Cannot be purchased.
     * - Cannot be "un-archived", meaning the plan cannot be made active again.
     *
     * Plan archiving does not impact existing purchases made for the plan. All purchases for the plan are still active and keep their payment options and terms.
     *
     * Site owners can see archived plans in the Dashboard under **Pricing Plans -> Archived Plans**.
     *
     * >**Note:** An attempt to archive an already-archived plan throws an error.
     * @param - ID of the active plan to archive.
     * @returns Fulfilled - The archived plan.
     *
     * Rejected - Error message.
     */
    (_id: string): Promise<ArchivePlanResponse & ArchivePlanResponseNonNullableFields>;
}
declare const onPlanUpdated$1: EventDefinition$1<PlanUpdatedEnvelope, "wix.pricing_plans.plan_updated">;
declare const onPlanCreated$1: EventDefinition$1<PlanCreatedEnvelope, "wix.pricing_plans.plan_created">;
declare const onPlanBuyerCanCancelUpdated$1: EventDefinition$1<PlanBuyerCanCancelUpdatedEnvelope, "wix.pricing_plans.plan_buyer_can_cancel_updated">;
declare const onPlanArchived$1: EventDefinition$1<PlanArchivedEnvelope, "wix.pricing_plans.plan_plan_archived">;

type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare function createEventModule<T extends EventDefinition<any, string>>(eventDefinition: T): BuildEventDefinition<T> & T;

declare const listPublicPlans: MaybeContext<BuildRESTFunction<typeof listPublicPlans$1> & typeof listPublicPlans$1>;
declare const queryPublicPlans: MaybeContext<BuildRESTFunction<typeof queryPublicPlans$1> & typeof queryPublicPlans$1>;
declare const getPlan: MaybeContext<BuildRESTFunction<typeof getPlan$1> & typeof getPlan$1>;
declare const listPlans: MaybeContext<BuildRESTFunction<typeof listPlans$1> & typeof listPlans$1>;
declare const getPlanStats: MaybeContext<BuildRESTFunction<typeof getPlanStats$1> & typeof getPlanStats$1>;
declare const createPlan: MaybeContext<BuildRESTFunction<typeof createPlan$1> & typeof createPlan$1>;
declare const updatePlan: MaybeContext<BuildRESTFunction<typeof updatePlan$1> & typeof updatePlan$1>;
declare const setPlanVisibility: MaybeContext<BuildRESTFunction<typeof setPlanVisibility$1> & typeof setPlanVisibility$1>;
declare const makePlanPrimary: MaybeContext<BuildRESTFunction<typeof makePlanPrimary$1> & typeof makePlanPrimary$1>;
declare const clearPrimary: MaybeContext<BuildRESTFunction<typeof clearPrimary$1> & typeof clearPrimary$1>;
declare const archivePlan: MaybeContext<BuildRESTFunction<typeof archivePlan$1> & typeof archivePlan$1>;

type _publicOnPlanUpdatedType = typeof onPlanUpdated$1;
/**
 * An event that is triggered when a pricing plan is updated.
 */
declare const onPlanUpdated: ReturnType<typeof createEventModule<_publicOnPlanUpdatedType>>;

type _publicOnPlanCreatedType = typeof onPlanCreated$1;
/**
 * An event that is triggered when a pricing plan is created.
 */
declare const onPlanCreated: ReturnType<typeof createEventModule<_publicOnPlanCreatedType>>;

type _publicOnPlanBuyerCanCancelUpdatedType = typeof onPlanBuyerCanCancelUpdated$1;
/** */
declare const onPlanBuyerCanCancelUpdated: ReturnType<typeof createEventModule<_publicOnPlanBuyerCanCancelUpdatedType>>;

type _publicOnPlanArchivedType = typeof onPlanArchived$1;
/**
 * An event that is triggered when a pricing plan is archived.
 */
declare const onPlanArchived: ReturnType<typeof createEventModule<_publicOnPlanArchivedType>>;

type context_ActionEvent = ActionEvent;
type context_ApplicationError = ApplicationError;
type context_AppliedAt = AppliedAt;
declare const context_AppliedAt: typeof AppliedAt;
type context_ArchivePlanRequest = ArchivePlanRequest;
type context_ArchivePlanResponse = ArchivePlanResponse;
type context_ArchivePlanResponseNonNullableFields = ArchivePlanResponseNonNullableFields;
type context_ArchivedFilter = ArchivedFilter;
declare const context_ArchivedFilter: typeof ArchivedFilter;
type context_ArrangePlansRequest = ArrangePlansRequest;
type context_ArrangePlansResponse = ArrangePlansResponse;
type context_BaseEventMetadata = BaseEventMetadata;
type context_BulkActionMetadata = BulkActionMetadata;
type context_BulkArchivePlanRequest = BulkArchivePlanRequest;
type context_BulkArchivePlanResponse = BulkArchivePlanResponse;
type context_BulkPlanResult = BulkPlanResult;
type context_BuyerCanCancelUpdated = BuyerCanCancelUpdated;
type context_ClearPrimaryRequest = ClearPrimaryRequest;
type context_ClearPrimaryResponse = ClearPrimaryResponse;
type context_CountPlansRequest = CountPlansRequest;
type context_CountPlansResponse = CountPlansResponse;
type context_CreatePlanRequest = CreatePlanRequest;
type context_CreatePlanResponse = CreatePlanResponse;
type context_CreatePlanResponseNonNullableFields = CreatePlanResponseNonNullableFields;
type context_Cursors = Cursors;
type context_DomainEvent = DomainEvent;
type context_DomainEventBodyOneOf = DomainEventBodyOneOf;
type context_Duration = Duration;
type context_EntityCreatedEvent = EntityCreatedEvent;
type context_EntityDeletedEvent = EntityDeletedEvent;
type context_EntityUpdatedEvent = EntityUpdatedEvent;
type context_EventMetadata = EventMetadata;
type context_Fee = Fee;
type context_FeeConfig = FeeConfig;
type context_GetPlanRequest = GetPlanRequest;
type context_GetPlanResponse = GetPlanResponse;
type context_GetPlanResponseNonNullableFields = GetPlanResponseNonNullableFields;
type context_GetPlanStatsRequest = GetPlanStatsRequest;
type context_GetPlanStatsResponse = GetPlanStatsResponse;
type context_GetPlanStatsResponseNonNullableFields = GetPlanStatsResponseNonNullableFields;
type context_GetPlansPremiumStatusRequest = GetPlansPremiumStatusRequest;
type context_GetPlansPremiumStatusResponse = GetPlansPremiumStatusResponse;
type context_IdentificationData = IdentificationData;
type context_IdentificationDataIdOneOf = IdentificationDataIdOneOf;
type context_ItemMetadata = ItemMetadata;
type context_ListPlansOptions = ListPlansOptions;
type context_ListPlansRequest = ListPlansRequest;
type context_ListPlansResponse = ListPlansResponse;
type context_ListPlansResponseNonNullableFields = ListPlansResponseNonNullableFields;
type context_ListPublicPlansOptions = ListPublicPlansOptions;
type context_ListPublicPlansRequest = ListPublicPlansRequest;
type context_ListPublicPlansResponse = ListPublicPlansResponse;
type context_ListPublicPlansResponseNonNullableFields = ListPublicPlansResponseNonNullableFields;
type context_MakePlanPrimaryRequest = MakePlanPrimaryRequest;
type context_MakePlanPrimaryResponse = MakePlanPrimaryResponse;
type context_MakePlanPrimaryResponseNonNullableFields = MakePlanPrimaryResponseNonNullableFields;
type context_MessageEnvelope = MessageEnvelope;
type context_Money = Money;
type context_Paging = Paging;
type context_PagingMetadataV2 = PagingMetadataV2;
type context_PeriodUnit = PeriodUnit;
declare const context_PeriodUnit: typeof PeriodUnit;
type context_Plan = Plan;
type context_PlanArchived = PlanArchived;
type context_PlanArchivedEnvelope = PlanArchivedEnvelope;
type context_PlanBuyerCanCancelUpdatedEnvelope = PlanBuyerCanCancelUpdatedEnvelope;
type context_PlanCreatedEnvelope = PlanCreatedEnvelope;
type context_PlanNonNullableFields = PlanNonNullableFields;
type context_PlanUpdatedEnvelope = PlanUpdatedEnvelope;
type context_PlansQueryBuilder = PlansQueryBuilder;
type context_PlansQueryResult = PlansQueryResult;
type context_Pricing = Pricing;
type context_PricingPricingModelOneOf = PricingPricingModelOneOf;
type context_PublicFilter = PublicFilter;
declare const context_PublicFilter: typeof PublicFilter;
type context_PublicPlan = PublicPlan;
type context_QueryPublicPlansRequest = QueryPublicPlansRequest;
type context_QueryPublicPlansResponse = QueryPublicPlansResponse;
type context_QueryPublicPlansResponseNonNullableFields = QueryPublicPlansResponseNonNullableFields;
type context_QueryV2 = QueryV2;
type context_Recurrence = Recurrence;
type context_RestoreInfo = RestoreInfo;
type context_SearchPlansRequest = SearchPlansRequest;
type context_SearchPlansResponse = SearchPlansResponse;
type context_SetPlanVisibilityRequest = SetPlanVisibilityRequest;
type context_SetPlanVisibilityResponse = SetPlanVisibilityResponse;
type context_SetPlanVisibilityResponseNonNullableFields = SetPlanVisibilityResponseNonNullableFields;
type context_SortOrder = SortOrder;
declare const context_SortOrder: typeof SortOrder;
type context_Sorting = Sorting;
type context_StringList = StringList;
type context_UpdatePlan = UpdatePlan;
type context_UpdatePlanRequest = UpdatePlanRequest;
type context_UpdatePlanResponse = UpdatePlanResponse;
type context_UpdatePlanResponseNonNullableFields = UpdatePlanResponseNonNullableFields;
type context_WebhookIdentityType = WebhookIdentityType;
declare const context_WebhookIdentityType: typeof WebhookIdentityType;
type context__publicOnPlanArchivedType = _publicOnPlanArchivedType;
type context__publicOnPlanBuyerCanCancelUpdatedType = _publicOnPlanBuyerCanCancelUpdatedType;
type context__publicOnPlanCreatedType = _publicOnPlanCreatedType;
type context__publicOnPlanUpdatedType = _publicOnPlanUpdatedType;
declare const context_archivePlan: typeof archivePlan;
declare const context_clearPrimary: typeof clearPrimary;
declare const context_createPlan: typeof createPlan;
declare const context_getPlan: typeof getPlan;
declare const context_getPlanStats: typeof getPlanStats;
declare const context_listPlans: typeof listPlans;
declare const context_listPublicPlans: typeof listPublicPlans;
declare const context_makePlanPrimary: typeof makePlanPrimary;
declare const context_onPlanArchived: typeof onPlanArchived;
declare const context_onPlanBuyerCanCancelUpdated: typeof onPlanBuyerCanCancelUpdated;
declare const context_onPlanCreated: typeof onPlanCreated;
declare const context_onPlanUpdated: typeof onPlanUpdated;
declare const context_queryPublicPlans: typeof queryPublicPlans;
declare const context_setPlanVisibility: typeof setPlanVisibility;
declare const context_updatePlan: typeof updatePlan;
declare namespace context {
  export { type context_ActionEvent as ActionEvent, type context_ApplicationError as ApplicationError, context_AppliedAt as AppliedAt, type context_ArchivePlanRequest as ArchivePlanRequest, type context_ArchivePlanResponse as ArchivePlanResponse, type context_ArchivePlanResponseNonNullableFields as ArchivePlanResponseNonNullableFields, context_ArchivedFilter as ArchivedFilter, type context_ArrangePlansRequest as ArrangePlansRequest, type context_ArrangePlansResponse as ArrangePlansResponse, type context_BaseEventMetadata as BaseEventMetadata, type context_BulkActionMetadata as BulkActionMetadata, type context_BulkArchivePlanRequest as BulkArchivePlanRequest, type context_BulkArchivePlanResponse as BulkArchivePlanResponse, type context_BulkPlanResult as BulkPlanResult, type context_BuyerCanCancelUpdated as BuyerCanCancelUpdated, type context_ClearPrimaryRequest as ClearPrimaryRequest, type context_ClearPrimaryResponse as ClearPrimaryResponse, type context_CountPlansRequest as CountPlansRequest, type context_CountPlansResponse as CountPlansResponse, type context_CreatePlanRequest as CreatePlanRequest, type context_CreatePlanResponse as CreatePlanResponse, type context_CreatePlanResponseNonNullableFields as CreatePlanResponseNonNullableFields, type context_Cursors as Cursors, type context_DomainEvent as DomainEvent, type context_DomainEventBodyOneOf as DomainEventBodyOneOf, type context_Duration as Duration, type context_EntityCreatedEvent as EntityCreatedEvent, type context_EntityDeletedEvent as EntityDeletedEvent, type context_EntityUpdatedEvent as EntityUpdatedEvent, type context_EventMetadata as EventMetadata, type context_Fee as Fee, type context_FeeConfig as FeeConfig, type context_GetPlanRequest as GetPlanRequest, type context_GetPlanResponse as GetPlanResponse, type context_GetPlanResponseNonNullableFields as GetPlanResponseNonNullableFields, type context_GetPlanStatsRequest as GetPlanStatsRequest, type context_GetPlanStatsResponse as GetPlanStatsResponse, type context_GetPlanStatsResponseNonNullableFields as GetPlanStatsResponseNonNullableFields, type context_GetPlansPremiumStatusRequest as GetPlansPremiumStatusRequest, type context_GetPlansPremiumStatusResponse as GetPlansPremiumStatusResponse, type context_IdentificationData as IdentificationData, type context_IdentificationDataIdOneOf as IdentificationDataIdOneOf, type context_ItemMetadata as ItemMetadata, type context_ListPlansOptions as ListPlansOptions, type context_ListPlansRequest as ListPlansRequest, type context_ListPlansResponse as ListPlansResponse, type context_ListPlansResponseNonNullableFields as ListPlansResponseNonNullableFields, type context_ListPublicPlansOptions as ListPublicPlansOptions, type context_ListPublicPlansRequest as ListPublicPlansRequest, type context_ListPublicPlansResponse as ListPublicPlansResponse, type context_ListPublicPlansResponseNonNullableFields as ListPublicPlansResponseNonNullableFields, type context_MakePlanPrimaryRequest as MakePlanPrimaryRequest, type context_MakePlanPrimaryResponse as MakePlanPrimaryResponse, type context_MakePlanPrimaryResponseNonNullableFields as MakePlanPrimaryResponseNonNullableFields, type context_MessageEnvelope as MessageEnvelope, type context_Money as Money, type context_Paging as Paging, type context_PagingMetadataV2 as PagingMetadataV2, context_PeriodUnit as PeriodUnit, type context_Plan as Plan, type context_PlanArchived as PlanArchived, type context_PlanArchivedEnvelope as PlanArchivedEnvelope, type context_PlanBuyerCanCancelUpdatedEnvelope as PlanBuyerCanCancelUpdatedEnvelope, type context_PlanCreatedEnvelope as PlanCreatedEnvelope, type context_PlanNonNullableFields as PlanNonNullableFields, type context_PlanUpdatedEnvelope as PlanUpdatedEnvelope, type context_PlansQueryBuilder as PlansQueryBuilder, type context_PlansQueryResult as PlansQueryResult, type context_Pricing as Pricing, type context_PricingPricingModelOneOf as PricingPricingModelOneOf, context_PublicFilter as PublicFilter, type context_PublicPlan as PublicPlan, type context_QueryPublicPlansRequest as QueryPublicPlansRequest, type context_QueryPublicPlansResponse as QueryPublicPlansResponse, type context_QueryPublicPlansResponseNonNullableFields as QueryPublicPlansResponseNonNullableFields, type context_QueryV2 as QueryV2, type context_Recurrence as Recurrence, type context_RestoreInfo as RestoreInfo, type context_SearchPlansRequest as SearchPlansRequest, type context_SearchPlansResponse as SearchPlansResponse, type context_SetPlanVisibilityRequest as SetPlanVisibilityRequest, type context_SetPlanVisibilityResponse as SetPlanVisibilityResponse, type context_SetPlanVisibilityResponseNonNullableFields as SetPlanVisibilityResponseNonNullableFields, context_SortOrder as SortOrder, type context_Sorting as Sorting, type context_StringList as StringList, type context_UpdatePlan as UpdatePlan, type context_UpdatePlanRequest as UpdatePlanRequest, type context_UpdatePlanResponse as UpdatePlanResponse, type context_UpdatePlanResponseNonNullableFields as UpdatePlanResponseNonNullableFields, context_WebhookIdentityType as WebhookIdentityType, type context__publicOnPlanArchivedType as _publicOnPlanArchivedType, type context__publicOnPlanBuyerCanCancelUpdatedType as _publicOnPlanBuyerCanCancelUpdatedType, type context__publicOnPlanCreatedType as _publicOnPlanCreatedType, type context__publicOnPlanUpdatedType as _publicOnPlanUpdatedType, context_archivePlan as archivePlan, context_clearPrimary as clearPrimary, context_createPlan as createPlan, context_getPlan as getPlan, context_getPlanStats as getPlanStats, context_listPlans as listPlans, context_listPublicPlans as listPublicPlans, context_makePlanPrimary as makePlanPrimary, context_onPlanArchived as onPlanArchived, context_onPlanBuyerCanCancelUpdated as onPlanBuyerCanCancelUpdated, context_onPlanCreated as onPlanCreated, context_onPlanUpdated as onPlanUpdated, onPlanArchived$1 as publicOnPlanArchived, onPlanBuyerCanCancelUpdated$1 as publicOnPlanBuyerCanCancelUpdated, onPlanCreated$1 as publicOnPlanCreated, onPlanUpdated$1 as publicOnPlanUpdated, context_queryPublicPlans as queryPublicPlans, context_setPlanVisibility as setPlanVisibility, context_updatePlan as updatePlan };
}

export { context$1 as orders, context as plans };
