"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createClient = createClient;
const sdk_context_1 = require("@wix/sdk-context");
const sdk_types_1 = require("@wix/sdk-types");
const ambassador_modules_js_1 = require("./ambassador-modules.js");
const common_js_1 = require("./common.js");
const fetch_error_js_1 = require("./fetch-error.js");
const helpers_js_1 = require("./helpers.js");
const host_modules_js_1 = require("./host-modules.js");
const rest_modules_js_1 = require("./rest-modules.js");
const event_handlers_modules_js_1 = require("./event-handlers-modules.js");
const service_plugin_modules_js_1 = require("./service-plugin-modules.js");
const context_1 = require("@wix/sdk-runtime/context");
function createClient(config) {
    const _headers = config.headers || { Authorization: '' };
    const authStrategy = config.auth ||
        {
            getAuthHeaders: (_) => Promise.resolve({ headers: {} }),
        };
    const boundGetAuthHeaders = authStrategy.getAuthHeaders.bind(undefined, config.host);
    authStrategy.getAuthHeaders = boundGetAuthHeaders;
    const { client: servicePluginsClient, initModule: initServicePluginModule } = (0, service_plugin_modules_js_1.servicePluginsModules)(authStrategy);
    const { client: eventHandlersClient, initModule: initEventHandlerModule } = (0, event_handlers_modules_js_1.eventHandlersModules)(authStrategy);
    const boundFetch = async (url, options) => {
        const authHeaders = await boundGetAuthHeaders();
        const defaultContentTypeHeader = (0, helpers_js_1.getDefaultContentHeader)(options);
        return fetch(url, {
            ...options,
            headers: {
                ...defaultContentTypeHeader,
                ..._headers,
                ...authHeaders?.headers,
                ...options?.headers,
                ...config.host?.essentials?.passThroughHeaders,
            },
        });
    };
    // This is typed as `any` because when trying to properly type it as defined
    // on the WixClient, typescript starts failing with `Type instantiation is
    // excessively deep and possibly infinite.`
    const use = (modules, metadata) => {
        if ((0, event_handlers_modules_js_1.isEventHandlerModule)(modules)) {
            return initEventHandlerModule(modules);
        }
        else if ((0, service_plugin_modules_js_1.isServicePluginModule)(modules)) {
            return initServicePluginModule(modules);
        }
        else if ((0, host_modules_js_1.isHostModule)(modules) && config.host) {
            return (0, host_modules_js_1.buildHostModule)(modules, config.host);
        }
        else if (typeof modules === 'function') {
            // The generated namespaces all have the error classes on them and
            // a class is also a function, so we need to explicitly ignore these
            // error classes using a static field that exists on them.
            if ('__type' in modules && modules.__type === sdk_types_1.SERVICE_PLUGIN_ERROR_TYPE) {
                return modules;
            }
            const apiBaseUrl = config.host?.apiBaseUrl ?? common_js_1.DEFAULT_API_URL;
            return (0, rest_modules_js_1.buildRESTDescriptor)((0, context_1.runWithoutContext)(() => (0, ambassador_modules_js_1.isAmbassadorModule)(modules))
                ? (0, ambassador_modules_js_1.toHTTPModule)(modules)
                : modules, metadata ?? {}, boundFetch, (relativeUrl, fetchOptions) => {
                const finalUrl = new URL(relativeUrl, `https://${apiBaseUrl}`);
                finalUrl.host = apiBaseUrl;
                finalUrl.protocol = 'https';
                return boundFetch(finalUrl.toString(), fetchOptions);
            }, authStrategy.getActiveToken, { HTTPHost: apiBaseUrl }, config.host?.name);
        }
        else if ((0, helpers_js_1.isObject)(modules)) {
            return Object.fromEntries(Object.entries(modules).map(([key, value]) => {
                return [key, use(value, modules[common_js_1.PUBLIC_METADATA_KEY])];
            }));
        }
        else {
            return modules;
        }
    };
    const setHeaders = (headers) => {
        for (const k in headers) {
            _headers[k] = headers[k];
        }
    };
    const wrappedModules = config.modules
        ? use(config.modules)
        : {};
    return {
        ...wrappedModules,
        auth: authStrategy,
        setHeaders,
        use,
        enableContext(contextType, opts = { elevated: false }) {
            if (contextType === 'global') {
                if (globalThis.__wix_context__ != null) {
                    if (opts.elevated) {
                        globalThis.__wix_context__.elevatedClient = this;
                    }
                    else {
                        globalThis.__wix_context__.client = this;
                    }
                }
                else {
                    if (opts.elevated) {
                        globalThis.__wix_context__ = { elevatedClient: this };
                    }
                    else {
                        globalThis.__wix_context__ = { client: this };
                    }
                }
            }
            else {
                if (opts.elevated) {
                    sdk_context_1.wixContext.elevatedClient = this;
                }
                else {
                    sdk_context_1.wixContext.client = this;
                }
            }
        },
        /**
         * @param relativeUrl The URL to fetch relative to the API base URL
         * @param options The fetch options
         * @returns The fetch Response object
         * @deprecated Use `fetchWithAuth` instead
         */
        fetch: (relativeUrl, options) => {
            const apiBaseUrl = config.host?.apiBaseUrl ?? common_js_1.DEFAULT_API_URL;
            const finalUrl = new URL(relativeUrl, `https://${apiBaseUrl}`);
            finalUrl.host = apiBaseUrl;
            finalUrl.protocol = 'https';
            return boundFetch(finalUrl.toString(), options);
        },
        fetchWithAuth: async (urlOrRequest, requestInit) => {
            if (typeof urlOrRequest === 'string' || urlOrRequest instanceof URL) {
                return fetch(urlOrRequest, {
                    ...requestInit,
                    headers: {
                        ...requestInit?.headers,
                        ...(await boundGetAuthHeaders()).headers,
                    },
                });
            }
            else {
                for (const [k, v] of Object.entries((await boundGetAuthHeaders()).headers)) {
                    urlOrRequest.headers.set(k, v);
                }
                return fetch(urlOrRequest, requestInit);
            }
        },
        async graphql(query, variables, opts = {
            apiVersion: 'alpha',
        }) {
            const apiBaseUrl = config?.host?.apiBaseUrl ?? common_js_1.DEFAULT_API_URL;
            const res = await boundFetch(`https://${apiBaseUrl}/graphql/${opts.apiVersion}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ query, variables }),
            });
            if (res.status !== 200) {
                throw new fetch_error_js_1.FetchErrorResponse(`GraphQL request failed with status ${res.status}`, res);
            }
            const { data, errors } = await res.json();
            return { data: data ?? {}, errors };
        },
        webhooks: eventHandlersClient,
        servicePlugins: servicePluginsClient,
    };
}
