"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEventHandlerModule = void 0;
exports.buildEventDefinition = buildEventDefinition;
exports.eventHandlersModules = eventHandlersModules;
const sdk_types_1 = require("@wix/sdk-types");
const nanoevents_js_1 = require("./nanoevents.js");
const isEventHandlerModule = (val) => val.__type === 'event-definition';
exports.isEventHandlerModule = isEventHandlerModule;
function buildEventDefinition(eventDefinition, registerHandler) {
    return (handler) => {
        registerHandler(eventDefinition, handler);
    };
}
function runHandler(eventDefinition, handler, payload, baseEventMetadata) {
    let envelope;
    if (eventDefinition.isDomainEvent) {
        const domainEventPayload = payload;
        const { deletedEvent, actionEvent, createdEvent, updatedEvent, ...domainEventMetadata } = domainEventPayload;
        const metadata = {
            ...baseEventMetadata,
            ...domainEventMetadata,
        };
        if (deletedEvent) {
            if (deletedEvent?.deletedEntity) {
                envelope = {
                    entity: deletedEvent?.deletedEntity,
                    metadata,
                };
            }
            else {
                envelope = { metadata };
            }
        }
        else if (actionEvent) {
            envelope = {
                data: actionEvent.body,
                metadata,
            };
        }
        else {
            envelope = {
                entity: createdEvent?.entity ?? updatedEvent?.currentEntity,
                metadata,
            };
        }
    }
    else {
        envelope = {
            data: payload,
            metadata: baseEventMetadata,
        };
    }
    const transformFromRESTFn = eventDefinition.transformations ?? ((x) => x);
    return handler(transformFromRESTFn(envelope));
}
function eventHandlersModules(authStrategy) {
    const eventHandlers = new Map();
    const webhooksEmitter = (0, nanoevents_js_1.createNanoEvents)();
    const client = {
        ...webhooksEmitter,
        getRegisteredEvents: () => eventHandlers,
        async process(jwt, opts = {
            expectedEvents: [],
        }) {
            const { eventType, identity, instanceId, payload } = await this.parseJWT(jwt);
            const allExpectedEvents = [
                ...opts.expectedEvents,
                ...Array.from(eventHandlers.keys()).map((type) => ({ type })),
            ];
            if (allExpectedEvents.length > 0 &&
                !allExpectedEvents.some(({ type }) => type === eventType)) {
                throw new Error(`Unexpected event type: ${eventType}. Expected one of: ${allExpectedEvents
                    .map((x) => x.type)
                    .join(', ')}`);
            }
            const handlers = eventHandlers.get(eventType) ?? [];
            await Promise.all(handlers.map(({ eventDefinition, handler }) => runHandler(eventDefinition, handler, payload, {
                instanceId,
                identity,
            })));
            return {
                instanceId,
                eventType,
                payload,
                identity,
            };
        },
        async processRequest(request, opts) {
            const body = await request.text();
            return this.process(body, opts);
        },
        async parseJWT(jwt) {
            if (!authStrategy.decodeJWT) {
                throw new Error('decodeJWT is not supported by the authentication strategy');
            }
            const { decoded, valid } = await authStrategy.decodeJWT(jwt);
            if (!valid) {
                throw new Error('JWT is not valid');
            }
            if (typeof decoded.data !== 'string') {
                throw new Error(`Unexpected type of JWT data: expected string, got ${typeof decoded.data}`);
            }
            const parsedDecoded = JSON.parse(decoded.data);
            const eventType = parsedDecoded.eventType;
            const instanceId = parsedDecoded.instanceId;
            const identity = parsedDecoded.identity
                ? JSON.parse(parsedDecoded.identity)
                : undefined;
            const payload = JSON.parse(parsedDecoded.data);
            return {
                instanceId,
                eventType,
                payload,
                identity,
            };
        },
        async parseRequest(request) {
            const jwt = await request.text();
            return this.parseJWT(jwt);
        },
        async executeHandlers(event) {
            const allExpectedEvents = Array.from(eventHandlers.keys()).map((type) => ({ type }));
            if (allExpectedEvents.length > 0 &&
                !allExpectedEvents.some(({ type }) => type === event.eventType)) {
                throw new Error(`Unexpected event type: ${event.eventType}. Expected one of: ${allExpectedEvents
                    .map((x) => x.type)
                    .join(', ')}`);
            }
            const handlers = eventHandlers.get(event.eventType) ?? [];
            await Promise.all(handlers.map(({ eventDefinition, handler }) => runHandler(eventDefinition, handler, event.payload, {
                instanceId: event.instanceId,
                identity: event.identity,
            })));
        },
        apps: {
            AppInstalled: (0, sdk_types_1.EventDefinition)('AppInstalled')(),
            AppRemoved: (0, sdk_types_1.EventDefinition)('AppRemoved')(),
        },
    };
    return {
        initModule(eventDefinition) {
            return (handler) => {
                const handlers = eventHandlers.get(eventDefinition.type) ?? [];
                handlers.push({ eventDefinition, handler });
                eventHandlers.set(eventDefinition.type, handlers);
                webhooksEmitter.emit('registered', eventDefinition);
            };
        },
        client,
    };
}
