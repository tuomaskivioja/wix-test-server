import { authentication } from '@wix/identity';
import { AuthenticationStrategy } from '@wix/sdk-types';
export interface Tokens {
    accessToken: AccessToken;
    refreshToken: RefreshToken;
}
export interface Token {
    value: string;
}
export interface AccessToken extends Token {
    expiresAt: number;
}
export interface RefreshToken extends Token {
    role: TokenRole;
}
export interface OauthData extends OauthPKCE {
    originalUri: string;
    redirectUri: string;
}
export interface OauthPKCE {
    codeVerifier: string;
    codeChallenge: string;
    state: string;
}
export interface RegisterParams extends LoginParams {
    profile?: authentication.IdentityProfile;
}
export interface LoginParams {
    email: string;
    password: string;
    captchaTokens?: {
        invisibleRecaptchaToken?: string;
        recaptchaToken?: string;
    };
}
export interface IOAuthStrategy extends AuthenticationStrategy {
    generateVisitorTokens(tokens?: {
        refreshToken?: RefreshToken;
        accessToken?: AccessToken;
    }): Promise<Tokens>;
    renewToken: (refreshToken: RefreshToken) => Promise<Tokens>;
    setTokens: (tokens: Tokens) => void;
    getTokens: () => Tokens;
    generateOAuthData: (redirectUri: string, originalUri?: string) => OauthData;
    getAuthUrl: (oauthData: OauthData, opts?: {
        prompt?: 'login' | 'none';
        responseMode?: 'fragment' | 'web_message' | 'query';
    }) => Promise<{
        authUrl: string;
    }>;
    getMemberTokens: (code: string, state: string, oauthData: OauthData) => Promise<Tokens>;
    logout: (originalUrl: string) => Promise<{
        logoutUrl: string;
    }>;
    parseFromUrl: (url?: string, responseMode?: 'query' | 'fragment') => {
        code: string;
        state: string;
        error?: string;
        errorDescription?: string;
    };
    register: (params: RegisterParams) => Promise<StateMachine>;
    login: (params: LoginParams) => Promise<StateMachine>;
    processVerification<T extends ProcessableState>(nextInputs: CalculateNextState<T>, state?: StateMachine): Promise<StateMachine>;
    getMemberTokensForDirectLogin: (sessionToken: string) => Promise<Tokens>;
    sendPasswordResetEmail: (email: string, redirectUri: string) => Promise<void>;
    captchaInvisibleSiteKey: string;
    captchaVisibleSiteKey: string;
    loggedIn: () => boolean;
    /**
     * Retrieves and authenticates site member's access and refresh tokens given a member ID.
     * A member ID for external login can be retrieved from the Wix Members API using `queryMembers`
     * function, using any externally identifiable field (e.g. email, phone number, etc.).
     *
     * In addition to the member ID, an API Key with permissions on Wix Contacts & Members is required
     * (this is an administrative API that bypasses the need for a session token and so can only be used
     * from confidential clients).
     * @param memberId The member ID to get the tokens for
     * @param apiKey An API Key with permissions on Wix Contacts & Members
     * @returns Tokens (access and refresh) for the member
     */
    getMemberTokensForExternalLogin: (memberId: string, apiKey: string) => Promise<Tokens>;
}
export declare enum LoginState {
    SUCCESS = "SUCCESS",
    INITIAL = "INITIAL",
    FAILURE = "FAILURE",
    EMAIL_VERIFICATION_REQUIRED = "EMAIL_VERIFICATION_REQUIRED",
    OWNER_APPROVAL_REQUIRED = "OWNER_APPROVAL_REQUIRED",
    USER_CAPTCHA_REQUIRED = "USER_CAPTCHA_REQUIRED",
    SILENT_CAPTCHA_REQUIRED = "SILENT_CAPTCHA_REQUIRED"
}
interface LoginResults<LK extends LoginState> {
    loginState: LK;
}
interface SuccessState extends LoginResults<LoginState.SUCCESS> {
    data: {
        sessionToken: string;
    };
}
interface InitialState extends LoginResults<LoginState.INITIAL> {
}
interface ErrorState extends LoginResults<LoginState.FAILURE> {
    errorCode?: 'invalidEmail' | 'invalidPassword' | 'resetPassword' | 'missingCaptchaToken' | 'emailAlreadyExists' | 'invalidCaptchaToken';
    error: string;
}
interface EmailVerificationRequiredState extends LoginResults<LoginState.EMAIL_VERIFICATION_REQUIRED> {
    data: {
        stateToken: string;
    };
}
interface OwnerApprovalRequiredState extends LoginResults<LoginState.OWNER_APPROVAL_REQUIRED> {
}
interface SilentCaptchaRequiredState extends LoginResults<LoginState.SILENT_CAPTCHA_REQUIRED> {
    data: {
        stateToken: string;
    };
}
interface UserCaptchaRequiredState extends LoginResults<LoginState.USER_CAPTCHA_REQUIRED> {
    data: {
        stateToken: string;
    };
}
export declare enum TokenRole {
    NONE = "none",
    VISITOR = "visitor",
    MEMBER = "member"
}
export type StateMachine = InitialState | SuccessState | ErrorState | EmailVerificationRequiredState | OwnerApprovalRequiredState | SilentCaptchaRequiredState | UserCaptchaRequiredState;
type VerificationCode = {
    verificationCode: string;
};
export type CalculateNextState<T> = T extends EmailVerificationRequiredState ? VerificationCode : never;
export type ProcessableState = EmailVerificationRequiredState;
export {};
