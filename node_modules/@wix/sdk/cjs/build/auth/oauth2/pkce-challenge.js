"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pkceChallenge = pkceChallenge;
exports.generateChallenge = generateChallenge;
const sha256_js_1 = require("./sha256.js");
function pkceChallenge(length) {
    if (!length) {
        length = 43;
    }
    if (length < 43 || length > 128) {
        throw new Error(`Expected a length between 43 and 128. Received ${length}.`);
    }
    const verifier = generateVerifier(length);
    const challenge = generateChallenge(verifier);
    return {
        code_verifier: verifier,
        code_challenge: challenge,
    };
}
function generateVerifier(length) {
    return random(length);
}
function generateChallenge(code_verifier) {
    return base64urlencode((0, sha256_js_1.sha256)(code_verifier));
}
function random(size) {
    const mask = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~';
    let result = '';
    const randomUints = crypto.getRandomValues(new Uint8Array(size));
    for (let i = 0; i < size; i++) {
        // cap the value of the randomIndex to mask.length - 1
        const randomIndex = randomUints[i] % mask.length;
        result += mask[randomIndex];
    }
    return result;
}
function base64urlencode(str) {
    const base64 = typeof Buffer === 'undefined'
        ? btoa(ab2str(str))
        : Buffer.from(str).toString('base64');
    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}
function ab2str(buf) {
    return String.fromCharCode.apply(null, Array.from(new Uint8Array(buf)));
}
