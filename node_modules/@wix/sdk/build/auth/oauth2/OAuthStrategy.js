import { createClient } from '../../wixClient.js';
import { redirects } from '@wix/redirects';
import { createAccessToken, isTokenExpired } from '../../tokenHelpers.js';
import { authentication, recovery, verification } from '@wix/identity';
import { DEFAULT_API_URL } from '../../common.js';
import { LoginState, TokenRole, } from './types.js';
import { addPostMessageListener, loadFrame } from '../../iframeUtils.js';
import { EMAIL_EXISTS, INVALID_CAPTCHA, INVALID_PASSWORD, MISSING_CAPTCHA, RESET_PASSWORD, } from './constants.js';
import { biHeaderGenerator } from '../../bi/biHeaderGenerator.js';
import { pkceChallenge } from './pkce-challenge.js';
const moduleWithTokens = { redirects, authentication, recovery, verification };
export function OAuthStrategy(config) {
    const _tokens = config.tokens || {
        accessToken: { value: '', expiresAt: 0 },
        refreshToken: { value: '', role: TokenRole.NONE },
    };
    const setTokens = (tokens) => {
        _tokens.accessToken = tokens.accessToken;
        _tokens.refreshToken = tokens.refreshToken;
    };
    let _state = {
        loginState: LoginState.INITIAL,
    };
    const getAuthHeaders = async () => {
        if (!_tokens.accessToken?.value || isTokenExpired(_tokens.accessToken)) {
            const tokens = await generateVisitorTokens({
                refreshToken: _tokens.refreshToken,
            });
            setTokens(tokens);
        }
        return Promise.resolve({
            headers: { Authorization: _tokens.accessToken.value },
        });
    };
    const wixClientWithTokens = createClient({
        modules: moduleWithTokens,
        auth: { getAuthHeaders },
    });
    const generateVisitorTokens = async (tokens) => {
        if (tokens?.accessToken?.value &&
            tokens?.refreshToken?.value &&
            !isTokenExpired(tokens.accessToken)) {
            return tokens;
        }
        if (tokens?.refreshToken?.value) {
            try {
                const newTokens = await renewToken(tokens.refreshToken);
                return newTokens;
            }
            catch (e) {
                // just continue and create a visitor one
            }
        }
        const tokensResponse = await fetchTokens({
            clientId: config.clientId,
            grantType: 'anonymous',
        });
        return {
            accessToken: createAccessToken(tokensResponse.access_token, tokensResponse.expires_in),
            refreshToken: {
                value: tokensResponse.refresh_token,
                role: TokenRole.VISITOR,
            },
        };
    };
    const renewToken = async (refreshToken) => {
        const tokensResponse = await fetchTokens({
            refreshToken: refreshToken.value,
            grantType: 'refresh_token',
        });
        const accessToken = createAccessToken(tokensResponse.access_token, tokensResponse.expires_in);
        return {
            accessToken,
            refreshToken,
        };
    };
    const generatePKCE = () => {
        const pkceState = pkceChallenge();
        return {
            codeChallenge: pkceState.code_challenge,
            codeVerifier: pkceState.code_verifier,
            state: pkceChallenge().code_challenge,
        };
    };
    const generateOAuthData = (redirectUri, originalUri) => {
        const state = { redirectUri };
        const pkceState = generatePKCE();
        return {
            ...state,
            originalUri: originalUri ?? '',
            codeChallenge: pkceState.codeChallenge,
            codeVerifier: pkceState.codeVerifier,
            state: pkceChallenge().code_challenge,
        };
    };
    const getAuthorizationUrlWithOptions = async (oauthData, responseMode, prompt, sessionToken) => {
        const { redirectSession } = await wixClientWithTokens.redirects.createRedirectSession({
            auth: {
                authRequest: {
                    redirectUri: oauthData.redirectUri,
                    ...(oauthData.redirectUri && {
                        redirectUri: oauthData.redirectUri,
                    }),
                    clientId: config.clientId,
                    codeChallenge: oauthData.codeChallenge,
                    codeChallengeMethod: 'S256',
                    responseMode,
                    responseType: 'code',
                    scope: 'offline_access',
                    state: oauthData.state,
                    ...(sessionToken && { sessionToken }),
                },
                prompt: redirects.Prompt[prompt],
            },
        });
        return {
            authUrl: redirectSession.fullUrl,
            authorizationEndpoint: redirectSession.urlDetails.endpoint,
            sessionToken: redirectSession.sessionToken,
        };
    };
    const getAuthUrl = async (oauthData = generateOAuthData('unused://'), opts = {
        prompt: 'login',
    }) => {
        return getAuthorizationUrlWithOptions(oauthData, opts.responseMode ?? 'fragment', opts.prompt ?? 'login', opts.sessionToken);
    };
    const parseFromUrl = (url, responseMode = 'fragment') => {
        const parsedUrl = new URL(url ?? window.location.href);
        const params = responseMode === 'query'
            ? parsedUrl.searchParams
            : new URLSearchParams(parsedUrl.hash.substring(1));
        const code = params.get('code');
        const state = params.get('state');
        const error = params.get('error');
        const errorDescription = params.get('error_description');
        return { code, state, ...(error && { error, errorDescription }) };
    };
    const getMemberTokens = async (code, state, oauthData) => {
        if (!code || !state) {
            throw new Error('Missing code or _state');
        }
        else if (state !== oauthData.state) {
            throw new Error('Invalid _state');
        }
        try {
            const tokensResponse = await fetchTokens({
                clientId: config.clientId,
                grantType: 'authorization_code',
                ...(oauthData.redirectUri && { redirectUri: oauthData.redirectUri }),
                code,
                codeVerifier: oauthData.codeVerifier,
            });
            return {
                accessToken: createAccessToken(tokensResponse.access_token, tokensResponse.expires_in),
                refreshToken: {
                    value: tokensResponse.refresh_token,
                    role: TokenRole.MEMBER,
                },
            };
        }
        catch (e) {
            throw new Error('Failed to get member tokens');
        }
    };
    const logout = async (originalUrl) => {
        const { redirectSession } = await wixClientWithTokens.redirects.createRedirectSession({
            logout: { clientId: config.clientId },
            callbacks: {
                postFlowUrl: originalUrl,
            },
        });
        _tokens.accessToken = { value: '', expiresAt: 0 };
        _tokens.refreshToken = { value: '', role: TokenRole.NONE };
        return { logoutUrl: redirectSession.fullUrl };
    };
    const handleState = (response) => {
        if (response.state === authentication.StateType.SUCCESS) {
            return {
                loginState: LoginState.SUCCESS,
                data: { sessionToken: response.sessionToken },
            };
        }
        else if (response.state === authentication.StateType.REQUIRE_OWNER_APPROVAL) {
            return {
                loginState: LoginState.OWNER_APPROVAL_REQUIRED,
            };
        }
        else if (response.state === authentication.StateType.REQUIRE_EMAIL_VERIFICATION) {
            _state = {
                loginState: LoginState.EMAIL_VERIFICATION_REQUIRED,
                data: { stateToken: response.stateToken },
            };
            return _state;
        }
        return {
            loginState: LoginState.FAILURE,
            error: 'Unknown _state',
        };
    };
    const register = async (params) => {
        try {
            const res = await wixClientWithTokens.authentication.registerV2({
                email: params.email,
            }, {
                password: params.password,
                profile: params.profile,
                ...(params.captchaTokens && {
                    captchaTokens: [
                        {
                            Recaptcha: params.captchaTokens?.recaptchaToken,
                            InvisibleRecaptcha: params.captchaTokens?.invisibleRecaptchaToken,
                        },
                    ],
                }),
            });
            return handleState(res);
        }
        catch (e) {
            const emailValidation = e.details.validationError?.fieldViolations?.find((v) => v.data.type === 'EMAIL');
            if (emailValidation) {
                return {
                    loginState: LoginState.FAILURE,
                    error: emailValidation.description,
                    errorCode: 'invalidEmail',
                };
            }
            if (e.details.applicationError?.code === MISSING_CAPTCHA) {
                return {
                    loginState: LoginState.FAILURE,
                    error: e.message,
                    errorCode: 'missingCaptchaToken',
                };
            }
            if (e.details.applicationError?.code === EMAIL_EXISTS) {
                return {
                    loginState: LoginState.FAILURE,
                    error: e.message,
                    errorCode: 'emailAlreadyExists',
                };
            }
            if (e.details.applicationError?.code === INVALID_CAPTCHA) {
                return {
                    loginState: LoginState.FAILURE,
                    error: e.message,
                    errorCode: 'invalidCaptchaToken',
                };
            }
            return {
                loginState: LoginState.FAILURE,
                error: e.message,
            };
        }
    };
    const login = async (params) => {
        try {
            const res = await wixClientWithTokens.authentication.loginV2({
                email: params.email,
            }, {
                password: params.password,
                ...(params.captchaTokens && {
                    captchaTokens: [
                        {
                            Recaptcha: params.captchaTokens?.recaptchaToken,
                            InvisibleRecaptcha: params.captchaTokens?.invisibleRecaptchaToken,
                        },
                    ],
                }),
            });
            return handleState(res);
        }
        catch (e) {
            return {
                loginState: LoginState.FAILURE,
                error: e.message,
                errorCode: e.details.applicationError?.code === MISSING_CAPTCHA
                    ? 'missingCaptchaToken'
                    : e.details.applicationError?.code === INVALID_CAPTCHA
                        ? 'invalidCaptchaToken'
                        : e.details.applicationError.code === INVALID_PASSWORD
                            ? 'invalidPassword'
                            : e.details.applicationError.code === RESET_PASSWORD
                                ? 'resetPassword'
                                : 'invalidEmail',
            };
        }
    };
    const processVerification = async (nextInputs, state) => {
        const stateToUse = state ?? _state;
        if (stateToUse.loginState === LoginState.EMAIL_VERIFICATION_REQUIRED) {
            const code = nextInputs.verificationCode ?? nextInputs.code;
            const res = await wixClientWithTokens.verification.verifyDuringAuthentication(code, { stateToken: stateToUse.data.stateToken });
            return handleState(res);
        }
        return {
            loginState: LoginState.FAILURE,
            error: 'Unknown _state',
        };
    };
    const getMemberTokensForDirectLogin = async (sessionToken) => {
        const oauthPKCE = generatePKCE();
        const { authUrl } = await getAuthorizationUrlWithOptions(oauthPKCE, 'web_message', 'none', sessionToken);
        const iframePromise = addPostMessageListener(oauthPKCE.state);
        const iframeEl = loadFrame(authUrl);
        return iframePromise
            .then((res) => {
            return getMemberTokens(res.code, res.state, oauthPKCE);
        })
            .finally(() => {
            if (document.body.contains(iframeEl)) {
                iframeEl.parentElement?.removeChild(iframeEl);
            }
        });
    };
    const sendPasswordResetEmail = async (email, redirectUri) => {
        await wixClientWithTokens.recovery.sendRecoveryEmail(email, {
            redirect: { url: redirectUri, clientId: config.clientId },
        });
    };
    const loggedIn = () => {
        return _tokens.refreshToken.role === TokenRole.MEMBER;
    };
    const getMemberTokensForExternalLogin = async (memberId, apiKey) => {
        const tokensResponse = await fetchTokens({
            grant_type: 'authorized_client',
            scope: 'offline_access',
            member_id: memberId,
        }, {
            Authorization: _tokens.accessToken.value + ',' + apiKey,
        });
        return {
            accessToken: createAccessToken(tokensResponse.access_token, tokensResponse.expires_in),
            refreshToken: {
                value: tokensResponse.refresh_token,
                role: TokenRole.MEMBER,
            },
        };
    };
    return {
        generateVisitorTokens,
        renewToken,
        parseFromUrl,
        getAuthUrl,
        getMemberTokens,
        generateOAuthData,
        getAuthHeaders,
        setTokens,
        getTokens: () => _tokens,
        loggedIn,
        logout,
        register,
        processVerification,
        login,
        getMemberTokensForDirectLogin,
        getMemberTokensForExternalLogin,
        sendPasswordResetEmail,
        captchaInvisibleSiteKey: '6LdoPaUfAAAAAJphvHoUoOob7mx0KDlXyXlgrx5v',
        captchaVisibleSiteKey: '6Ld0J8IcAAAAANyrnxzrRlX1xrrdXsOmsepUYosy',
    };
}
const fetchTokens = async (payload, headers = {}) => {
    const res = await fetch(`https://${DEFAULT_API_URL}/oauth2/token`, {
        method: 'POST',
        body: JSON.stringify(payload),
        headers: {
            ...biHeaderGenerator({
                entityFqdn: 'wix.identity.oauth.v1.refresh_token',
                methodFqn: 'wix.identity.oauth2.v1.Oauth2Ng.Token',
                packageName: '@wix/sdk',
            }),
            'Content-Type': 'application/json',
            ...headers,
        },
    });
    if (res.status !== 200) {
        throw new Error('something went wrong');
    }
    const json = await res.json();
    return json;
};
