import { CursorBasedIterator } from './CursorBasedIterator';
import { OffsetBasedIterator } from './OffsetBasedIterator';
import { PlatformizedQueryBuilder } from './PlatformizedQueryBuilder';
import { constants } from '@wix/motion-edm-autogen-common';
import { preset } from '@wix/motion-edm-autogen-transformations-core';
const { ITEMS_RESULT_PROPERTY_NAME, PAGING_METADATA_RESULT_PROPERTY_NAME } = preset.query;
const { PagingMethods } = constants;
const DEFAULT_LIMIT = 50;
class PlatformizedQueryMethodWrapper extends PlatformizedQueryBuilder {
    constructor(obj) {
        super(obj);
        // Private variables cannot be prefixed with '_' here.
        // That's because the filterMixin used by PlatformizedQueryBuilder copies its properties from "this"
        // and passes them to the new instance ctor, that expects names without the '_' prefix.
        // Changing this breaks the chaining capability.
        this.func = obj.func;
        this.requestTransformer = obj.requestTransformer;
        this.responseTransformer = obj.responseTransformer;
        this.errorTransformer = obj.errorTransformer;
        this.pagingMethod = obj.pagingMethod;
        this.cursor = obj.cursor;
        this.builderOptions = obj.builderOptions;
    }
    async find(options = {}) {
        try {
            const query = this._buildQuery();
            const request = this.requestTransformer(query, options);
            const response = await this.func(request, {
                ...options,
                ...this.builderOptions,
            });
            const { [ITEMS_RESULT_PROPERTY_NAME]: items, [PAGING_METADATA_RESULT_PROPERTY_NAME]: pagingMetadata, } = this.responseTransformer(response);
            if (this.pagingMethod === PagingMethods.Offset) {
                return new OffsetBasedIterator({
                    items,
                    fetchNextPage: () => this._copyWithNextPage().find(options),
                    fetchPrevPage: () => this._copyWithPrevPage().find(options),
                    offset: this._pagingOffset,
                    limit: this._pagingLimit,
                    totalCount: pagingMetadata?.total,
                    tooManyToCount: pagingMetadata?.tooManyToCount,
                    originQuery: this,
                });
            }
            return new CursorBasedIterator({
                items,
                limit: this._pagingLimit,
                originQuery: this,
                fetchNextPage: () => this._copyWithCursor(pagingMetadata?.cursors?.next ?? '').find(options),
                fetchPrevPage: () => this._copyWithCursor(pagingMetadata?.cursors?.prev ?? '').find(options),
                prevCursor: pagingMetadata?.cursors?.prev ?? '',
                nextCursor: pagingMetadata?.cursors?.next ?? '',
            });
        }
        catch (error) {
            return this.errorTransformer(error);
        }
    }
    skipTo(cursor) {
        return this._copyWithCursor(cursor);
    }
    _copyWithCursor(cursor) {
        return new PlatformizedQueryMethodWrapper({ ...this, cursor });
    }
    _buildQuery() {
        const queryObject = this.build();
        if (this.pagingMethod === PagingMethods.Cursor) {
            if (this.builderOptions?.cursorWithEmptyFilterAndSort && this.cursor) {
                return {
                    cursorPaging: { cursor: this.cursor, limit: this._pagingLimit },
                };
            }
            return {
                filter: queryObject.filter,
                sort: this.sort,
                cursorPaging: { cursor: this.cursor, limit: this._pagingLimit },
            };
        }
        return {
            filter: queryObject.filter,
            sort: this.sort,
            paging: { limit: this._pagingLimit, offset: this._pagingOffset },
        };
    }
    get _pagingOffset() {
        return this.paging.offset || 0;
    }
    get _pagingLimit() {
        return this.paging.limit === undefined ? DEFAULT_LIMIT : this.paging.limit;
    }
    _copyWithOffsetChange(amount) {
        const nextPage = {
            offset: this._pagingOffset + amount,
            limit: this._pagingLimit,
        };
        return new PlatformizedQueryMethodWrapper({ ...this, paging: nextPage });
    }
    _copyWithNextPage() {
        return this._copyWithOffsetChange(this._pagingLimit);
    }
    _copyWithPrevPage() {
        return this._copyWithOffsetChange(-this._pagingLimit);
    }
}
const wrapWithQueryBuilder = ({ func, requestTransformer, responseTransformer, errorTransformer, pagingMethod, transformationPaths, cursor = undefined, }) => (builderOptions = {}) => new PlatformizedQueryMethodWrapper({
    func,
    builderOptions,
    requestTransformer,
    responseTransformer,
    errorTransformer,
    pagingMethod,
    transformationPaths,
    cursor,
});
export { wrapWithQueryBuilder, PlatformizedQueryMethodWrapper };
//# sourceMappingURL=wrapWithQueryBuilder.js.map