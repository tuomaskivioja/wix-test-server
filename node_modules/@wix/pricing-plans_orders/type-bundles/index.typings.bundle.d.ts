/**
 * An order object includes all of the details related to the purchase of a Pricing Plan.
 * You can manage existing orders, create offline orders, and preview orders not yet purchased.
 *
 * Orders are based on pricing models based on the payment and duration cycles for each plan. See here to
 * [learn more about pricing models](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/introduction#wix-pricing-plans_pricing-plans_introduction_pricing-models).
 */
interface Order {
    /**
     * Order ID.
     * @readonly
     */
    _id?: string;
    /**
     * ID of the plan purchased with the order.
     * @readonly
     */
    planId?: string;
    /**
     * ID of the related Wix subscription.
     *
     * Every pricing plan order corresponds to a Wix subscription, including orders for single payment plans. See a [Pricing Plans overview](https://support.wix.com/en/article/pricing-plans-an-overview#create-plans-to-suit-your-business).
     * @readonly
     */
    subscriptionId?: string;
    /**
     * Wix Pay order ID.
     *
     * Provided by Wix whether the order is created online or offline. The field is omitted when the order is free.
     * @readonly
     */
    wixPayOrderId?: string | null;
    /**
     * The buyer's IDs. Includes `memberId` and `contactId`.
     *
     * Currently, Pricing Plan purchases are limited to members only. `contactId` is returned,
     * but a buyer will not be able to purchase a plan without a `memberId`.
     * @readonly
     */
    buyer?: Buyer;
    /**
     * @internal
     * @internal
     * @readonly
     * @deprecated __Deprecated.__ Use `pricing` instead. This property will be removed on September 30, 2022.
     * @replacedBy pricing
     * @targetRemovalDate 2022-10-01
     */
    priceDetails?: PriceDetails;
    /**
     * Pricing model, price, and payment schedule for the order.
     * @readonly
     */
    pricing?: PricingDetails;
    /**
     * How the order was processed. Supported values:
     * + `"ONLINE"`: The buyer purchased the plan using the site.
     * + `"OFFLINE"`: The buyer made a manual, offline purchase without using the site.
     * @readonly
     */
    type?: OrderType;
    /**
     * Status of the order. Supported values:
     * + `DRAFT`: Order has been initiated but payment hasn't been processed yet. The plan isn't yet available for use to the buyer.
     * + `PENDING`: Order has been purchased and its start date is set in the future.
     * + `ACTIVE`: Order has been processed. The plan is available for use.
     * + `PAUSED`: Order, and use of the plan, is [paused](#pauseorder). The order, and use of the plan, can be [resumed](#resumeorder).
     * + `ENDED`: Order has completed its duration and is no longer available for use.
     * + `CANCELED`: Order has been [canceled](#cancelorder).
     * @readonly
     */
    status?: OrderStatus;
    /**
     * Whether the order will be canceled at the next payment date.
     *
     * If `true`, the order status will be `CANCELED` and the next payment won't be charged. Omitted for single payment orders.
     * @readonly
     */
    autoRenewCanceled?: boolean | null;
    /**
     * Details about the cancellation of an order.
     *
     *
     * @readonly
     */
    cancellation?: Cancellation;
    /**
     * Status of the last payment for the order.
     * Updated automatically for online orders. Updated manually by the site owner for offline orders.
     *
     * Supported values:
     * + `PAID`: The last payment was paid.
     * + `REFUNDED`: The last payment was refunded.
     * + `FAILED`: The last payment transaction didn't complete.
     * + `UNPAID`: The last payment wasn't paid.
     * + `PENDING`: Awaiting payment.
     * + `NOT_APPLICABLE`: No payment was necessary. For example, for free plans or free trials.
     * @readonly
     */
    lastPaymentStatus?: PaymentStatus;
    /**
     * Start date and time for the ordered plan.
     * @readonly
     */
    startDate?: Date;
    /**
     * Current end date and time for the ordered plan.
     *
     * `endDate` may be updated over the course of an order. If the order is [paused](#pauseorder),
     * it will have a later `endDate` once it [resumes](#resumeorder). `endDate` may also be [postponed](#postponeenddate).
     *
     * Omitted if the order is valid until canceled and still `ACTIVE`.
     * @readonly
     */
    endDate?: Date;
    /**
     * List of periods during which the order is paused.
     * @readonly
     */
    pausePeriods?: PausePeriod[];
    /**
     * Free trial period for the order, in days.
     *
     * Only available for recurring plans.
     * @readonly
     */
    freeTrialDays?: number | null;
    /**
     * Earliest end date and time that the plan for the order can expire.
     *
     * Calculated by using the original end date plus any pause periods. Omitted if the order is active until canceled. Reserved for future use.
     * @readonly
     */
    earliestEndDate?: Date;
    /**
     * Current payment cycle for the order.
     *
     * `currentCycle` will be omitted if the order's status is `CANCELED` or `ENDED`, or if the `startDate` hasn't passed yet.
     * @readonly
     */
    currentCycle?: CurrentCycle;
    /**
     * Plan name at the time of purchase.
     * @readonly
     */
    planName?: string;
    /**
     * Plan description at the time of purchase
     * @readonly
     */
    planDescription?: string;
    /**
     * Plan price as it was at the moment of order creation.
     * @readonly
     */
    planPrice?: string;
    /**
     * Date and time the order was created.
     * @readonly
     */
    _createdDate?: Date;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    _updatedDate?: Date;
    /**
     * Information about the form submitted during the plan's checkout.
     * @readonly
     */
    formData?: FormData;
}
interface Buyer {
    /**
     * Member ID for a buyer.
     * @readonly
     */
    memberId?: string;
    /**
     * Contact ID for a buyer.
     * @readonly
     */
    contactId?: string;
}
interface PriceDetails extends PriceDetailsPricingModelOneOf {
    /** Order has recurring payments. */
    subscription?: Recurrence;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
    /** Price of the order excluding tax, specified as a monetary amount. for example, `"9.99"`. */
    subtotal?: string;
    /** Total discount applied. */
    discount?: string;
    /** Tax applied. */
    tax?: Tax;
    /**
     * Price after tax and discount is applied, specified as a monetary amount. For example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     */
    total?: string;
    /** Plan price as it was at the moment of order creation. */
    planPrice?: string;
    /** Currency code. Must be valid ISO 4217 currency code (e.g., USD). */
    currency?: string;
    /** Free trial period for the order in days. Only available for recurring plans. */
    freeTrialDays?: number | null;
    /** Coupon applied to the order. Empty means no coupon was applied. */
    coupon?: Coupon;
}
/** @oneof */
interface PriceDetailsPricingModelOneOf {
    /** Order has recurring payments. */
    subscription?: Recurrence;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
}
interface Tax {
    /** Name of the tax. For example, VAT. */
    name?: string;
    /** Whether tax is included in the original price. When `false`, tax is added at checkout. */
    includedInPrice?: boolean;
    /** Tax rate percentage, as a number between 0 and 100. For example, a 7% tax rate is `"7.00"`. */
    rate?: string;
    /** Total tax, specified as a monetary amount. For example, `"3.99"`. */
    amount?: string;
}
/** An object specifying how often and for how long payments recur (may be forever). */
interface Recurrence {
    /** Length of one payment cycle. */
    cycleDuration?: Duration;
    /**
     * Amount of payment cycles this subscription is valid for.
     *
     * `0` for unlimited or until-canceled.
     */
    cycleCount?: number | null;
}
/** A duration expressed in number of time units. */
interface Duration {
    /** The amount of a duration `unit` in a single payment cycle. */
    count?: number | null;
    /** Unit of time for the cycle duration. */
    unit?: PeriodUnit;
}
declare enum PeriodUnit {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface Coupon {
    /** Code of the applied coupon. */
    code?: string;
    /** Total discount of the coupon, as a monetary amount. */
    amount?: string;
    /**
     * Coupon ID.
     * @readonly
     */
    _id?: string;
}
interface PricingDetails extends PricingDetailsPricingModelOneOf {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
    /**
     * Pricing details for all pricing models.
     * @readonly
     */
    prices?: SpannedPrice[];
}
/** @oneof */
interface PricingDetailsPricingModelOneOf {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
}
interface SpannedPrice {
    /**
     * Cycle duration to apply `price` for.
     *
     * Use with all pricing models.
     * Can apply the same price to multiple payment cycles.
     */
    duration?: PriceDuration;
    /** Order price. */
    price?: Price;
}
interface PriceDuration {
    /**
     * Price starts to apply with this cycle.
     *
     * `1` is the first payment cycle for all pricing models.
     */
    cycleFrom?: number;
    /**
     * Amount of cycles to apply price for.
     *
     * For `subscription` pricing models with a finite number of cycles, the `numberOfCycles` is the same as `pricing.subscription.cycleCount`.
     *
     * For `subscription` pricing models that are unlimited or until-canceled, the `numberOfCycles` is not returned.
     *
     * For `singlePaymentForDuration` and `singlePaymentUnlimited` pricing models, the `numberOfCycles` is `1`.
     */
    numberOfCycles?: number | null;
}
interface Price {
    /** Price of the order excluding tax, specified as a monetary amount. For example, `"9.99"`. */
    subtotal?: string;
    /** Coupon applied to the order. */
    coupon?: Coupon;
    /** Total discount applied to the order. */
    discount?: string;
    /**
     * Tax applied to the order.
     *
     * Tax is only applied if the site [has it configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection).
     */
    tax?: Tax;
    /**
     * Price after tax and discount is applied. Specified as a monetary amount, for example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     */
    total?: string;
    /**
     * Three-letter currency code in
     * [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     */
    currency?: string;
    /** Price change after billing date was change and price was adjusted. Could be positive and negative values. */
    proration?: string;
}
interface Fee {
    /** Fee name */
    name?: string;
    /** Amount of fee to be charged */
    amount?: string;
}
declare enum OrderType {
    UNDEFINED = "UNDEFINED",
    /** Payments made by the buyer */
    ONLINE = "ONLINE",
    /** Payments managed manually by the site owner */
    OFFLINE = "OFFLINE",
    /** Payments managed externally */
    EXTERNAL = "EXTERNAL"
}
declare enum OrderMethod {
    UNKNOWN = "UNKNOWN",
    /** Mail Order / Telephone Order transaction */
    MOTO = "MOTO",
    /** Point of Sale transaction */
    POS = "POS"
}
declare enum OrderStatus {
    /** Order status undefined */
    UNDEFINED = "UNDEFINED",
    /** Order created, but hasn't been paid for yet. Filtered out in ListOrders response by default. */
    DRAFT = "DRAFT",
    /** Order has been paid for, but the start date is in the future */
    PENDING = "PENDING",
    /** Order is active */
    ACTIVE = "ACTIVE",
    /** Order is paused until site owner resumes it */
    PAUSED = "PAUSED",
    /** Order has ended */
    ENDED = "ENDED",
    /** Order has been canceled */
    CANCELED = "CANCELED"
}
interface Cancellation {
    /** Date and time the cancellation was requested. */
    requestedDate?: Date;
    /**
     * Reason for the cancellation. One of:
     * + `OWNER_ACTION`: Site owner canceled the order.
     * + `MEMBER_ACTION`: Buyer initiated the cancellation.
     * + `PAYMENT_FAILURE`: Payment transaction failed.
     * + `PAYMENT_SETUP_FAILURE`: Buyer's payment details weren't set up correctly.
     * + `UNKNOWN`: Reason for the cancellation is unknown.
     */
    cause?: CancellationCause;
    /**
     * When the cancellation takes effect. Set when cancelling the order. One of:
     * + `IMMEDIATELY`: Cancellation occurs immediately and the buyer can no longer use the plan.
     * + `NEXT_PAYMENT_DATE`: Cancellation occurs at the next payment date and time. Buyer can continue to use the plan until that date and time.
     */
    effectiveAt?: CancellationEffectiveAt;
}
declare enum CancellationCause {
    /** Cancellation initiator undefined */
    UNDEFINED = "UNDEFINED",
    /** Order was canceled by site owner (default if canceled by user or service identity) */
    OWNER_ACTION = "OWNER_ACTION",
    /** Order was canceled by member (default if canceled by member identity) */
    MEMBER_ACTION = "MEMBER_ACTION",
    /** Order was canceled because of payment failure */
    PAYMENT_FAILURE = "PAYMENT_FAILURE",
    /** Order was canceled because of payment setup failure */
    PAYMENT_SETUP_FAILURE = "PAYMENT_SETUP_FAILURE",
    /** Order was cancelled because of an unknown reason. It's not possible to know with certain payment providers (e.g. paypal) */
    UNKNOWN = "UNKNOWN"
}
declare enum CancellationEffectiveAt {
    /** Cancellation time undefined */
    UNDEFINED = "UNDEFINED",
    /** Will cancel the order now, i.e. update validUntil to the current date */
    IMMEDIATELY = "IMMEDIATELY",
    /** Will cancel the order at the date when next payment should have been made */
    NEXT_PAYMENT_DATE = "NEXT_PAYMENT_DATE"
}
declare enum PaymentStatus {
    /** Payment status undefined */
    UNDEFINED = "UNDEFINED",
    /** Payment has been paid */
    PAID = "PAID",
    /** Payment has been refunded */
    REFUNDED = "REFUNDED",
    /** Recurring payment has failed */
    FAILED = "FAILED",
    /** Payment has not been paid */
    UNPAID = "UNPAID",
    /** Billing has been initialized, but actual charge is yet to be made. Can happen for free trial and PayPal */
    PENDING = "PENDING",
    /** Used in cases where the plan is free */
    NOT_APPLICABLE = "NOT_APPLICABLE"
}
interface PausePeriod {
    /**
     * Status of the pause period. Supported values:
     * + `ACTIVE`: Status while the order is [paused](#pauseorder).
     * + `ENDED`: Status when the order is [resumed](#resumeorder).
     */
    status?: Status;
    /** Start date and time of the pause period. */
    pauseDate?: Date;
    /**
     * End date and time of the pause period.
     *
     * Omitted while the pause period remains `ACTIVE`.
     */
    resumeDate?: Date;
}
declare enum Status {
    UNDEFINED = "UNDEFINED",
    /** Order suspension is active */
    ACTIVE = "ACTIVE",
    /** Order suspension has ended */
    ENDED = "ENDED"
}
/**
 * Current cycle will be empty when order is cancelled, expired or order start date is in the future
 * Current cycle start and end dates take into account free trial days and suspensions
 */
interface CurrentCycle {
    /**
     * Index of the current payment cycle in the order.
     *
     * `0` when order is in a free trial period. In all other cases, the index starts with `1`.
     */
    index?: number;
    /** Start date and time for the current payment cycle. */
    startedDate?: Date;
    /** End date and time for the current payment cycle. */
    endedDate?: Date;
}
/** Order cycle start and end dates take into account free trial days and suspensions */
interface OrderCycle {
    /**
     * Index of this cycle in the order.
     *
     * `0` when order is in a free trial period. In all other cases, the index starts with `1`.
     */
    index?: number;
    /** Start date and time for this order cycle. */
    startedDate?: Date;
    /** End date and time for this order cycle. */
    endedDate?: Date;
}
interface FormData {
    /** ID of the form associated with the plan at checkout. */
    formId?: string | null;
    /** ID of a submission to the plan's order form at checkout. Every time a visitor completes the checkout process for a plan, a new submission is created. */
    submissionId?: string | null;
    /**
     * Data submitted to the plan's order form at checkout.
     *
     * This field is returned when a method's `fieldset` is set to `"FULL"`.
     *
     * @readonly
     */
    submissionData?: Record<string, any>;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface Empty {
}
interface MemberGetOrderRequest {
    /** Order ID. */
    _id: string;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
declare enum Set {
    /** Same behavior as BASIC */
    UNKNOWN_SET = "UNKNOWN_SET",
    /**
     * Returns fields of the entity that are available in the database.
     * By default a field is available in the database unless explicitly specified in the documentation
     */
    BASIC = "BASIC",
    /**
     * Returns all fields in the entity.
     * This might make additional calls to gather the full entity
     */
    FULL = "FULL"
}
interface MemberGetOrderResponse {
    /** Requested order. */
    order?: Order;
}
interface MemberListOrdersRequest {
    /** Filter by plan IDs. */
    planIds?: string[];
    /** Filter for orders where auto renewal was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatus[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatus[];
    /** Limit the number of pricing plans returned. Default limit is 50. */
    limit?: number | null;
    /** Number of entries to offset. */
    offset?: number | null;
    /** Sorting direction (defaults to ASC) and field to sort by. [See available fields here](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort). */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
interface MemberListOrdersResponse {
    /** List of orders. */
    orders?: Order[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
/**
 * TODO: Write orders filter and sort docs page
 * Retrieves a list of up to 1,000 orders, based on the provided paging, [sorting, and filtering](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort).
 */
interface QueryOrdersRequest {
    /** [See available fields here](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort). */
    query?: QueryV2;
}
interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting[];
    /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
    fields?: string[];
    /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
    fieldsets?: string[];
}
/** @oneof */
interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryOrdersResponse {
    /** Order data. */
    plans?: Order[];
    /** Paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
interface RequestCancellationRequest {
    /** Order ID. */
    _id: string;
    /**
     * Whether to cancel the order immediately or at the next payment date.
     * One-time payment orders can only be canceled immediately.
     *
     * Supported values:
     * - `"IMMEDIATELY"`: Indicates that the order should be canceled immediately.
     * - `"NEXT_PAYMENT_DATE"`: Indicates that the order be canceled at the next payment date.
     */
    effectiveAt: CancellationEffectiveAt;
}
interface RequestCancellationResponse {
}
/**
 * Emitted when an order is canceled immediately or when cycle ends for an order with canceled auto renewal
 *
 * To determine the specific reason of the cancellation check `order.cancellation.cause` field.
 */
interface OrderCanceled {
    /** Canceled order. */
    order?: Order;
}
interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface CreateOnlineOrderRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Provided if checkout is initiated on buyer's behalf. */
    onBehalf?: OnBehalf;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
interface OnBehalf {
    /** Member ID. */
    memberId?: string;
    /** Method by which checkout is initiated on buyer's behalf */
    orderMethod?: OrderMethod;
}
interface CreateOnlineOrderResponse {
    /** Order. */
    order?: Order;
}
interface CouponsError {
    /** Coupon code. */
    couponCode?: string;
    /** Plan ID. */
    planId?: string;
}
interface CreateGuestOnlineOrderRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Captcha data to prove you are not a robot */
    captcha?: Captcha;
    /** Visitor info */
    guest?: Guest;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
interface Captcha {
    /** Token from captcha */
    token?: string;
}
interface Guest {
    /** Email for checkout */
    email?: string;
}
interface CreateGuestOnlineOrderResponse {
    /** Order. */
    order?: Order;
}
interface CreateOfflineOrderRequest {
    /** ID of the plan being ordered. */
    planId: string;
    /** ID of the member ordering the plan. */
    memberId: string;
    /**
     * Start date and time for the ordered plan.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /**
     * Whether the order is paid.
     *
     * Default: `false`
     */
    paid?: boolean | null;
    /**
     * Coupon code to apply.
     *
     * See [Coupons to learn more](https://dev.wix.com/api/rest/coupons).
     */
    couponCode?: string | null;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
interface CreateOfflineOrderResponse {
    /** Order. */
    order?: Order;
}
interface CreateExternalOrderRequest {
    /** Plan ID. */
    planId?: string;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
interface CreateExternalOrderResponse {
    /** Created order */
    order?: Order;
}
interface GetOnlineOrderPreviewRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
}
interface GetOnlineOrderPreviewResponse {
    /** Will be missing if limit is exceeded */
    order?: Order;
    /**
     * Whether the purchase limit has already been reached for this plan by this member.
     * Always false for plans without purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
interface GetGuestOnlineOrderPreviewRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Email for checkout */
    email?: string;
}
interface GetGuestOnlineOrderPreviewResponse {
    /** Will be missing if limit is exceeded */
    order?: Order;
    /**
     * Whether the purchase limit has already been reached for this plan by this email.
     * Always false for plans without purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
interface GetOfflineOrderPreviewRequest {
    /** ID of the plan of the previewed order. See [Plans for more information about plan IDs](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans). */
    planId: string;
    /** Member ID of the buyer the previewed order is for. */
    memberId: string;
    /**
     * Start date and time for plan of the previewed order.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /** Coupon code to apply. See [Coupons to learn more](https://dev.wix.com/api/rest/coupons). */
    couponCode?: string | null;
}
interface GetOfflineOrderPreviewResponse {
    /** The previewed order, as if the plan had been ordered. */
    order?: Order;
    /**
     * Whether this previewed order would exceed the permitted amount of purchases available
     * for this plan for this buyer.
     *
     * Always `false` for plans that do not have purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
interface GetPricePreviewRequest {
    /** ID of plan to preview. */
    planId: string;
    /**
     * Coupon code to apply.
     *
     * See Coupons [to learn more](https://dev.wix.com/api/rest/coupons).
     */
    couponCode?: string | null;
}
interface GetPricePreviewResponse {
    /**
     * @internal
     * @internal
     * @deprecated __Deprecated.__ Use `prices` instead. This property will be removed on September 30, 2022.
     * @replacedBy prices
     * @targetRemovalDate 2022-10-01
     */
    price?: PriceDetails;
    /** Pricing details. */
    prices?: SpannedPrice[];
}
interface ChangeStartDateRequest {
    /** Draft order ID. */
    orderId?: string;
    /** New valid from date (timestamp). */
    startDate?: Date;
}
interface ChangeStartDateResponse {
    /** Updated draft order. */
    order?: Order;
}
interface OrderStartDateChanged {
    /** Order whose `startDate` changed. */
    order?: Order;
}
interface ApplyCouponRequest {
    /** Draft order ID. */
    orderId?: string;
    /** Coupon code to apply. */
    couponCode?: string;
}
interface ApplyCouponResponse {
    /** Order with applied coupon and recalculated tax. */
    order?: Order;
}
interface SetSubmissionRequest {
    /** Order ID. */
    orderId?: string;
    /** Submission ID. */
    submissionId?: string;
}
interface SetSubmissionResponse {
    /** Order with submission id */
    order?: Order;
}
interface OrderPurchased {
    /** Order that was paid for. If a free or an offline order, the order that was created. */
    order?: Order;
}
interface OrderStarted {
    /** Order that reached its `startDate`. */
    order?: Order;
}
/**
 * Triggered at the start of a new payment cycle for an existing order.
 *
 * This webhook does not trigger at the initial start of an offline order.
 */
interface OrderCycleStarted {
    /** Order whose new cycle started. */
    order?: Order;
    /** Number of the payment cycle will be 0 when the order is in the free trial period. In other cases, the cycle number starts from 1. */
    cycleNumber?: number;
}
/** Emitted when a recurring order is canceled for the next payment cycle */
interface OrderAutoRenewCanceled {
    /** Order that is canceled, effective at the end of the current payment cycle. */
    order?: Order;
}
interface OrderEnded {
    /** Order that ended. */
    order?: Order;
}
interface GetOrderRequest {
    /** Order ID. */
    _id: string;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface GetOrderResponse {
    /** Order. */
    order?: Order;
}
interface ListOrdersRequest {
    /** Filter by a buyer's member ID. See [Members to learn more about a site's members](https://dev.wix.com/api/rest/members/members). */
    buyerIds?: string[];
    /** Filter by plan IDs. See [Plans to learn more about pricing plans](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans). */
    planIds?: string[];
    /** Filter by whether or not the auto-renewal of recurring orders was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatus[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatus[];
    /**
     * Number of orders to return. See [Pagination](https://dev.wix.com/api/rest/getting-started/sorting-and-paging#getting-started_sorting-and-paging_paging) for more information.
     *
     * Max: `50`
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `DESC`
     */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface ListOrdersResponse {
    /** List of orders. */
    orders?: Order[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
interface OrdersQueryOrdersRequest {
    /** [See available fields here](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort). */
    query?: QueryV2;
}
interface OrdersQueryOrdersResponse {
    /** Retrieved orders. */
    plans?: Order[];
    /** Paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
interface GetOrdersStatsRequest {
}
interface GetOrdersStatsResponse {
    /** Total number of orders. */
    totalOrderCount?: number;
    /** Number of active orders. */
    activeOrderCount?: number;
}
interface GetAvailableOrderActionsRequest {
    /** Order ID. */
    _id?: string;
}
interface GetAvailableOrderActionsResponse {
    /** Whether the order can be suspended. */
    suspendable?: boolean;
    /** If the order cannot be suspended, a reason is returned here. */
    notSuspendableReason?: ReasonNotSuspendable;
    /** Whether the order can be canceled by the buyer. */
    cancelableByBuyer?: boolean;
}
declare enum ReasonNotSuspendable {
    /** Reason unknown */
    UNDEFINED = "UNDEFINED",
    /** Saved in the database but is awaiting payment. Non-active orders cannot be suspended */
    PENDING = "PENDING",
    /** Trial orders cannot be suspended */
    TRIAL = "TRIAL",
    /** Canceled orders cannot be suspended */
    CANCELED = "CANCELED",
    /** Ended orders cannot be suspended */
    ENDED = "ENDED",
    /** Paid for orders with future start dates cannot be suspended */
    NOT_STARTED = "NOT_STARTED",
    /** Order is already suspended */
    ALREADY_SUSPENDED = "ALREADY_SUSPENDED",
    /** Orders based on recurring payments using older Stripe versions cannot be suspended */
    OLD_STRIPE = "OLD_STRIPE"
}
interface PostponeEndDateRequest {
    /** Order ID. */
    _id: string;
    /**
     * New end date and time.
     *
     * Must be later than the current end date and time.
     */
    endDate: Date;
}
interface PostponeEndDateResponse {
}
interface OrderEndDatePostponed {
    /** Order whose `endDate` was postponed. */
    order?: Order;
}
interface CancelOrderRequest {
    /** Order ID. */
    _id: string;
    /**
     * When the order is canceled.
     *
     * One time orders can only be canceled immediately. Supported values:
     * - `"IMMEDIATELY"`: The order is canceled immediately.
     * - `"NEXT_PAYMENT_DATE"`: The order is canceled at the next payment date.
     */
    effectiveAt: CancellationEffectiveAt;
}
interface CancelOrderResponse {
}
interface MarkAsPaidRequest {
    /** Order ID. */
    _id: string;
}
interface MarkAsPaidResponse {
}
interface OrderMarkedAsPaid {
    /** Order that was marked as paid. */
    order?: Order;
}
interface PauseOrderRequest {
    /** Order ID. */
    _id: string;
}
interface PauseOrderResponse {
}
interface OrderPaused {
    /** Paused order. */
    order?: Order;
}
interface BulkPauseOrderRequest {
    /** List of Order IDs. */
    ids?: string[];
    /** Set to true to return Order entity in response. */
    returnFullEntity?: boolean;
}
interface BulkPauseOrderResponse {
    /** Orders that were paused. */
    results?: BulkOrderResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkOrderResult {
    /** Item metadata */
    itemMetadata?: ItemMetadata;
    /** The order. */
    order?: Order;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface ResumeOrderRequest {
    /** Order ID. */
    _id: string;
}
interface ResumeOrderResponse {
}
interface OrderResumed {
    /** Resumed order. */
    order?: Order;
}
interface BulkResumeOrderRequest {
    /** List of Order IDs. */
    ids?: string[];
    /** Set to true to return Order entity in response. */
    returnFullEntity?: boolean;
}
interface BulkResumeOrderResponse {
    /** Orders that were resumed. */
    results?: BulkOrderResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BuyerNonNullableFields {
    memberId: string;
    contactId: string;
}
interface DurationNonNullableFields {
    unit: PeriodUnit;
}
interface RecurrenceNonNullableFields {
    cycleDuration?: DurationNonNullableFields;
}
interface TaxNonNullableFields {
    name: string;
    includedInPrice: boolean;
    rate: string;
    amount: string;
}
interface CouponNonNullableFields {
    code: string;
    amount: string;
    _id: string;
}
interface PriceDetailsNonNullableFields {
    subscription?: RecurrenceNonNullableFields;
    singlePaymentForDuration?: DurationNonNullableFields;
    subtotal: string;
    discount: string;
    tax?: TaxNonNullableFields;
    total: string;
    planPrice: string;
    currency: string;
    coupon?: CouponNonNullableFields;
}
interface PriceDurationNonNullableFields {
    cycleFrom: number;
}
interface FeeNonNullableFields {
    name: string;
    amount: string;
}
interface PriceNonNullableFields {
    subtotal: string;
    coupon?: CouponNonNullableFields;
    discount: string;
    tax?: TaxNonNullableFields;
    total: string;
    currency: string;
    fees: FeeNonNullableFields[];
    proration: string;
}
interface SpannedPriceNonNullableFields {
    duration?: PriceDurationNonNullableFields;
    price?: PriceNonNullableFields;
}
interface PricingDetailsNonNullableFields {
    subscription?: RecurrenceNonNullableFields;
    singlePaymentForDuration?: DurationNonNullableFields;
    prices: SpannedPriceNonNullableFields[];
}
interface CancellationNonNullableFields {
    cause: CancellationCause;
    effectiveAt: CancellationEffectiveAt;
}
interface PausePeriodNonNullableFields {
    status: Status;
}
interface CurrentCycleNonNullableFields {
    index: number;
}
interface OrderCycleNonNullableFields {
    index: number;
}
interface OrderNonNullableFields {
    _id: string;
    planId: string;
    subscriptionId: string;
    buyer?: BuyerNonNullableFields;
    priceDetails?: PriceDetailsNonNullableFields;
    pricing?: PricingDetailsNonNullableFields;
    type: OrderType;
    orderMethod: OrderMethod;
    status: OrderStatus;
    cancellation?: CancellationNonNullableFields;
    lastPaymentStatus: PaymentStatus;
    pausePeriods: PausePeriodNonNullableFields[];
    currentCycle?: CurrentCycleNonNullableFields;
    cycles: OrderCycleNonNullableFields[];
    planName: string;
    planDescription: string;
    planPrice: string;
    statusNew: OrderStatus;
}
interface MemberGetOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
interface MemberListOrdersResponseNonNullableFields {
    orders: OrderNonNullableFields[];
}
interface CreateOfflineOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
interface GetOfflineOrderPreviewResponseNonNullableFields {
    order?: OrderNonNullableFields;
    purchaseLimitExceeded: boolean;
}
interface GetPricePreviewResponseNonNullableFields {
    price?: PriceDetailsNonNullableFields;
    prices: SpannedPriceNonNullableFields[];
}
interface GetOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
interface ListOrdersResponseNonNullableFields {
    orders: OrderNonNullableFields[];
}
interface BaseEventMetadata {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
interface OrderCanceledEnvelope {
    data: OrderCanceled;
    metadata: EventMetadata;
}
/**
 * Triggered when an order is canceled.
 *
 * This webhook is triggered either immediately or at the end of the current payment cycle, as follows:
 * + If the order is canceled and `effectiveAt` is set to `IMMEDIATELY`, the webhook is triggered immediately when canceled.
 * + If the order is canceled and `effectiveAt` is set to `NEXT_PAYMENT_DATE`, the webhook is triggered at the end of the current payment cycle. In this case, the [Order Auto Renew Canceled Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-auto-renew-canceled-webhook) is triggered immediately.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_canceled
 * @documentationMaturity preview
 */
declare function onOrderCanceled(handler: (event: OrderCanceledEnvelope) => void | Promise<void>): void;
interface OrderCreatedEnvelope {
    entity: Order;
    metadata: EventMetadata;
}
/**
 * Triggered when an order is created.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_created
 * @documentationMaturity preview
 */
declare function onOrderCreated(handler: (event: OrderCreatedEnvelope) => void | Promise<void>): void;
interface OrderUpdatedEnvelope {
    entity: Order;
    metadata: EventMetadata;
}
/**
 * Triggered when an order is updated.
 *
 * Order Updated Webhook is triggered when any of the following happens:
 * + Order is paid for. [Order Purchased Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-purchased-webhook) is also triggered.
 * + Order reaches its start date or end date. [Order Started Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-started-webhook) and [Order Ended Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-ended-webhook), respectively, are also triggered.
 * + New payment cycle of an order starts. [Order Cycle Started Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-cycle-started-webhook) is also triggered.
 * + Offline order is marked as paid. [Order Marked As Paid Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-marked-as-paid-webhook) is also triggered.
 * + End date of the order is postponed. [Order End Date Postponed Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-end-date-postponed-webhook) is also triggered
 * + Order is paused, or a paused order is resumed. [Order Paused Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-paused-webhook)
 * and [Order Resumed Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-resumed-webhook), respectively, are also triggered.
 * + Order is canceled, either immediately or at the end of the payment cycle. [Order Canceled Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-canceled-webhook)
 * and [Order Auto Renew Canceled Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-auto-renew-canceled-webhook) are also triggered.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_updated
 * @documentationMaturity preview
 */
declare function onOrderUpdated(handler: (event: OrderUpdatedEnvelope) => void | Promise<void>): void;
interface OrderStartDateChangedEnvelope {
    data: OrderStartDateChanged;
    metadata: EventMetadata;
}
/**
 * Triggered when an order's `startDate` is changed.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_start_date_changed
 * @documentationMaturity preview
 */
declare function onOrderStartDateChanged(handler: (event: OrderStartDateChangedEnvelope) => void | Promise<void>): void;
interface OrderPurchasedEnvelope {
    data: OrderPurchased;
    metadata: EventMetadata;
}
/**
 * Triggered when an order is purchased.
 *
 * This webhook is triggered for any of the following events:
 * + Order is paid in full.
 * + At least 1 order cycle payment is paid for.
 * + Offline order is created, even if not yet marked as paid.
 * + Free order is created.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_purchased
 * @documentationMaturity preview
 */
declare function onOrderPurchased(handler: (event: OrderPurchasedEnvelope) => void | Promise<void>): void;
interface OrderStartedEnvelope {
    data: OrderStarted;
    metadata: EventMetadata;
}
/**
 * Triggered when an order reaches its `startDate`. Applies to both purchased and free orders.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_started
 * @documentationMaturity preview
 */
declare function onOrderStarted(handler: (event: OrderStartedEnvelope) => void | Promise<void>): void;
interface OrderCycleStartedEnvelope {
    data: OrderCycleStarted;
    metadata: EventMetadata;
}
/**
 * Triggered at the start of a new payment cycle for an existing order.
 *
 * This webhook is not triggered at the initial start of an offline order.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_cycle_started
 * @documentationMaturity preview
 */
declare function onOrderCycleStarted(handler: (event: OrderCycleStartedEnvelope) => void | Promise<void>): void;
interface OrderAutoRenewCanceledEnvelope {
    data: OrderAutoRenewCanceled;
    metadata: EventMetadata;
}
/**
 * Triggered when an order is canceled and `effectiveAt` is set to `NEXT_PAYMENT_DATE`.
 *
 * This webhook is *not* triggered in the following scenarios:
 * + When an order is canceled and `effectiveAt` is set to `IMMEDIATELY`. Instead, at the time of cancellation, [Order Canceled](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-canceled-webhook) is triggered.
 * + When an order expires at the end of the current payment cycle because it was canceled and `effectiveAt` was set to `NEXT_PAYMENT_DATE`. Instead, at the time of expiration, [Order Canceled](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-canceled-webhook) and [Order Ended](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-ended-webhook) are triggered.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_auto_renew_canceled
 * @documentationMaturity preview
 */
declare function onOrderAutoRenewCanceled(handler: (event: OrderAutoRenewCanceledEnvelope) => void | Promise<void>): void;
interface OrderEndedEnvelope {
    data: OrderEnded;
    metadata: EventMetadata;
}
/**
 * Triggered when an order ends.
 *
 * This webhook is triggered:
 * + When an order expires at the end of the current payment cycle.
 * + When an order is canceled and `effectiveAt` is set to `IMMEDIATELY`..
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_ended
 * @documentationMaturity preview
 */
declare function onOrderEnded(handler: (event: OrderEndedEnvelope) => void | Promise<void>): void;
interface OrderEndDatePostponedEnvelope {
    data: OrderEndDatePostponed;
    metadata: EventMetadata;
}
/**
 * Triggered when an order's `endDate` is postponed.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_end_date_postponed
 * @documentationMaturity preview
 */
declare function onOrderEndDatePostponed(handler: (event: OrderEndDatePostponedEnvelope) => void | Promise<void>): void;
interface OrderMarkedAsPaidEnvelope {
    data: OrderMarkedAsPaid;
    metadata: EventMetadata;
}
/**
 * Triggered when an offline order is marked as paid.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_marked_as_paid
 * @documentationMaturity preview
 */
declare function onOrderMarkedAsPaid(handler: (event: OrderMarkedAsPaidEnvelope) => void | Promise<void>): void;
interface OrderPausedEnvelope {
    data: OrderPaused;
    metadata: EventMetadata;
}
/**
 * Triggered when an order is paused.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_paused
 * @documentationMaturity preview
 */
declare function onOrderPaused(handler: (event: OrderPausedEnvelope) => void | Promise<void>): void;
interface OrderResumedEnvelope {
    data: OrderResumed;
    metadata: EventMetadata;
}
/**
 * Triggered when a paused order is resumed.
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @webhook
 * @eventType wix.pricing_plans.v2.order_resumed
 * @documentationMaturity preview
 */
declare function onOrderResumed(handler: (event: OrderResumedEnvelope) => void | Promise<void>): void;
/**
 * Gets an order by ID for the currently logged-in member.
 *
 * The `memberGetOrder()` function returns a Promise that resolves to information about a specified order for the currently logged-in member.
 * @param _id - Order ID.
 * @public
 * @requiredField _id
 * @param options - Options for getting a logged-in member's order.
 * @permissionId PRICING_PLANS.READ_OWN_ORDERS
 * @applicableIdentity MEMBER
 * @returns Requested order.
 */
declare function memberGetOrder(_id: string, options?: MemberGetOrderOptions): Promise<Order & OrderNonNullableFields>;
interface MemberGetOrderOptions {
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
/**
 * Lists orders for the currently logged-in member.
 *
 * The `memberListOrders()` function returns a Promise that resolves to a list of up to 100 pricing plan orders.
 * @public
 * @documentationMaturity preview
 * @param options - Filtering, sorting, and pagination options.
 * @permissionId PRICING_PLANS.READ_OWN_ORDERS
 * @applicableIdentity MEMBER
 */
declare function memberListOrders(options?: MemberListOrdersOptions): Promise<MemberListOrdersResponse & MemberListOrdersResponseNonNullableFields>;
interface MemberListOrdersOptions {
    /** Filter by plan IDs. */
    planIds?: string[];
    /** Filter for orders where auto renewal was canceled. */
    autoRenewCanceled?: boolean | null;
    /**
     * Filter by the order status. Supported values:
     * + `DRAFT`: Order has been initiated but payment hasn't been processed yet. The plan isn't yet available for use to the buyer.
     * + `PENDING`: Order has been purchased and its start date is set in the future.
     * + `ACTIVE`: Order has been processed. The plan is available for use.
     * + `PAUSED`: Order, and use of the plan, is [paused](#pauseorder). The order, and use of the plan, can be [resumed](#resumeorder).
     * + `ENDED`: Order has completed its duration and is no longer available for use.
     * + `CANCELED`: Order has been [canceled](#cancelorder).
     */
    orderStatuses?: OrderStatus[];
    /**
     * Key Path to edit
     * ManagementListOrdersOptions.paymentStatuses
     * Production value
     * Filter by payment status.
     * Override
     * Filter by payment status.
     *
     * Supported values:
     * + `PAID`: The last payment was paid.
     * + `REFUNDED`: The last payment was refunded.
     * + `FAILED`: The last payment transaction didn't complete.
     * + `UNPAID`: The last payment wasn't paid.
     * + `PENDING`: Awaiting payment.
     * + `NOT_APPLICABLE`: No payment was necessary. For example, for free plans or free trials.
     * Mark down view
     * Filter by payment status.
     *
     * Supported values:
     *
     * PAID: The last payment was paid.
     * REFUNDED: The last payment was refunded.
     * FAILED: The last payment transaction didn't complete.
     * UNPAID: The last payment wasn't paid.
     * PENDING: Awaiting payment.
     * NOT_APPLICABLE: No payment was necessary. For example, for free plans or free trials.
     */
    paymentStatuses?: PaymentStatus[];
    /**
     * Number of pricing plan orders to return.
     *
     * Default: `50`
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `ASC`
     */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
/**
 * Starts the process of canceling an order.
 *
 *
 * The `requestCancellation()` function returns a Promise that resolves when the order cancellation is successfully requested.
 *
 * For orders with recurring payments, a cancellation can be set to occur either immediately or at the next payment date. For orders with one-time payments, a cancellation occurs immediately after the request is processed.
 *
 * Requesting an order cancellation starts the cancellation process. There may be some operations that continue to be processed before the status of the order is changed to `"CANCELED"`. For example, payments might need to be refunded before the order is fully canceled.
 *
 * #### Canceling during the free trial period.
 *
 * When a buyer cancels their order during the free trial period, the buyer's subscription expires at the end of the free trial period and they won't be billed. The buyer may continue using the benefits until the end of the free trial period.
 *
 * @param _id - Order ID.
 * @param effectiveAt - Whether to cancel the order immediately or at the next payment date.
 * One-time payment orders can only be canceled immediately.
 *
 * Supported values:
 * - `"IMMEDIATELY"`: Indicates that the order should be canceled immediately.
 * - `"NEXT_PAYMENT_DATE"`: Indicates that the order be canceled at the next payment date.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @requiredField effectiveAt
 * @param options - Options for requesting a cancellation.
 * @permissionId PRICING_PLANS.MANAGE_OWN_ORDERS
 * @applicableIdentity MEMBER
 * @returns Fulfilled - When the cancellation process is started.
 */
declare function requestCancellation(_id: string, effectiveAt: CancellationEffectiveAt): Promise<void>;
/**
 * Creates an order for a buyer who purchased the plan with an offline transaction.
 *
 * The `createOfflineOrder()` function returns a Promise that resolves to an `order` object when the order has been created.
 *
 * Payment of an offline order is handled in 1 of 2 ways.
 * - When creating the order, select `true` in the `paid` request parameter.
 * - After creation, with the [`markAsPaid()`](#markaspaid) function.
 *
 * When creating a non-free offline order:
 * - The order's status is set to `"PENDING"` if the start date is in the future. Otherwise, the status is set to `"ACTIVE"`.
 * The order's last payment status is set to `"UNPAID"` or `"PAID"`.
 *
 * When creating a free offline order:
 * - The order's status is set to `"PENDING"` if the start date is in the future. Otherwise, the status is set to `"ACTIVE"`.
 * - The order's last payment status is set to `"NOT_APPLICABLE"`.
 * @param memberId - ID of the member ordering the plan.
 * @public
 * @documentationMaturity preview
 * @requiredField memberId
 * @requiredField planId
 * @param options - Options for creating an offline order.
 * @param planId - ID of the plan being ordered. See [Plans for more information about plan IDs](plans)
 * @permissionId PRICING_PLANS.REGISTER_OFFLINE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns Fulfilled - The order of the plan.
 */
declare function createOfflineOrder(planId: string, memberId: string, options?: CreateOfflineOrderOptions): Promise<CreateOfflineOrderResponse & CreateOfflineOrderResponseNonNullableFields>;
interface CreateOfflineOrderOptions {
    /**
     * Start date and time for the ordered plan.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /**
     * Whether the order is paid.
     *
     * Default: `false`
     */
    paid?: boolean | null;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Form submission ID that was submitted together with the order. */
    submissionId?: string | null;
}
/**
 * Provides a preview of an offline order as if it was purchased.
 *
 * The `getOfflineOrderPreview()` function returns a Promise that resolves to a temporary preview of the offline order.
 *
 * The preview uses the same logic as purchasing a plan, but the preview is not saved. Because an order is not actually created, the preview's `_id` and `subscriptionId` properties are displayed as a string of multiple zero characters (`000000-0000`).
 *
 * If [taxes are configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection) for the site, taxes are applied to the preview. If not, `tax` previews as `null`.
 *
 * You can preview the order to check purchase limitations, but the limitations are not enforced for the preview. If a pricing plan has a limit on the amount of purchases per buyer, that limit is not considered for generating the preview. But, if that limit has been reached and this order would then exceed the amount of purchases permitted for this buyer, then `purchaseLimitExceeded` will return as `true`. Thus function is not available to the buyer. You specify the member ID for the buyer whose order should be previewed. To get a general price preview for a plan that's not buyer-specific, use the [`getPricePreview()`](#getpricepreview) function.
 * @param memberId - Member ID of the buyer the previewed order is for.
 * @public
 * @documentationMaturity preview
 * @requiredField memberId
 * @requiredField planId
 * @param options - Options for previewing the offline order.
 * @param planId - ID of the plan of the previewed order.
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns Fulfilled - A preview of the order.
 */
declare function getOfflineOrderPreview(planId: string, memberId: string, options?: GetOfflineOrderPreviewOptions): Promise<GetOfflineOrderPreviewResponse & GetOfflineOrderPreviewResponseNonNullableFields>;
interface GetOfflineOrderPreviewOptions {
    /**
     * Start date and time for plan of the previewed order.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
}
/**
 * Retrieves a preview of an order's pricing as if it was purchased.
 *
 * The `getPricePreview()` function returns a Promise that resolves to a temporary preview of the order's price.
 *
 * The price preview uses the same logic for calculating prices as used when purchasing a plan, but the preview is not saved. If [taxes are configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection) for the site, taxes are applied to the preview. If not, the `tax` previews as `null`.
 *
 * Buyers do not have to be logged in to preview the price, as such, the details returned by this function are not buyer-specific. To generate a preview of a purchase for a specific-buyer, use the [`getOfflineOrderPreview()`](#getofflineorderpreview).
 * @param planId - ID of plan to preview.
 * @public
 * @documentationMaturity preview
 * @requiredField planId
 * @param options - Options for getting a price preview.
 * @permissionId PRICING_PLANS.READ_PUBLIC_PLANS
 * @permissionScope Read Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-PLANS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-PLANS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @returns Fulfilled - A preview of the pricing for the order.
 */
declare function getPricePreview(planId: string, options?: GetPricePreviewOptions): Promise<GetPricePreviewResponse & GetPricePreviewResponseNonNullableFields>;
interface GetPricePreviewOptions {
    /** Coupon code to apply.  */
    couponCode?: string | null;
}
/**
 * Retrieves an order by ID.
 *
 * The `managementGetOrder()` function returns a Promise that resolves to information about the specified order.
 * @param _id - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @param options - Options to use when getting an order.
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @applicableIdentity APP
 */
declare function managementGetOrder(_id: string, options?: ManagementGetOrderOptions): Promise<GetOrderResponse & GetOrderResponseNonNullableFields>;
interface ManagementGetOrderOptions {
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
/**
 * Lists pricing plan orders.
 *
 * The `managementListOrders()` function returns a Promise that resolves to a list of up to 50 pricing plan orders. You can specify options for filtering, sorting, and paginating the results.
 *
 * This function returns the orders on the site. To list orders for the currently logged-in member, use [`memberListOrders()`](#memberlistorders).
 * @public
 * @documentationMaturity preview
 * @param options - Filtering, sorting, and pagination options.
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @applicableIdentity APP
 */
declare function managementListOrders(options?: ManagementListOrdersOptions): Promise<ListOrdersResponse & ListOrdersResponseNonNullableFields>;
interface ManagementListOrdersOptions {
    /** Filter by specific member IDs of buyers who ordered a pricing plan. */
    buyerIds?: string[];
    /** Filter by specific IDs of plans that were ordered.  */
    planIds?: string[];
    /** Filter by whether or not the auto-renewal of recurring orders was canceled. */
    autoRenewCanceled?: boolean | null;
    /**
     * Filter by the order status. Supported values:
     * + `DRAFT`: Order has been initiated but payment hasn't been processed yet. The plan isn't yet available for use to the buyer.
     * + `PENDING`: Order has been purchased and its start date is set in the future.
     * + `ACTIVE`: Order has been processed. The plan is available for use.
     * + `PAUSED`: Order, and use of the plan, is [paused](#pauseorder). The order, and use of the plan, can be [resumed](#resumeorder).
     * + `ENDED`: Order has completed its duration and is no longer available for use.
     * + `CANCELED`: Order has been [canceled](#cancelorder).
     */
    orderStatuses?: OrderStatus[];
    /**
     * Filter by payment status.
     *
     * Supported values:
     * + `PAID`: The last payment was paid.
     * + `REFUNDED`: The last payment was refunded.
     * + `FAILED`: The last payment transaction didn't complete.
     * + `UNPAID`: The last payment wasn't paid.
     * + `PENDING`: Awaiting payment.
     * + `NOT_APPLICABLE`: No payment was necessary. For example, for free plans or free trials.
     */
    paymentStatuses?: PaymentStatus[];
    /**
     * Number of pricing plan orders to return.
     *
     * Default: `50`
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `DESC`
     */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
/**
 * Extends the duration of a pricing plan order by postponing the order's `endDate`.
 *
 * The `postponeEndDate()` function returns a Promise that resolves when the order's end date is successfully changed.
 *
 * The new end date and time must be later than the order's current `endDate`.
 *
 * Postponing the end date of an order does not impact payments. For example, if the pricing plan is for a membership to an online lecture series, and you want to extend the duration of the series because the lecturer could not attend some sessions, you can postpone the end date of the orders for all relevant participants. The participants will not be billed additionally.
 *
 * Postponing an order causes the following changes:
 * - The `endDate` for the order is adjusted to the new end date.
 * @param _id - Order ID.
 * @param endDate - New end date and time.
 *
 * Must be later than the current end date and time.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @requiredField endDate
 * @param options - Options for postponing the end date of an order.
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns Fulfilled - When the order's end date has been postponed or made earlier.
 *
 *
 */
declare function postponeEndDate(_id: string, endDate: Date): Promise<void>;
/**
 * Cancels an existing order.
 *
 * The `cancelOrder()` function returns a Promise that resolves when the order is successfully canceled.
 *
 * For orders with recurring payments, a cancellation can be set to occur either `IMMEDIATELY` or at the `NEXT_PAYMENT_DATE`.
 * For orders with one-time payments, a cancellation occurs `IMMEDIATELY`.
 *
 * Canceling an order changes the order status to `CANCELED`.
 *
 * #### Canceling during the free trial period.
 *
 * When a site owner cancels an ordered plan during the free trial period, they choose to apply the cancellation `IMMEDIATELY` or at the `NEXT_PAYMENT_DATE`.
 *
 * Canceling `IMMEDIATELY` will end the subscription for the buyer
 * immediately, even during the free trial period and the buyer won't be billed.
 *
 * Canceling at the `NEXT_PAYMENT_DATE` allows the buyer to continue using the benefits of the subscription until the end of the free trial period. Then, the subscription ends and the buyer is not billed.
 * @param _id - Order ID.
 * @param effectiveAt - When the order is canceled.
 *
 * One time orders can only be canceled immediately. Supported values:
 * - `"IMMEDIATELY"`: The order is canceled immediately.
 * - `"NEXT_PAYMENT_DATE"`: The order is canceled at the next payment date.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @requiredField effectiveAt
 * @param options - Options for canceling orders.
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns Fulfilled - When the order is canceled.
 */
declare function cancelOrder(_id: string, effectiveAt: CancellationEffectiveAt): Promise<void>;
/**
 * Marks an offline order as paid.
 *
 * The `markAsPaid()` function returns a Promise that resolves when the offline order is successfully marked as paid.
 *
 * The entire order is marked as paid, even if the order's payments are recurring.
 *
 * >**Note:** Marking separate payment cycles as paid is not yet supported. Subsequent offline payments do trigger events and emails, but are not registered as additional offline payments.
 *
 * Marking an offline order as paid causes the following changes:
 * - The order's `lastPaymentStatus` changes to `"PAID"`.
 * - The order's status changes to either `"PENDING"` or `"ACTIVE"`, depending on the order's `startDate`.
 *
 * An error occurs if you attempt to:
 * - Mark an already-paid, offline order as paid. You cannot make an offline order as paid twice.
 * - Mark an online order as paid. The `markAsPaid()` function is supported for offline orders only.
 * @param _id - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns Fulfilled - When the order is marked as paid.
 */
declare function markAsPaid(_id: string): Promise<void>;
/**
 * Pauses a pricing plan order.
 *
 * The `pauseOrder()` function returns a Promise that resolves when the order is successfully paused.
 *
 * For orders with recurring payments, `pauseOrder()` also pauses the payment schedule. Buyers are not charged when an order is paused. Use `pauseOrder()`, for example, if the buyer is away and would like to put their pricing plan membership on hold until they return. Pausing an order affects the end date of the order by adding the time the order is paused to the `endDate`. You can only pause orders with an `"ACTIVE`" status.
 *
 * Pausing an order causes the following changes:
 * - The order status changes to `"PAUSED"`.
 * - The `pausePeriods` array is updated.
 *
 * The `endDate` and the `earliestEndDate` for the order are adjusted to include the pause period when the order is resumed.
 *
 * Paused orders can be continued with the [`resumeOrder()`](#resumeorder) function.
 * @param _id - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns Fulfilled - When the order is paused.
 */
declare function pauseOrder(_id: string): Promise<void>;
/**
 * Resumes a paused pricing plan order.
 *
 * The `resumeOrder()` function returns a Promise that resolves when a paused order is successfully resumed.
 *
 * For orders with recurring payments, `resumeOrder()` also restarts the payment schedule.
 *
 * Resuming an order causes the following changes:
 * - The order status changes to `"ACTIVE"`.
 * - The `pausePeriods` array is updated.
 * - The `endDate` for the order is adjusted to include the pause period.
 * - The `earliestEndDate` is adjusted to include the pause period. (This property is reserved for future use).
 * @param _id - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns Fulfilled - When the order is resumed.
 */
declare function resumeOrder(_id: string): Promise<void>;

export { type ActionEvent, type ApplicationError, type ApplyCouponRequest, type ApplyCouponResponse, type BaseEventMetadata, type BulkActionMetadata, type BulkOrderResult, type BulkPauseOrderRequest, type BulkPauseOrderResponse, type BulkResumeOrderRequest, type BulkResumeOrderResponse, type Buyer, type CancelOrderRequest, type CancelOrderResponse, type Cancellation, CancellationCause, CancellationEffectiveAt, type Captcha, type ChangeStartDateRequest, type ChangeStartDateResponse, type Coupon, type CouponsError, type CreateExternalOrderRequest, type CreateExternalOrderResponse, type CreateGuestOnlineOrderRequest, type CreateGuestOnlineOrderResponse, type CreateOfflineOrderOptions, type CreateOfflineOrderRequest, type CreateOfflineOrderResponse, type CreateOfflineOrderResponseNonNullableFields, type CreateOnlineOrderRequest, type CreateOnlineOrderResponse, type CurrentCycle, type CursorPaging, type Cursors, type DomainEvent, type DomainEventBodyOneOf, type Duration, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventMetadata, type Fee, type FormData, type GetAvailableOrderActionsRequest, type GetAvailableOrderActionsResponse, type GetGuestOnlineOrderPreviewRequest, type GetGuestOnlineOrderPreviewResponse, type GetOfflineOrderPreviewOptions, type GetOfflineOrderPreviewRequest, type GetOfflineOrderPreviewResponse, type GetOfflineOrderPreviewResponseNonNullableFields, type GetOnlineOrderPreviewRequest, type GetOnlineOrderPreviewResponse, type GetOrderRequest, type GetOrderResponse, type GetOrderResponseNonNullableFields, type GetOrdersStatsRequest, type GetOrdersStatsResponse, type GetPricePreviewOptions, type GetPricePreviewRequest, type GetPricePreviewResponse, type GetPricePreviewResponseNonNullableFields, type Guest, type IdentificationData, type IdentificationDataIdOneOf, type ItemMetadata, type ListOrdersRequest, type ListOrdersResponse, type ListOrdersResponseNonNullableFields, type ManagementGetOrderOptions, type ManagementListOrdersOptions, type MarkAsPaidRequest, type MarkAsPaidResponse, type MemberGetOrderOptions, type MemberGetOrderRequest, type MemberGetOrderResponse, type MemberGetOrderResponseNonNullableFields, type MemberListOrdersOptions, type MemberListOrdersRequest, type MemberListOrdersResponse, type MemberListOrdersResponseNonNullableFields, type MessageEnvelope, type OnBehalf, type Order, type OrderAutoRenewCanceled, type OrderAutoRenewCanceledEnvelope, type OrderCanceled, type OrderCanceledEnvelope, type OrderCreatedEnvelope, type OrderCycle, type OrderCycleStarted, type OrderCycleStartedEnvelope, type OrderEndDatePostponed, type OrderEndDatePostponedEnvelope, type OrderEnded, type OrderEndedEnvelope, type OrderMarkedAsPaid, type OrderMarkedAsPaidEnvelope, OrderMethod, type OrderNonNullableFields, type OrderPaused, type OrderPausedEnvelope, type OrderPurchased, type OrderPurchasedEnvelope, type OrderResumed, type OrderResumedEnvelope, type OrderStartDateChanged, type OrderStartDateChangedEnvelope, type OrderStarted, type OrderStartedEnvelope, OrderStatus, OrderType, type OrderUpdatedEnvelope, type OrdersQueryOrdersRequest, type OrdersQueryOrdersResponse, type Paging, type PagingMetadataV2, type PauseOrderRequest, type PauseOrderResponse, type PausePeriod, PaymentStatus, PeriodUnit, type PostponeEndDateRequest, type PostponeEndDateResponse, type Price, type PriceDetails, type PriceDetailsPricingModelOneOf, type PriceDuration, type PricingDetails, type PricingDetailsPricingModelOneOf, type QueryOrdersRequest, type QueryOrdersResponse, type QueryV2, type QueryV2PagingMethodOneOf, ReasonNotSuspendable, type Recurrence, type RequestCancellationRequest, type RequestCancellationResponse, type RestoreInfo, type ResumeOrderRequest, type ResumeOrderResponse, Set, type SetSubmissionRequest, type SetSubmissionResponse, SortOrder, type Sorting, type SpannedPrice, Status, type Tax, WebhookIdentityType, cancelOrder, createOfflineOrder, getOfflineOrderPreview, getPricePreview, managementGetOrder, managementListOrders, markAsPaid, memberGetOrder, memberListOrders, onOrderAutoRenewCanceled, onOrderCanceled, onOrderCreated, onOrderCycleStarted, onOrderEndDatePostponed, onOrderEnded, onOrderMarkedAsPaid, onOrderPaused, onOrderPurchased, onOrderResumed, onOrderStartDateChanged, onOrderStarted, onOrderUpdated, pauseOrder, postponeEndDate, requestCancellation, resumeOrder };
