type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition$1<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition$1<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition$1<Payload, Type>;
type EventHandler$1<T extends EventDefinition$1> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition$1<T extends EventDefinition$1<any, string>> = (handler: EventHandler$1<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> = NonNullable<
// Wrap in `NonNullable` to strip away the `undefined` type from the produced union.
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key since the condition passes.
		? Key
	// Discard this key since the condition fails.
		: never;

	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base]
>;

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition$1<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition$1<any> ? BuildEventDefinition$1<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

/**
 * An order object includes all of the details related to the purchase of a Pricing Plan.
 * You can manage existing orders, create offline orders, and preview orders not yet purchased.
 *
 * Orders are based on pricing models based on the payment and duration cycles for each plan. See here to
 * [learn more about pricing models](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/introduction#wix-pricing-plans_pricing-plans_introduction_pricing-models).
 */
interface Order {
    /**
     * Order ID.
     * @readonly
     */
    _id?: string;
    /**
     * ID of the plan purchased with the order.
     * @readonly
     */
    planId?: string;
    /**
     * ID of the related Wix subscription.
     *
     * Every pricing plan order corresponds to a Wix subscription, including orders for single payment plans. See a [Pricing Plans overview](https://support.wix.com/en/article/pricing-plans-an-overview#create-plans-to-suit-your-business).
     * @readonly
     */
    subscriptionId?: string;
    /**
     * Wix Pay order ID.
     *
     * Provided by Wix whether the order is created online or offline. The field is omitted when the order is free.
     * @readonly
     */
    wixPayOrderId?: string | null;
    /**
     * The buyer's IDs. Includes `memberId` and `contactId`.
     *
     * Currently, Pricing Plan purchases are limited to members only. `contactId` is returned,
     * but a buyer will not be able to purchase a plan without a `memberId`.
     * @readonly
     */
    buyer?: Buyer;
    /**
     * @internal
     * @internal
     * @readonly
     * @deprecated __Deprecated.__ Use `pricing` instead. This property will be removed on September 30, 2022.
     * @replacedBy pricing
     * @targetRemovalDate 2022-10-01
     */
    priceDetails?: PriceDetails;
    /**
     * Pricing model, price, and payment schedule for the order.
     * @readonly
     */
    pricing?: PricingDetails;
    /**
     * How the order was processed. Supported values:
     * + `"ONLINE"`: The buyer purchased the plan using the site.
     * + `"OFFLINE"`: The buyer made a manual, offline purchase without using the site.
     * @readonly
     */
    type?: OrderType;
    /**
     * Status of the order. Supported values:
     * + `DRAFT`: Order has been initiated but payment hasn't been processed yet. The plan isn't yet available for use to the buyer.
     * + `PENDING`: Order has been purchased and its start date is set in the future.
     * + `ACTIVE`: Order has been processed. The plan is available for use.
     * + `PAUSED`: Order, and use of the plan, is [paused](#pauseorder). The order, and use of the plan, can be [resumed](#resumeorder).
     * + `ENDED`: Order has completed its duration and is no longer available for use.
     * + `CANCELED`: Order has been [canceled](#cancelorder).
     * @readonly
     */
    status?: OrderStatus;
    /**
     * Whether the order will be canceled at the next payment date.
     *
     * If `true`, the order status will be `CANCELED` and the next payment won't be charged. Omitted for single payment orders.
     * @readonly
     */
    autoRenewCanceled?: boolean | null;
    /**
     * Details about the cancellation of an order.
     *
     *
     * @readonly
     */
    cancellation?: Cancellation;
    /**
     * Status of the last payment for the order.
     * Updated automatically for online orders. Updated manually by the site owner for offline orders.
     *
     * Supported values:
     * + `PAID`: The last payment was paid.
     * + `REFUNDED`: The last payment was refunded.
     * + `FAILED`: The last payment transaction didn't complete.
     * + `UNPAID`: The last payment wasn't paid.
     * + `PENDING`: Awaiting payment.
     * + `NOT_APPLICABLE`: No payment was necessary. For example, for free plans or free trials.
     * @readonly
     */
    lastPaymentStatus?: PaymentStatus;
    /**
     * Start date and time for the ordered plan.
     * @readonly
     */
    startDate?: Date;
    /**
     * Current end date and time for the ordered plan.
     *
     * `endDate` may be updated over the course of an order. If the order is [paused](#pauseorder),
     * it will have a later `endDate` once it [resumes](#resumeorder). `endDate` may also be [postponed](#postponeenddate).
     *
     * Omitted if the order is valid until canceled and still `ACTIVE`.
     * @readonly
     */
    endDate?: Date;
    /**
     * List of periods during which the order is paused.
     * @readonly
     */
    pausePeriods?: PausePeriod[];
    /**
     * Free trial period for the order, in days.
     *
     * Only available for recurring plans.
     * @readonly
     */
    freeTrialDays?: number | null;
    /**
     * Earliest end date and time that the plan for the order can expire.
     *
     * Calculated by using the original end date plus any pause periods. Omitted if the order is active until canceled. Reserved for future use.
     * @readonly
     */
    earliestEndDate?: Date;
    /**
     * Current payment cycle for the order.
     *
     * `currentCycle` will be omitted if the order's status is `CANCELED` or `ENDED`, or if the `startDate` hasn't passed yet.
     * @readonly
     */
    currentCycle?: CurrentCycle;
    /**
     * Plan name at the time of purchase.
     * @readonly
     */
    planName?: string;
    /**
     * Plan description at the time of purchase
     * @readonly
     */
    planDescription?: string;
    /**
     * Plan price as it was at the moment of order creation.
     * @readonly
     */
    planPrice?: string;
    /**
     * Date and time the order was created.
     * @readonly
     */
    _createdDate?: Date;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    _updatedDate?: Date;
    /**
     * Information about the form submitted during the plan's checkout.
     * @readonly
     */
    formData?: FormData;
}
interface Buyer {
    /**
     * Member ID for a buyer.
     * @readonly
     */
    memberId?: string;
    /**
     * Contact ID for a buyer.
     * @readonly
     */
    contactId?: string;
}
interface PriceDetails extends PriceDetailsPricingModelOneOf {
    /** Order has recurring payments. */
    subscription?: Recurrence;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
    /** Price of the order excluding tax, specified as a monetary amount. for example, `"9.99"`. */
    subtotal?: string;
    /** Total discount applied. */
    discount?: string;
    /** Tax applied. */
    tax?: Tax;
    /**
     * Price after tax and discount is applied, specified as a monetary amount. For example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     */
    total?: string;
    /** Plan price as it was at the moment of order creation. */
    planPrice?: string;
    /** Currency code. Must be valid ISO 4217 currency code (e.g., USD). */
    currency?: string;
    /** Free trial period for the order in days. Only available for recurring plans. */
    freeTrialDays?: number | null;
    /** Coupon applied to the order. Empty means no coupon was applied. */
    coupon?: Coupon;
}
/** @oneof */
interface PriceDetailsPricingModelOneOf {
    /** Order has recurring payments. */
    subscription?: Recurrence;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
}
interface Tax {
    /** Name of the tax. For example, VAT. */
    name?: string;
    /** Whether tax is included in the original price. When `false`, tax is added at checkout. */
    includedInPrice?: boolean;
    /** Tax rate percentage, as a number between 0 and 100. For example, a 7% tax rate is `"7.00"`. */
    rate?: string;
    /** Total tax, specified as a monetary amount. For example, `"3.99"`. */
    amount?: string;
}
/** An object specifying how often and for how long payments recur (may be forever). */
interface Recurrence {
    /** Length of one payment cycle. */
    cycleDuration?: Duration;
    /**
     * Amount of payment cycles this subscription is valid for.
     *
     * `0` for unlimited or until-canceled.
     */
    cycleCount?: number | null;
}
/** A duration expressed in number of time units. */
interface Duration {
    /** The amount of a duration `unit` in a single payment cycle. */
    count?: number | null;
    /** Unit of time for the cycle duration. */
    unit?: PeriodUnit;
}
declare enum PeriodUnit {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface Coupon {
    /** Code of the applied coupon. */
    code?: string;
    /** Total discount of the coupon, as a monetary amount. */
    amount?: string;
    /**
     * Coupon ID.
     * @readonly
     */
    _id?: string;
}
interface PricingDetails extends PricingDetailsPricingModelOneOf {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
    /**
     * Pricing details for all pricing models.
     * @readonly
     */
    prices?: SpannedPrice[];
}
/** @oneof */
interface PricingDetailsPricingModelOneOf {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
}
interface SpannedPrice {
    /**
     * Cycle duration to apply `price` for.
     *
     * Use with all pricing models.
     * Can apply the same price to multiple payment cycles.
     */
    duration?: PriceDuration;
    /** Order price. */
    price?: Price;
}
interface PriceDuration {
    /**
     * Price starts to apply with this cycle.
     *
     * `1` is the first payment cycle for all pricing models.
     */
    cycleFrom?: number;
    /**
     * Amount of cycles to apply price for.
     *
     * For `subscription` pricing models with a finite number of cycles, the `numberOfCycles` is the same as `pricing.subscription.cycleCount`.
     *
     * For `subscription` pricing models that are unlimited or until-canceled, the `numberOfCycles` is not returned.
     *
     * For `singlePaymentForDuration` and `singlePaymentUnlimited` pricing models, the `numberOfCycles` is `1`.
     */
    numberOfCycles?: number | null;
}
interface Price {
    /** Price of the order excluding tax, specified as a monetary amount. For example, `"9.99"`. */
    subtotal?: string;
    /** Coupon applied to the order. */
    coupon?: Coupon;
    /** Total discount applied to the order. */
    discount?: string;
    /**
     * Tax applied to the order.
     *
     * Tax is only applied if the site [has it configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection).
     */
    tax?: Tax;
    /**
     * Price after tax and discount is applied. Specified as a monetary amount, for example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     */
    total?: string;
    /**
     * Three-letter currency code in
     * [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     */
    currency?: string;
    /** Price change after billing date was change and price was adjusted. Could be positive and negative values. */
    proration?: string;
}
interface Fee {
    /** Fee name */
    name?: string;
    /** Amount of fee to be charged */
    amount?: string;
}
declare enum OrderType {
    UNDEFINED = "UNDEFINED",
    /** Payments made by the buyer */
    ONLINE = "ONLINE",
    /** Payments managed manually by the site owner */
    OFFLINE = "OFFLINE",
    /** Payments managed externally */
    EXTERNAL = "EXTERNAL"
}
declare enum OrderMethod {
    UNKNOWN = "UNKNOWN",
    /** Mail Order / Telephone Order transaction */
    MOTO = "MOTO",
    /** Point of Sale transaction */
    POS = "POS"
}
declare enum OrderStatus {
    /** Order status undefined */
    UNDEFINED = "UNDEFINED",
    /** Order created, but hasn't been paid for yet. Filtered out in ListOrders response by default. */
    DRAFT = "DRAFT",
    /** Order has been paid for, but the start date is in the future */
    PENDING = "PENDING",
    /** Order is active */
    ACTIVE = "ACTIVE",
    /** Order is paused until site owner resumes it */
    PAUSED = "PAUSED",
    /** Order has ended */
    ENDED = "ENDED",
    /** Order has been canceled */
    CANCELED = "CANCELED"
}
interface Cancellation {
    /** Date and time the cancellation was requested. */
    requestedDate?: Date;
    /**
     * Reason for the cancellation. One of:
     * + `OWNER_ACTION`: Site owner canceled the order.
     * + `MEMBER_ACTION`: Buyer initiated the cancellation.
     * + `PAYMENT_FAILURE`: Payment transaction failed.
     * + `PAYMENT_SETUP_FAILURE`: Buyer's payment details weren't set up correctly.
     * + `UNKNOWN`: Reason for the cancellation is unknown.
     */
    cause?: CancellationCause;
    /**
     * When the cancellation takes effect. Set when cancelling the order. One of:
     * + `IMMEDIATELY`: Cancellation occurs immediately and the buyer can no longer use the plan.
     * + `NEXT_PAYMENT_DATE`: Cancellation occurs at the next payment date and time. Buyer can continue to use the plan until that date and time.
     */
    effectiveAt?: CancellationEffectiveAt;
}
declare enum CancellationCause {
    /** Cancellation initiator undefined */
    UNDEFINED = "UNDEFINED",
    /** Order was canceled by site owner (default if canceled by user or service identity) */
    OWNER_ACTION = "OWNER_ACTION",
    /** Order was canceled by member (default if canceled by member identity) */
    MEMBER_ACTION = "MEMBER_ACTION",
    /** Order was canceled because of payment failure */
    PAYMENT_FAILURE = "PAYMENT_FAILURE",
    /** Order was canceled because of payment setup failure */
    PAYMENT_SETUP_FAILURE = "PAYMENT_SETUP_FAILURE",
    /** Order was cancelled because of an unknown reason. It's not possible to know with certain payment providers (e.g. paypal) */
    UNKNOWN = "UNKNOWN"
}
declare enum CancellationEffectiveAt {
    /** Cancellation time undefined */
    UNDEFINED = "UNDEFINED",
    /** Will cancel the order now, i.e. update validUntil to the current date */
    IMMEDIATELY = "IMMEDIATELY",
    /** Will cancel the order at the date when next payment should have been made */
    NEXT_PAYMENT_DATE = "NEXT_PAYMENT_DATE"
}
declare enum PaymentStatus {
    /** Payment status undefined */
    UNDEFINED = "UNDEFINED",
    /** Payment has been paid */
    PAID = "PAID",
    /** Payment has been refunded */
    REFUNDED = "REFUNDED",
    /** Recurring payment has failed */
    FAILED = "FAILED",
    /** Payment has not been paid */
    UNPAID = "UNPAID",
    /** Billing has been initialized, but actual charge is yet to be made. Can happen for free trial and PayPal */
    PENDING = "PENDING",
    /** Used in cases where the plan is free */
    NOT_APPLICABLE = "NOT_APPLICABLE"
}
interface PausePeriod {
    /**
     * Status of the pause period. Supported values:
     * + `ACTIVE`: Status while the order is [paused](#pauseorder).
     * + `ENDED`: Status when the order is [resumed](#resumeorder).
     */
    status?: Status;
    /** Start date and time of the pause period. */
    pauseDate?: Date;
    /**
     * End date and time of the pause period.
     *
     * Omitted while the pause period remains `ACTIVE`.
     */
    resumeDate?: Date;
}
declare enum Status {
    UNDEFINED = "UNDEFINED",
    /** Order suspension is active */
    ACTIVE = "ACTIVE",
    /** Order suspension has ended */
    ENDED = "ENDED"
}
/**
 * Current cycle will be empty when order is cancelled, expired or order start date is in the future
 * Current cycle start and end dates take into account free trial days and suspensions
 */
interface CurrentCycle {
    /**
     * Index of the current payment cycle in the order.
     *
     * `0` when order is in a free trial period. In all other cases, the index starts with `1`.
     */
    index?: number;
    /** Start date and time for the current payment cycle. */
    startedDate?: Date;
    /** End date and time for the current payment cycle. */
    endedDate?: Date;
}
/** Order cycle start and end dates take into account free trial days and suspensions */
interface OrderCycle {
    /**
     * Index of this cycle in the order.
     *
     * `0` when order is in a free trial period. In all other cases, the index starts with `1`.
     */
    index?: number;
    /** Start date and time for this order cycle. */
    startedDate?: Date;
    /** End date and time for this order cycle. */
    endedDate?: Date;
}
interface FormData {
    /** ID of the form associated with the plan at checkout. */
    formId?: string | null;
    /** ID of a submission to the plan's order form at checkout. Every time a visitor completes the checkout process for a plan, a new submission is created. */
    submissionId?: string | null;
    /**
     * Data submitted to the plan's order form at checkout.
     *
     * This field is returned when a method's `fieldset` is set to `"FULL"`.
     *
     * @readonly
     */
    submissionData?: Record<string, any>;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface Empty {
}
interface MemberGetOrderRequest {
    /** Order ID. */
    _id: string;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
declare enum Set {
    /** Same behavior as BASIC */
    UNKNOWN_SET = "UNKNOWN_SET",
    /**
     * Returns fields of the entity that are available in the database.
     * By default a field is available in the database unless explicitly specified in the documentation
     */
    BASIC = "BASIC",
    /**
     * Returns all fields in the entity.
     * This might make additional calls to gather the full entity
     */
    FULL = "FULL"
}
interface MemberGetOrderResponse {
    /** Requested order. */
    order?: Order;
}
interface MemberListOrdersRequest {
    /** Filter by plan IDs. */
    planIds?: string[];
    /** Filter for orders where auto renewal was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatus[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatus[];
    /** Limit the number of pricing plans returned. Default limit is 50. */
    limit?: number | null;
    /** Number of entries to offset. */
    offset?: number | null;
    /** Sorting direction (defaults to ASC) and field to sort by. [See available fields here](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort). */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
interface MemberListOrdersResponse {
    /** List of orders. */
    orders?: Order[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
/**
 * TODO: Write orders filter and sort docs page
 * Retrieves a list of up to 1,000 orders, based on the provided paging, [sorting, and filtering](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort).
 */
interface QueryOrdersRequest {
    /** [See available fields here](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort). */
    query?: QueryV2;
}
interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting[];
    /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
    fields?: string[];
    /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
    fieldsets?: string[];
}
/** @oneof */
interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryOrdersResponse {
    /** Order data. */
    plans?: Order[];
    /** Paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
interface RequestCancellationRequest {
    /** Order ID. */
    _id: string;
    /**
     * Whether to cancel the order immediately or at the next payment date.
     * One-time payment orders can only be canceled immediately.
     *
     * Supported values:
     * - `"IMMEDIATELY"`: Indicates that the order should be canceled immediately.
     * - `"NEXT_PAYMENT_DATE"`: Indicates that the order be canceled at the next payment date.
     */
    effectiveAt: CancellationEffectiveAt;
}
interface RequestCancellationResponse {
}
/**
 * Emitted when an order is canceled immediately or when cycle ends for an order with canceled auto renewal
 *
 * To determine the specific reason of the cancellation check `order.cancellation.cause` field.
 */
interface OrderCanceled {
    /** Canceled order. */
    order?: Order;
}
interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface CreateOnlineOrderRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Provided if checkout is initiated on buyer's behalf. */
    onBehalf?: OnBehalf;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
interface OnBehalf {
    /** Member ID. */
    memberId?: string;
    /** Method by which checkout is initiated on buyer's behalf */
    orderMethod?: OrderMethod;
}
interface CreateOnlineOrderResponse {
    /** Order. */
    order?: Order;
}
interface CouponsError {
    /** Coupon code. */
    couponCode?: string;
    /** Plan ID. */
    planId?: string;
}
interface CreateGuestOnlineOrderRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Captcha data to prove you are not a robot */
    captcha?: Captcha;
    /** Visitor info */
    guest?: Guest;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
interface Captcha {
    /** Token from captcha */
    token?: string;
}
interface Guest {
    /** Email for checkout */
    email?: string;
}
interface CreateGuestOnlineOrderResponse {
    /** Order. */
    order?: Order;
}
interface CreateOfflineOrderRequest {
    /** ID of the plan being ordered. */
    planId: string;
    /** ID of the member ordering the plan. */
    memberId: string;
    /**
     * Start date and time for the ordered plan.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /**
     * Whether the order is paid.
     *
     * Default: `false`
     */
    paid?: boolean | null;
    /**
     * Coupon code to apply.
     *
     * See [Coupons to learn more](https://dev.wix.com/api/rest/coupons).
     */
    couponCode?: string | null;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
interface CreateOfflineOrderResponse {
    /** Order. */
    order?: Order;
}
interface CreateExternalOrderRequest {
    /** Plan ID. */
    planId?: string;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
interface CreateExternalOrderResponse {
    /** Created order */
    order?: Order;
}
interface GetOnlineOrderPreviewRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
}
interface GetOnlineOrderPreviewResponse {
    /** Will be missing if limit is exceeded */
    order?: Order;
    /**
     * Whether the purchase limit has already been reached for this plan by this member.
     * Always false for plans without purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
interface GetGuestOnlineOrderPreviewRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Email for checkout */
    email?: string;
}
interface GetGuestOnlineOrderPreviewResponse {
    /** Will be missing if limit is exceeded */
    order?: Order;
    /**
     * Whether the purchase limit has already been reached for this plan by this email.
     * Always false for plans without purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
interface GetOfflineOrderPreviewRequest {
    /** ID of the plan of the previewed order. See [Plans for more information about plan IDs](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans). */
    planId: string;
    /** Member ID of the buyer the previewed order is for. */
    memberId: string;
    /**
     * Start date and time for plan of the previewed order.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /** Coupon code to apply. See [Coupons to learn more](https://dev.wix.com/api/rest/coupons). */
    couponCode?: string | null;
}
interface GetOfflineOrderPreviewResponse {
    /** The previewed order, as if the plan had been ordered. */
    order?: Order;
    /**
     * Whether this previewed order would exceed the permitted amount of purchases available
     * for this plan for this buyer.
     *
     * Always `false` for plans that do not have purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
interface GetPricePreviewRequest {
    /** ID of plan to preview. */
    planId: string;
    /**
     * Coupon code to apply.
     *
     * See Coupons [to learn more](https://dev.wix.com/api/rest/coupons).
     */
    couponCode?: string | null;
}
interface GetPricePreviewResponse {
    /**
     * @internal
     * @internal
     * @deprecated __Deprecated.__ Use `prices` instead. This property will be removed on September 30, 2022.
     * @replacedBy prices
     * @targetRemovalDate 2022-10-01
     */
    price?: PriceDetails;
    /** Pricing details. */
    prices?: SpannedPrice[];
}
interface ChangeStartDateRequest {
    /** Draft order ID. */
    orderId?: string;
    /** New valid from date (timestamp). */
    startDate?: Date;
}
interface ChangeStartDateResponse {
    /** Updated draft order. */
    order?: Order;
}
interface OrderStartDateChanged {
    /** Order whose `startDate` changed. */
    order?: Order;
}
interface ApplyCouponRequest {
    /** Draft order ID. */
    orderId?: string;
    /** Coupon code to apply. */
    couponCode?: string;
}
interface ApplyCouponResponse {
    /** Order with applied coupon and recalculated tax. */
    order?: Order;
}
interface SetSubmissionRequest {
    /** Order ID. */
    orderId?: string;
    /** Submission ID. */
    submissionId?: string;
}
interface SetSubmissionResponse {
    /** Order with submission id */
    order?: Order;
}
interface OrderPurchased {
    /** Order that was paid for. If a free or an offline order, the order that was created. */
    order?: Order;
}
interface OrderStarted {
    /** Order that reached its `startDate`. */
    order?: Order;
}
/**
 * Triggered at the start of a new payment cycle for an existing order.
 *
 * This webhook does not trigger at the initial start of an offline order.
 */
interface OrderCycleStarted {
    /** Order whose new cycle started. */
    order?: Order;
    /** Number of the payment cycle will be 0 when the order is in the free trial period. In other cases, the cycle number starts from 1. */
    cycleNumber?: number;
}
/** Emitted when a recurring order is canceled for the next payment cycle */
interface OrderAutoRenewCanceled {
    /** Order that is canceled, effective at the end of the current payment cycle. */
    order?: Order;
}
interface OrderEnded {
    /** Order that ended. */
    order?: Order;
}
interface GetOrderRequest {
    /** Order ID. */
    _id: string;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface GetOrderResponse {
    /** Order. */
    order?: Order;
}
interface ListOrdersRequest {
    /** Filter by a buyer's member ID. See [Members to learn more about a site's members](https://dev.wix.com/api/rest/members/members). */
    buyerIds?: string[];
    /** Filter by plan IDs. See [Plans to learn more about pricing plans](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans). */
    planIds?: string[];
    /** Filter by whether or not the auto-renewal of recurring orders was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatus[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatus[];
    /**
     * Number of orders to return. See [Pagination](https://dev.wix.com/api/rest/getting-started/sorting-and-paging#getting-started_sorting-and-paging_paging) for more information.
     *
     * Max: `50`
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `DESC`
     */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface ListOrdersResponse {
    /** List of orders. */
    orders?: Order[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
interface OrdersQueryOrdersRequest {
    /** [See available fields here](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort). */
    query?: QueryV2;
}
interface OrdersQueryOrdersResponse {
    /** Retrieved orders. */
    plans?: Order[];
    /** Paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
interface GetOrdersStatsRequest {
}
interface GetOrdersStatsResponse {
    /** Total number of orders. */
    totalOrderCount?: number;
    /** Number of active orders. */
    activeOrderCount?: number;
}
interface GetAvailableOrderActionsRequest {
    /** Order ID. */
    _id?: string;
}
interface GetAvailableOrderActionsResponse {
    /** Whether the order can be suspended. */
    suspendable?: boolean;
    /** If the order cannot be suspended, a reason is returned here. */
    notSuspendableReason?: ReasonNotSuspendable;
    /** Whether the order can be canceled by the buyer. */
    cancelableByBuyer?: boolean;
}
declare enum ReasonNotSuspendable {
    /** Reason unknown */
    UNDEFINED = "UNDEFINED",
    /** Saved in the database but is awaiting payment. Non-active orders cannot be suspended */
    PENDING = "PENDING",
    /** Trial orders cannot be suspended */
    TRIAL = "TRIAL",
    /** Canceled orders cannot be suspended */
    CANCELED = "CANCELED",
    /** Ended orders cannot be suspended */
    ENDED = "ENDED",
    /** Paid for orders with future start dates cannot be suspended */
    NOT_STARTED = "NOT_STARTED",
    /** Order is already suspended */
    ALREADY_SUSPENDED = "ALREADY_SUSPENDED",
    /** Orders based on recurring payments using older Stripe versions cannot be suspended */
    OLD_STRIPE = "OLD_STRIPE"
}
interface PostponeEndDateRequest {
    /** Order ID. */
    _id: string;
    /**
     * New end date and time.
     *
     * Must be later than the current end date and time.
     */
    endDate: Date;
}
interface PostponeEndDateResponse {
}
interface OrderEndDatePostponed {
    /** Order whose `endDate` was postponed. */
    order?: Order;
}
interface CancelOrderRequest {
    /** Order ID. */
    _id: string;
    /**
     * When the order is canceled.
     *
     * One time orders can only be canceled immediately. Supported values:
     * - `"IMMEDIATELY"`: The order is canceled immediately.
     * - `"NEXT_PAYMENT_DATE"`: The order is canceled at the next payment date.
     */
    effectiveAt: CancellationEffectiveAt;
}
interface CancelOrderResponse {
}
interface MarkAsPaidRequest {
    /** Order ID. */
    _id: string;
}
interface MarkAsPaidResponse {
}
interface OrderMarkedAsPaid {
    /** Order that was marked as paid. */
    order?: Order;
}
interface PauseOrderRequest {
    /** Order ID. */
    _id: string;
}
interface PauseOrderResponse {
}
interface OrderPaused {
    /** Paused order. */
    order?: Order;
}
interface BulkPauseOrderRequest {
    /** List of Order IDs. */
    ids?: string[];
    /** Set to true to return Order entity in response. */
    returnFullEntity?: boolean;
}
interface BulkPauseOrderResponse {
    /** Orders that were paused. */
    results?: BulkOrderResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkOrderResult {
    /** Item metadata */
    itemMetadata?: ItemMetadata;
    /** The order. */
    order?: Order;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface ResumeOrderRequest {
    /** Order ID. */
    _id: string;
}
interface ResumeOrderResponse {
}
interface OrderResumed {
    /** Resumed order. */
    order?: Order;
}
interface BulkResumeOrderRequest {
    /** List of Order IDs. */
    ids?: string[];
    /** Set to true to return Order entity in response. */
    returnFullEntity?: boolean;
}
interface BulkResumeOrderResponse {
    /** Orders that were resumed. */
    results?: BulkOrderResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BuyerNonNullableFields {
    memberId: string;
    contactId: string;
}
interface DurationNonNullableFields {
    unit: PeriodUnit;
}
interface RecurrenceNonNullableFields {
    cycleDuration?: DurationNonNullableFields;
}
interface TaxNonNullableFields {
    name: string;
    includedInPrice: boolean;
    rate: string;
    amount: string;
}
interface CouponNonNullableFields {
    code: string;
    amount: string;
    _id: string;
}
interface PriceDetailsNonNullableFields {
    subscription?: RecurrenceNonNullableFields;
    singlePaymentForDuration?: DurationNonNullableFields;
    subtotal: string;
    discount: string;
    tax?: TaxNonNullableFields;
    total: string;
    planPrice: string;
    currency: string;
    coupon?: CouponNonNullableFields;
}
interface PriceDurationNonNullableFields {
    cycleFrom: number;
}
interface FeeNonNullableFields {
    name: string;
    amount: string;
}
interface PriceNonNullableFields {
    subtotal: string;
    coupon?: CouponNonNullableFields;
    discount: string;
    tax?: TaxNonNullableFields;
    total: string;
    currency: string;
    fees: FeeNonNullableFields[];
    proration: string;
}
interface SpannedPriceNonNullableFields {
    duration?: PriceDurationNonNullableFields;
    price?: PriceNonNullableFields;
}
interface PricingDetailsNonNullableFields {
    subscription?: RecurrenceNonNullableFields;
    singlePaymentForDuration?: DurationNonNullableFields;
    prices: SpannedPriceNonNullableFields[];
}
interface CancellationNonNullableFields {
    cause: CancellationCause;
    effectiveAt: CancellationEffectiveAt;
}
interface PausePeriodNonNullableFields {
    status: Status;
}
interface CurrentCycleNonNullableFields {
    index: number;
}
interface OrderCycleNonNullableFields {
    index: number;
}
interface OrderNonNullableFields {
    _id: string;
    planId: string;
    subscriptionId: string;
    buyer?: BuyerNonNullableFields;
    priceDetails?: PriceDetailsNonNullableFields;
    pricing?: PricingDetailsNonNullableFields;
    type: OrderType;
    orderMethod: OrderMethod;
    status: OrderStatus;
    cancellation?: CancellationNonNullableFields;
    lastPaymentStatus: PaymentStatus;
    pausePeriods: PausePeriodNonNullableFields[];
    currentCycle?: CurrentCycleNonNullableFields;
    cycles: OrderCycleNonNullableFields[];
    planName: string;
    planDescription: string;
    planPrice: string;
    statusNew: OrderStatus;
}
interface MemberGetOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
interface MemberListOrdersResponseNonNullableFields {
    orders: OrderNonNullableFields[];
}
interface CreateOfflineOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
interface GetOfflineOrderPreviewResponseNonNullableFields {
    order?: OrderNonNullableFields;
    purchaseLimitExceeded: boolean;
}
interface GetPricePreviewResponseNonNullableFields {
    price?: PriceDetailsNonNullableFields;
    prices: SpannedPriceNonNullableFields[];
}
interface GetOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
interface ListOrdersResponseNonNullableFields {
    orders: OrderNonNullableFields[];
}
interface BaseEventMetadata {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
interface OrderCanceledEnvelope {
    data: OrderCanceled;
    metadata: EventMetadata;
}
interface OrderCreatedEnvelope {
    entity: Order;
    metadata: EventMetadata;
}
interface OrderUpdatedEnvelope {
    entity: Order;
    metadata: EventMetadata;
}
interface OrderStartDateChangedEnvelope {
    data: OrderStartDateChanged;
    metadata: EventMetadata;
}
interface OrderPurchasedEnvelope {
    data: OrderPurchased;
    metadata: EventMetadata;
}
interface OrderStartedEnvelope {
    data: OrderStarted;
    metadata: EventMetadata;
}
interface OrderCycleStartedEnvelope {
    data: OrderCycleStarted;
    metadata: EventMetadata;
}
interface OrderAutoRenewCanceledEnvelope {
    data: OrderAutoRenewCanceled;
    metadata: EventMetadata;
}
interface OrderEndedEnvelope {
    data: OrderEnded;
    metadata: EventMetadata;
}
interface OrderEndDatePostponedEnvelope {
    data: OrderEndDatePostponed;
    metadata: EventMetadata;
}
interface OrderMarkedAsPaidEnvelope {
    data: OrderMarkedAsPaid;
    metadata: EventMetadata;
}
interface OrderPausedEnvelope {
    data: OrderPaused;
    metadata: EventMetadata;
}
interface OrderResumedEnvelope {
    data: OrderResumed;
    metadata: EventMetadata;
}
interface MemberGetOrderOptions {
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface MemberListOrdersOptions {
    /** Filter by plan IDs. */
    planIds?: string[];
    /** Filter for orders where auto renewal was canceled. */
    autoRenewCanceled?: boolean | null;
    /**
     * Filter by the order status. Supported values:
     * + `DRAFT`: Order has been initiated but payment hasn't been processed yet. The plan isn't yet available for use to the buyer.
     * + `PENDING`: Order has been purchased and its start date is set in the future.
     * + `ACTIVE`: Order has been processed. The plan is available for use.
     * + `PAUSED`: Order, and use of the plan, is [paused](#pauseorder). The order, and use of the plan, can be [resumed](#resumeorder).
     * + `ENDED`: Order has completed its duration and is no longer available for use.
     * + `CANCELED`: Order has been [canceled](#cancelorder).
     */
    orderStatuses?: OrderStatus[];
    /**
     * Key Path to edit
     * ManagementListOrdersOptions.paymentStatuses
     * Production value
     * Filter by payment status.
     * Override
     * Filter by payment status.
     *
     * Supported values:
     * + `PAID`: The last payment was paid.
     * + `REFUNDED`: The last payment was refunded.
     * + `FAILED`: The last payment transaction didn't complete.
     * + `UNPAID`: The last payment wasn't paid.
     * + `PENDING`: Awaiting payment.
     * + `NOT_APPLICABLE`: No payment was necessary. For example, for free plans or free trials.
     * Mark down view
     * Filter by payment status.
     *
     * Supported values:
     *
     * PAID: The last payment was paid.
     * REFUNDED: The last payment was refunded.
     * FAILED: The last payment transaction didn't complete.
     * UNPAID: The last payment wasn't paid.
     * PENDING: Awaiting payment.
     * NOT_APPLICABLE: No payment was necessary. For example, for free plans or free trials.
     */
    paymentStatuses?: PaymentStatus[];
    /**
     * Number of pricing plan orders to return.
     *
     * Default: `50`
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `ASC`
     */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface CreateOfflineOrderOptions {
    /**
     * Start date and time for the ordered plan.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /**
     * Whether the order is paid.
     *
     * Default: `false`
     */
    paid?: boolean | null;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Form submission ID that was submitted together with the order. */
    submissionId?: string | null;
}
interface GetOfflineOrderPreviewOptions {
    /**
     * Start date and time for plan of the previewed order.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
}
interface GetPricePreviewOptions {
    /** Coupon code to apply.  */
    couponCode?: string | null;
}
interface ManagementGetOrderOptions {
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
interface ManagementListOrdersOptions {
    /** Filter by specific member IDs of buyers who ordered a pricing plan. */
    buyerIds?: string[];
    /** Filter by specific IDs of plans that were ordered.  */
    planIds?: string[];
    /** Filter by whether or not the auto-renewal of recurring orders was canceled. */
    autoRenewCanceled?: boolean | null;
    /**
     * Filter by the order status. Supported values:
     * + `DRAFT`: Order has been initiated but payment hasn't been processed yet. The plan isn't yet available for use to the buyer.
     * + `PENDING`: Order has been purchased and its start date is set in the future.
     * + `ACTIVE`: Order has been processed. The plan is available for use.
     * + `PAUSED`: Order, and use of the plan, is [paused](#pauseorder). The order, and use of the plan, can be [resumed](#resumeorder).
     * + `ENDED`: Order has completed its duration and is no longer available for use.
     * + `CANCELED`: Order has been [canceled](#cancelorder).
     */
    orderStatuses?: OrderStatus[];
    /**
     * Filter by payment status.
     *
     * Supported values:
     * + `PAID`: The last payment was paid.
     * + `REFUNDED`: The last payment was refunded.
     * + `FAILED`: The last payment transaction didn't complete.
     * + `UNPAID`: The last payment wasn't paid.
     * + `PENDING`: Awaiting payment.
     * + `NOT_APPLICABLE`: No payment was necessary. For example, for free plans or free trials.
     */
    paymentStatuses?: PaymentStatus[];
    /**
     * Number of pricing plan orders to return.
     *
     * Default: `50`
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `DESC`
     */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}

declare function memberGetOrder$1(httpClient: HttpClient): MemberGetOrderSignature;
interface MemberGetOrderSignature {
    /**
     * Gets an order by ID for the currently logged-in member.
     *
     * The `memberGetOrder()` function returns a Promise that resolves to information about a specified order for the currently logged-in member.
     * @param - Order ID.
     * @param - Options for getting a logged-in member's order.
     * @returns Requested order.
     */
    (_id: string, options?: MemberGetOrderOptions | undefined): Promise<Order & OrderNonNullableFields>;
}
declare function memberListOrders$1(httpClient: HttpClient): MemberListOrdersSignature;
interface MemberListOrdersSignature {
    /**
     * Lists orders for the currently logged-in member.
     *
     * The `memberListOrders()` function returns a Promise that resolves to a list of up to 100 pricing plan orders.
     * @param - Filtering, sorting, and pagination options.
     */
    (options?: MemberListOrdersOptions | undefined): Promise<MemberListOrdersResponse & MemberListOrdersResponseNonNullableFields>;
}
declare function requestCancellation$1(httpClient: HttpClient): RequestCancellationSignature;
interface RequestCancellationSignature {
    /**
     * Starts the process of canceling an order.
     *
     *
     * The `requestCancellation()` function returns a Promise that resolves when the order cancellation is successfully requested.
     *
     * For orders with recurring payments, a cancellation can be set to occur either immediately or at the next payment date. For orders with one-time payments, a cancellation occurs immediately after the request is processed.
     *
     * Requesting an order cancellation starts the cancellation process. There may be some operations that continue to be processed before the status of the order is changed to `"CANCELED"`. For example, payments might need to be refunded before the order is fully canceled.
     *
     * #### Canceling during the free trial period.
     *
     * When a buyer cancels their order during the free trial period, the buyer's subscription expires at the end of the free trial period and they won't be billed. The buyer may continue using the benefits until the end of the free trial period.
     *
     * @param - Order ID.
     * @param - Whether to cancel the order immediately or at the next payment date.
     * One-time payment orders can only be canceled immediately.
     *
     * Supported values:
     * - `"IMMEDIATELY"`: Indicates that the order should be canceled immediately.
     * - `"NEXT_PAYMENT_DATE"`: Indicates that the order be canceled at the next payment date.
     * @param - Options for requesting a cancellation.
     * @returns Fulfilled - When the cancellation process is started.
     */
    (_id: string, effectiveAt: CancellationEffectiveAt): Promise<void>;
}
declare function createOfflineOrder$1(httpClient: HttpClient): CreateOfflineOrderSignature;
interface CreateOfflineOrderSignature {
    /**
     * Creates an order for a buyer who purchased the plan with an offline transaction.
     *
     * The `createOfflineOrder()` function returns a Promise that resolves to an `order` object when the order has been created.
     *
     * Payment of an offline order is handled in 1 of 2 ways.
     * - When creating the order, select `true` in the `paid` request parameter.
     * - After creation, with the [`markAsPaid()`](#markaspaid) function.
     *
     * When creating a non-free offline order:
     * - The order's status is set to `"PENDING"` if the start date is in the future. Otherwise, the status is set to `"ACTIVE"`.
     * The order's last payment status is set to `"UNPAID"` or `"PAID"`.
     *
     * When creating a free offline order:
     * - The order's status is set to `"PENDING"` if the start date is in the future. Otherwise, the status is set to `"ACTIVE"`.
     * - The order's last payment status is set to `"NOT_APPLICABLE"`.
     * @param - ID of the member ordering the plan.
     * @param - Options for creating an offline order.
     * @param - ID of the plan being ordered. See [Plans for more information about plan IDs](plans)
     * @returns Fulfilled - The order of the plan.
     */
    (planId: string, memberId: string, options?: CreateOfflineOrderOptions | undefined): Promise<CreateOfflineOrderResponse & CreateOfflineOrderResponseNonNullableFields>;
}
declare function getOfflineOrderPreview$1(httpClient: HttpClient): GetOfflineOrderPreviewSignature;
interface GetOfflineOrderPreviewSignature {
    /**
     * Provides a preview of an offline order as if it was purchased.
     *
     * The `getOfflineOrderPreview()` function returns a Promise that resolves to a temporary preview of the offline order.
     *
     * The preview uses the same logic as purchasing a plan, but the preview is not saved. Because an order is not actually created, the preview's `_id` and `subscriptionId` properties are displayed as a string of multiple zero characters (`000000-0000`).
     *
     * If [taxes are configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection) for the site, taxes are applied to the preview. If not, `tax` previews as `null`.
     *
     * You can preview the order to check purchase limitations, but the limitations are not enforced for the preview. If a pricing plan has a limit on the amount of purchases per buyer, that limit is not considered for generating the preview. But, if that limit has been reached and this order would then exceed the amount of purchases permitted for this buyer, then `purchaseLimitExceeded` will return as `true`. Thus function is not available to the buyer. You specify the member ID for the buyer whose order should be previewed. To get a general price preview for a plan that's not buyer-specific, use the [`getPricePreview()`](#getpricepreview) function.
     * @param - Member ID of the buyer the previewed order is for.
     * @param - Options for previewing the offline order.
     * @param - ID of the plan of the previewed order.
     * @returns Fulfilled - A preview of the order.
     */
    (planId: string, memberId: string, options?: GetOfflineOrderPreviewOptions | undefined): Promise<GetOfflineOrderPreviewResponse & GetOfflineOrderPreviewResponseNonNullableFields>;
}
declare function getPricePreview$1(httpClient: HttpClient): GetPricePreviewSignature;
interface GetPricePreviewSignature {
    /**
     * Retrieves a preview of an order's pricing as if it was purchased.
     *
     * The `getPricePreview()` function returns a Promise that resolves to a temporary preview of the order's price.
     *
     * The price preview uses the same logic for calculating prices as used when purchasing a plan, but the preview is not saved. If [taxes are configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection) for the site, taxes are applied to the preview. If not, the `tax` previews as `null`.
     *
     * Buyers do not have to be logged in to preview the price, as such, the details returned by this function are not buyer-specific. To generate a preview of a purchase for a specific-buyer, use the [`getOfflineOrderPreview()`](#getofflineorderpreview).
     * @param - ID of plan to preview.
     * @param - Options for getting a price preview.
     * @returns Fulfilled - A preview of the pricing for the order.
     */
    (planId: string, options?: GetPricePreviewOptions | undefined): Promise<GetPricePreviewResponse & GetPricePreviewResponseNonNullableFields>;
}
declare function managementGetOrder$1(httpClient: HttpClient): ManagementGetOrderSignature;
interface ManagementGetOrderSignature {
    /**
     * Retrieves an order by ID.
     *
     * The `managementGetOrder()` function returns a Promise that resolves to information about the specified order.
     * @param - Order ID.
     * @param - Options to use when getting an order.
     */
    (_id: string, options?: ManagementGetOrderOptions | undefined): Promise<GetOrderResponse & GetOrderResponseNonNullableFields>;
}
declare function managementListOrders$1(httpClient: HttpClient): ManagementListOrdersSignature;
interface ManagementListOrdersSignature {
    /**
     * Lists pricing plan orders.
     *
     * The `managementListOrders()` function returns a Promise that resolves to a list of up to 50 pricing plan orders. You can specify options for filtering, sorting, and paginating the results.
     *
     * This function returns the orders on the site. To list orders for the currently logged-in member, use [`memberListOrders()`](#memberlistorders).
     * @param - Filtering, sorting, and pagination options.
     */
    (options?: ManagementListOrdersOptions | undefined): Promise<ListOrdersResponse & ListOrdersResponseNonNullableFields>;
}
declare function postponeEndDate$1(httpClient: HttpClient): PostponeEndDateSignature;
interface PostponeEndDateSignature {
    /**
     * Extends the duration of a pricing plan order by postponing the order's `endDate`.
     *
     * The `postponeEndDate()` function returns a Promise that resolves when the order's end date is successfully changed.
     *
     * The new end date and time must be later than the order's current `endDate`.
     *
     * Postponing the end date of an order does not impact payments. For example, if the pricing plan is for a membership to an online lecture series, and you want to extend the duration of the series because the lecturer could not attend some sessions, you can postpone the end date of the orders for all relevant participants. The participants will not be billed additionally.
     *
     * Postponing an order causes the following changes:
     * - The `endDate` for the order is adjusted to the new end date.
     * @param - Order ID.
     * @param - New end date and time.
     *
     * Must be later than the current end date and time.
     * @param - Options for postponing the end date of an order.
     * @returns Fulfilled - When the order's end date has been postponed or made earlier.
     */
    (_id: string, endDate: Date): Promise<void>;
}
declare function cancelOrder$1(httpClient: HttpClient): CancelOrderSignature;
interface CancelOrderSignature {
    /**
     * Cancels an existing order.
     *
     * The `cancelOrder()` function returns a Promise that resolves when the order is successfully canceled.
     *
     * For orders with recurring payments, a cancellation can be set to occur either `IMMEDIATELY` or at the `NEXT_PAYMENT_DATE`.
     * For orders with one-time payments, a cancellation occurs `IMMEDIATELY`.
     *
     * Canceling an order changes the order status to `CANCELED`.
     *
     * #### Canceling during the free trial period.
     *
     * When a site owner cancels an ordered plan during the free trial period, they choose to apply the cancellation `IMMEDIATELY` or at the `NEXT_PAYMENT_DATE`.
     *
     * Canceling `IMMEDIATELY` will end the subscription for the buyer
     * immediately, even during the free trial period and the buyer won't be billed.
     *
     * Canceling at the `NEXT_PAYMENT_DATE` allows the buyer to continue using the benefits of the subscription until the end of the free trial period. Then, the subscription ends and the buyer is not billed.
     * @param - Order ID.
     * @param - When the order is canceled.
     *
     * One time orders can only be canceled immediately. Supported values:
     * - `"IMMEDIATELY"`: The order is canceled immediately.
     * - `"NEXT_PAYMENT_DATE"`: The order is canceled at the next payment date.
     * @param - Options for canceling orders.
     * @returns Fulfilled - When the order is canceled.
     */
    (_id: string, effectiveAt: CancellationEffectiveAt): Promise<void>;
}
declare function markAsPaid$1(httpClient: HttpClient): MarkAsPaidSignature;
interface MarkAsPaidSignature {
    /**
     * Marks an offline order as paid.
     *
     * The `markAsPaid()` function returns a Promise that resolves when the offline order is successfully marked as paid.
     *
     * The entire order is marked as paid, even if the order's payments are recurring.
     *
     * >**Note:** Marking separate payment cycles as paid is not yet supported. Subsequent offline payments do trigger events and emails, but are not registered as additional offline payments.
     *
     * Marking an offline order as paid causes the following changes:
     * - The order's `lastPaymentStatus` changes to `"PAID"`.
     * - The order's status changes to either `"PENDING"` or `"ACTIVE"`, depending on the order's `startDate`.
     *
     * An error occurs if you attempt to:
     * - Mark an already-paid, offline order as paid. You cannot make an offline order as paid twice.
     * - Mark an online order as paid. The `markAsPaid()` function is supported for offline orders only.
     * @param - Order ID.
     * @returns Fulfilled - When the order is marked as paid.
     */
    (_id: string): Promise<void>;
}
declare function pauseOrder$1(httpClient: HttpClient): PauseOrderSignature;
interface PauseOrderSignature {
    /**
     * Pauses a pricing plan order.
     *
     * The `pauseOrder()` function returns a Promise that resolves when the order is successfully paused.
     *
     * For orders with recurring payments, `pauseOrder()` also pauses the payment schedule. Buyers are not charged when an order is paused. Use `pauseOrder()`, for example, if the buyer is away and would like to put their pricing plan membership on hold until they return. Pausing an order affects the end date of the order by adding the time the order is paused to the `endDate`. You can only pause orders with an `"ACTIVE`" status.
     *
     * Pausing an order causes the following changes:
     * - The order status changes to `"PAUSED"`.
     * - The `pausePeriods` array is updated.
     *
     * The `endDate` and the `earliestEndDate` for the order are adjusted to include the pause period when the order is resumed.
     *
     * Paused orders can be continued with the [`resumeOrder()`](#resumeorder) function.
     * @param - Order ID.
     * @returns Fulfilled - When the order is paused.
     */
    (_id: string): Promise<void>;
}
declare function resumeOrder$1(httpClient: HttpClient): ResumeOrderSignature;
interface ResumeOrderSignature {
    /**
     * Resumes a paused pricing plan order.
     *
     * The `resumeOrder()` function returns a Promise that resolves when a paused order is successfully resumed.
     *
     * For orders with recurring payments, `resumeOrder()` also restarts the payment schedule.
     *
     * Resuming an order causes the following changes:
     * - The order status changes to `"ACTIVE"`.
     * - The `pausePeriods` array is updated.
     * - The `endDate` for the order is adjusted to include the pause period.
     * - The `earliestEndDate` is adjusted to include the pause period. (This property is reserved for future use).
     * @param - Order ID.
     * @returns Fulfilled - When the order is resumed.
     */
    (_id: string): Promise<void>;
}
declare const onOrderCanceled$1: EventDefinition$1<OrderCanceledEnvelope, "wix.pricing_plans.v2.order_canceled">;
declare const onOrderCreated$1: EventDefinition$1<OrderCreatedEnvelope, "wix.pricing_plans.v2.order_created">;
declare const onOrderUpdated$1: EventDefinition$1<OrderUpdatedEnvelope, "wix.pricing_plans.v2.order_updated">;
declare const onOrderStartDateChanged$1: EventDefinition$1<OrderStartDateChangedEnvelope, "wix.pricing_plans.v2.order_start_date_changed">;
declare const onOrderPurchased$1: EventDefinition$1<OrderPurchasedEnvelope, "wix.pricing_plans.v2.order_purchased">;
declare const onOrderStarted$1: EventDefinition$1<OrderStartedEnvelope, "wix.pricing_plans.v2.order_started">;
declare const onOrderCycleStarted$1: EventDefinition$1<OrderCycleStartedEnvelope, "wix.pricing_plans.v2.order_cycle_started">;
declare const onOrderAutoRenewCanceled$1: EventDefinition$1<OrderAutoRenewCanceledEnvelope, "wix.pricing_plans.v2.order_auto_renew_canceled">;
declare const onOrderEnded$1: EventDefinition$1<OrderEndedEnvelope, "wix.pricing_plans.v2.order_ended">;
declare const onOrderEndDatePostponed$1: EventDefinition$1<OrderEndDatePostponedEnvelope, "wix.pricing_plans.v2.order_end_date_postponed">;
declare const onOrderMarkedAsPaid$1: EventDefinition$1<OrderMarkedAsPaidEnvelope, "wix.pricing_plans.v2.order_marked_as_paid">;
declare const onOrderPaused$1: EventDefinition$1<OrderPausedEnvelope, "wix.pricing_plans.v2.order_paused">;
declare const onOrderResumed$1: EventDefinition$1<OrderResumedEnvelope, "wix.pricing_plans.v2.order_resumed">;

type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare function createEventModule<T extends EventDefinition<any, string>>(eventDefinition: T): BuildEventDefinition<T> & T;

declare const memberGetOrder: MaybeContext<BuildRESTFunction<typeof memberGetOrder$1> & typeof memberGetOrder$1>;
declare const memberListOrders: MaybeContext<BuildRESTFunction<typeof memberListOrders$1> & typeof memberListOrders$1>;
declare const requestCancellation: MaybeContext<BuildRESTFunction<typeof requestCancellation$1> & typeof requestCancellation$1>;
declare const createOfflineOrder: MaybeContext<BuildRESTFunction<typeof createOfflineOrder$1> & typeof createOfflineOrder$1>;
declare const getOfflineOrderPreview: MaybeContext<BuildRESTFunction<typeof getOfflineOrderPreview$1> & typeof getOfflineOrderPreview$1>;
declare const getPricePreview: MaybeContext<BuildRESTFunction<typeof getPricePreview$1> & typeof getPricePreview$1>;
declare const managementGetOrder: MaybeContext<BuildRESTFunction<typeof managementGetOrder$1> & typeof managementGetOrder$1>;
declare const managementListOrders: MaybeContext<BuildRESTFunction<typeof managementListOrders$1> & typeof managementListOrders$1>;
declare const postponeEndDate: MaybeContext<BuildRESTFunction<typeof postponeEndDate$1> & typeof postponeEndDate$1>;
declare const cancelOrder: MaybeContext<BuildRESTFunction<typeof cancelOrder$1> & typeof cancelOrder$1>;
declare const markAsPaid: MaybeContext<BuildRESTFunction<typeof markAsPaid$1> & typeof markAsPaid$1>;
declare const pauseOrder: MaybeContext<BuildRESTFunction<typeof pauseOrder$1> & typeof pauseOrder$1>;
declare const resumeOrder: MaybeContext<BuildRESTFunction<typeof resumeOrder$1> & typeof resumeOrder$1>;

type _publicOnOrderCanceledType = typeof onOrderCanceled$1;
/**
 * Triggered when an order is canceled.
 *
 * This webhook is triggered either immediately or at the end of the current payment cycle, as follows:
 * + If the order is canceled and `effectiveAt` is set to `IMMEDIATELY`, the webhook is triggered immediately when canceled.
 * + If the order is canceled and `effectiveAt` is set to `NEXT_PAYMENT_DATE`, the webhook is triggered at the end of the current payment cycle. In this case, the [Order Auto Renew Canceled Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-auto-renew-canceled-webhook) is triggered immediately.
 */
declare const onOrderCanceled: ReturnType<typeof createEventModule<_publicOnOrderCanceledType>>;

type _publicOnOrderCreatedType = typeof onOrderCreated$1;
/**
 * Triggered when an order is created.
 */
declare const onOrderCreated: ReturnType<typeof createEventModule<_publicOnOrderCreatedType>>;

type _publicOnOrderUpdatedType = typeof onOrderUpdated$1;
/**
 * Triggered when an order is updated.
 *
 * Order Updated Webhook is triggered when any of the following happens:
 * + Order is paid for. [Order Purchased Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-purchased-webhook) is also triggered.
 * + Order reaches its start date or end date. [Order Started Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-started-webhook) and [Order Ended Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-ended-webhook), respectively, are also triggered.
 * + New payment cycle of an order starts. [Order Cycle Started Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-cycle-started-webhook) is also triggered.
 * + Offline order is marked as paid. [Order Marked As Paid Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-marked-as-paid-webhook) is also triggered.
 * + End date of the order is postponed. [Order End Date Postponed Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-end-date-postponed-webhook) is also triggered
 * + Order is paused, or a paused order is resumed. [Order Paused Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-paused-webhook)
 * and [Order Resumed Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-resumed-webhook), respectively, are also triggered.
 * + Order is canceled, either immediately or at the end of the payment cycle. [Order Canceled Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-canceled-webhook)
 * and [Order Auto Renew Canceled Webhook](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-auto-renew-canceled-webhook) are also triggered.
 */
declare const onOrderUpdated: ReturnType<typeof createEventModule<_publicOnOrderUpdatedType>>;

type _publicOnOrderStartDateChangedType = typeof onOrderStartDateChanged$1;
/**
 * Triggered when an order's `startDate` is changed.
 */
declare const onOrderStartDateChanged: ReturnType<typeof createEventModule<_publicOnOrderStartDateChangedType>>;

type _publicOnOrderPurchasedType = typeof onOrderPurchased$1;
/**
 * Triggered when an order is purchased.
 *
 * This webhook is triggered for any of the following events:
 * + Order is paid in full.
 * + At least 1 order cycle payment is paid for.
 * + Offline order is created, even if not yet marked as paid.
 * + Free order is created.
 */
declare const onOrderPurchased: ReturnType<typeof createEventModule<_publicOnOrderPurchasedType>>;

type _publicOnOrderStartedType = typeof onOrderStarted$1;
/**
 * Triggered when an order reaches its `startDate`. Applies to both purchased and free orders.
 */
declare const onOrderStarted: ReturnType<typeof createEventModule<_publicOnOrderStartedType>>;

type _publicOnOrderCycleStartedType = typeof onOrderCycleStarted$1;
/**
 * Triggered at the start of a new payment cycle for an existing order.
 *
 * This webhook is not triggered at the initial start of an offline order.
 */
declare const onOrderCycleStarted: ReturnType<typeof createEventModule<_publicOnOrderCycleStartedType>>;

type _publicOnOrderAutoRenewCanceledType = typeof onOrderAutoRenewCanceled$1;
/**
 * Triggered when an order is canceled and `effectiveAt` is set to `NEXT_PAYMENT_DATE`.
 *
 * This webhook is *not* triggered in the following scenarios:
 * + When an order is canceled and `effectiveAt` is set to `IMMEDIATELY`. Instead, at the time of cancellation, [Order Canceled](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-canceled-webhook) is triggered.
 * + When an order expires at the end of the current payment cycle because it was canceled and `effectiveAt` was set to `NEXT_PAYMENT_DATE`. Instead, at the time of expiration, [Order Canceled](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-canceled-webhook) and [Order Ended](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/order-ended-webhook) are triggered.
 */
declare const onOrderAutoRenewCanceled: ReturnType<typeof createEventModule<_publicOnOrderAutoRenewCanceledType>>;

type _publicOnOrderEndedType = typeof onOrderEnded$1;
/**
 * Triggered when an order ends.
 *
 * This webhook is triggered:
 * + When an order expires at the end of the current payment cycle.
 * + When an order is canceled and `effectiveAt` is set to `IMMEDIATELY`..
 */
declare const onOrderEnded: ReturnType<typeof createEventModule<_publicOnOrderEndedType>>;

type _publicOnOrderEndDatePostponedType = typeof onOrderEndDatePostponed$1;
/**
 * Triggered when an order's `endDate` is postponed.
 */
declare const onOrderEndDatePostponed: ReturnType<typeof createEventModule<_publicOnOrderEndDatePostponedType>>;

type _publicOnOrderMarkedAsPaidType = typeof onOrderMarkedAsPaid$1;
/**
 * Triggered when an offline order is marked as paid.
 */
declare const onOrderMarkedAsPaid: ReturnType<typeof createEventModule<_publicOnOrderMarkedAsPaidType>>;

type _publicOnOrderPausedType = typeof onOrderPaused$1;
/**
 * Triggered when an order is paused.
 */
declare const onOrderPaused: ReturnType<typeof createEventModule<_publicOnOrderPausedType>>;

type _publicOnOrderResumedType = typeof onOrderResumed$1;
/**
 * Triggered when a paused order is resumed.
 */
declare const onOrderResumed: ReturnType<typeof createEventModule<_publicOnOrderResumedType>>;

export { type ActionEvent, type ApplicationError, type ApplyCouponRequest, type ApplyCouponResponse, type BaseEventMetadata, type BulkActionMetadata, type BulkOrderResult, type BulkPauseOrderRequest, type BulkPauseOrderResponse, type BulkResumeOrderRequest, type BulkResumeOrderResponse, type Buyer, type CancelOrderRequest, type CancelOrderResponse, type Cancellation, CancellationCause, CancellationEffectiveAt, type Captcha, type ChangeStartDateRequest, type ChangeStartDateResponse, type Coupon, type CouponsError, type CreateExternalOrderRequest, type CreateExternalOrderResponse, type CreateGuestOnlineOrderRequest, type CreateGuestOnlineOrderResponse, type CreateOfflineOrderOptions, type CreateOfflineOrderRequest, type CreateOfflineOrderResponse, type CreateOfflineOrderResponseNonNullableFields, type CreateOnlineOrderRequest, type CreateOnlineOrderResponse, type CurrentCycle, type CursorPaging, type Cursors, type DomainEvent, type DomainEventBodyOneOf, type Duration, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventMetadata, type Fee, type FormData, type GetAvailableOrderActionsRequest, type GetAvailableOrderActionsResponse, type GetGuestOnlineOrderPreviewRequest, type GetGuestOnlineOrderPreviewResponse, type GetOfflineOrderPreviewOptions, type GetOfflineOrderPreviewRequest, type GetOfflineOrderPreviewResponse, type GetOfflineOrderPreviewResponseNonNullableFields, type GetOnlineOrderPreviewRequest, type GetOnlineOrderPreviewResponse, type GetOrderRequest, type GetOrderResponse, type GetOrderResponseNonNullableFields, type GetOrdersStatsRequest, type GetOrdersStatsResponse, type GetPricePreviewOptions, type GetPricePreviewRequest, type GetPricePreviewResponse, type GetPricePreviewResponseNonNullableFields, type Guest, type IdentificationData, type IdentificationDataIdOneOf, type ItemMetadata, type ListOrdersRequest, type ListOrdersResponse, type ListOrdersResponseNonNullableFields, type ManagementGetOrderOptions, type ManagementListOrdersOptions, type MarkAsPaidRequest, type MarkAsPaidResponse, type MemberGetOrderOptions, type MemberGetOrderRequest, type MemberGetOrderResponse, type MemberGetOrderResponseNonNullableFields, type MemberListOrdersOptions, type MemberListOrdersRequest, type MemberListOrdersResponse, type MemberListOrdersResponseNonNullableFields, type MessageEnvelope, type OnBehalf, type Order, type OrderAutoRenewCanceled, type OrderAutoRenewCanceledEnvelope, type OrderCanceled, type OrderCanceledEnvelope, type OrderCreatedEnvelope, type OrderCycle, type OrderCycleStarted, type OrderCycleStartedEnvelope, type OrderEndDatePostponed, type OrderEndDatePostponedEnvelope, type OrderEnded, type OrderEndedEnvelope, type OrderMarkedAsPaid, type OrderMarkedAsPaidEnvelope, OrderMethod, type OrderNonNullableFields, type OrderPaused, type OrderPausedEnvelope, type OrderPurchased, type OrderPurchasedEnvelope, type OrderResumed, type OrderResumedEnvelope, type OrderStartDateChanged, type OrderStartDateChangedEnvelope, type OrderStarted, type OrderStartedEnvelope, OrderStatus, OrderType, type OrderUpdatedEnvelope, type OrdersQueryOrdersRequest, type OrdersQueryOrdersResponse, type Paging, type PagingMetadataV2, type PauseOrderRequest, type PauseOrderResponse, type PausePeriod, PaymentStatus, PeriodUnit, type PostponeEndDateRequest, type PostponeEndDateResponse, type Price, type PriceDetails, type PriceDetailsPricingModelOneOf, type PriceDuration, type PricingDetails, type PricingDetailsPricingModelOneOf, type QueryOrdersRequest, type QueryOrdersResponse, type QueryV2, type QueryV2PagingMethodOneOf, ReasonNotSuspendable, type Recurrence, type RequestCancellationRequest, type RequestCancellationResponse, type RestoreInfo, type ResumeOrderRequest, type ResumeOrderResponse, Set, type SetSubmissionRequest, type SetSubmissionResponse, SortOrder, type Sorting, type SpannedPrice, Status, type Tax, WebhookIdentityType, type _publicOnOrderAutoRenewCanceledType, type _publicOnOrderCanceledType, type _publicOnOrderCreatedType, type _publicOnOrderCycleStartedType, type _publicOnOrderEndDatePostponedType, type _publicOnOrderEndedType, type _publicOnOrderMarkedAsPaidType, type _publicOnOrderPausedType, type _publicOnOrderPurchasedType, type _publicOnOrderResumedType, type _publicOnOrderStartDateChangedType, type _publicOnOrderStartedType, type _publicOnOrderUpdatedType, cancelOrder, createOfflineOrder, getOfflineOrderPreview, getPricePreview, managementGetOrder, managementListOrders, markAsPaid, memberGetOrder, memberListOrders, onOrderAutoRenewCanceled, onOrderCanceled, onOrderCreated, onOrderCycleStarted, onOrderEndDatePostponed, onOrderEnded, onOrderMarkedAsPaid, onOrderPaused, onOrderPurchased, onOrderResumed, onOrderStartDateChanged, onOrderStarted, onOrderUpdated, pauseOrder, postponeEndDate, onOrderAutoRenewCanceled$1 as publicOnOrderAutoRenewCanceled, onOrderCanceled$1 as publicOnOrderCanceled, onOrderCreated$1 as publicOnOrderCreated, onOrderCycleStarted$1 as publicOnOrderCycleStarted, onOrderEndDatePostponed$1 as publicOnOrderEndDatePostponed, onOrderEnded$1 as publicOnOrderEnded, onOrderMarkedAsPaid$1 as publicOnOrderMarkedAsPaid, onOrderPaused$1 as publicOnOrderPaused, onOrderPurchased$1 as publicOnOrderPurchased, onOrderResumed$1 as publicOnOrderResumed, onOrderStartDateChanged$1 as publicOnOrderStartDateChanged, onOrderStarted$1 as publicOnOrderStarted, onOrderUpdated$1 as publicOnOrderUpdated, requestCancellation, resumeOrder };
