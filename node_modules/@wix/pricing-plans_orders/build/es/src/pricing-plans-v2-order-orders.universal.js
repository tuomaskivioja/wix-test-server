import { transformError as sdkTransformError } from '@wix/sdk-runtime/transform-error';
import { renameKeysFromSDKRequestToRESTRequest, renameKeysFromRESTResponseToSDKResponse, } from '@wix/sdk-runtime/rename-all-nested-keys';
import * as ambassadorWixPricingPlansV2Order from './pricing-plans-v2-order-orders.http';
export var PeriodUnit;
(function (PeriodUnit) {
    PeriodUnit["UNDEFINED"] = "UNDEFINED";
    PeriodUnit["DAY"] = "DAY";
    PeriodUnit["WEEK"] = "WEEK";
    PeriodUnit["MONTH"] = "MONTH";
    PeriodUnit["YEAR"] = "YEAR";
})(PeriodUnit || (PeriodUnit = {}));
export var OrderType;
(function (OrderType) {
    OrderType["UNDEFINED"] = "UNDEFINED";
    /** Payments made by the buyer */
    OrderType["ONLINE"] = "ONLINE";
    /** Payments managed manually by the site owner */
    OrderType["OFFLINE"] = "OFFLINE";
    /** Payments managed externally */
    OrderType["EXTERNAL"] = "EXTERNAL";
})(OrderType || (OrderType = {}));
export var OrderMethod;
(function (OrderMethod) {
    OrderMethod["UNKNOWN"] = "UNKNOWN";
    /** Mail Order / Telephone Order transaction */
    OrderMethod["MOTO"] = "MOTO";
    /** Point of Sale transaction */
    OrderMethod["POS"] = "POS";
})(OrderMethod || (OrderMethod = {}));
export var OrderStatus;
(function (OrderStatus) {
    /** Order status undefined */
    OrderStatus["UNDEFINED"] = "UNDEFINED";
    /** Order created, but hasn't been paid for yet. Filtered out in ListOrders response by default. */
    OrderStatus["DRAFT"] = "DRAFT";
    /** Order has been paid for, but the start date is in the future */
    OrderStatus["PENDING"] = "PENDING";
    /** Order is active */
    OrderStatus["ACTIVE"] = "ACTIVE";
    /** Order is paused until site owner resumes it */
    OrderStatus["PAUSED"] = "PAUSED";
    /** Order has ended */
    OrderStatus["ENDED"] = "ENDED";
    /** Order has been canceled */
    OrderStatus["CANCELED"] = "CANCELED";
})(OrderStatus || (OrderStatus = {}));
export var CancellationCause;
(function (CancellationCause) {
    /** Cancellation initiator undefined */
    CancellationCause["UNDEFINED"] = "UNDEFINED";
    /** Order was canceled by site owner (default if canceled by user or service identity) */
    CancellationCause["OWNER_ACTION"] = "OWNER_ACTION";
    /** Order was canceled by member (default if canceled by member identity) */
    CancellationCause["MEMBER_ACTION"] = "MEMBER_ACTION";
    /** Order was canceled because of payment failure */
    CancellationCause["PAYMENT_FAILURE"] = "PAYMENT_FAILURE";
    /** Order was canceled because of payment setup failure */
    CancellationCause["PAYMENT_SETUP_FAILURE"] = "PAYMENT_SETUP_FAILURE";
    /** Order was cancelled because of an unknown reason. It's not possible to know with certain payment providers (e.g. paypal) */
    CancellationCause["UNKNOWN"] = "UNKNOWN";
})(CancellationCause || (CancellationCause = {}));
export var CancellationEffectiveAt;
(function (CancellationEffectiveAt) {
    /** Cancellation time undefined */
    CancellationEffectiveAt["UNDEFINED"] = "UNDEFINED";
    /** Will cancel the order now, i.e. update validUntil to the current date */
    CancellationEffectiveAt["IMMEDIATELY"] = "IMMEDIATELY";
    /** Will cancel the order at the date when next payment should have been made */
    CancellationEffectiveAt["NEXT_PAYMENT_DATE"] = "NEXT_PAYMENT_DATE";
})(CancellationEffectiveAt || (CancellationEffectiveAt = {}));
export var PaymentStatus;
(function (PaymentStatus) {
    /** Payment status undefined */
    PaymentStatus["UNDEFINED"] = "UNDEFINED";
    /** Payment has been paid */
    PaymentStatus["PAID"] = "PAID";
    /** Payment has been refunded */
    PaymentStatus["REFUNDED"] = "REFUNDED";
    /** Recurring payment has failed */
    PaymentStatus["FAILED"] = "FAILED";
    /** Payment has not been paid */
    PaymentStatus["UNPAID"] = "UNPAID";
    /** Billing has been initialized, but actual charge is yet to be made. Can happen for free trial and PayPal */
    PaymentStatus["PENDING"] = "PENDING";
    /** Used in cases where the plan is free */
    PaymentStatus["NOT_APPLICABLE"] = "NOT_APPLICABLE";
})(PaymentStatus || (PaymentStatus = {}));
export var Status;
(function (Status) {
    Status["UNDEFINED"] = "UNDEFINED";
    /** Order suspension is active */
    Status["ACTIVE"] = "ACTIVE";
    /** Order suspension has ended */
    Status["ENDED"] = "ENDED";
})(Status || (Status = {}));
export var Set;
(function (Set) {
    /** Same behavior as BASIC */
    Set["UNKNOWN_SET"] = "UNKNOWN_SET";
    /**
     * Returns fields of the entity that are available in the database.
     * By default a field is available in the database unless explicitly specified in the documentation
     */
    Set["BASIC"] = "BASIC";
    /**
     * Returns all fields in the entity.
     * This might make additional calls to gather the full entity
     */
    Set["FULL"] = "FULL";
})(Set || (Set = {}));
export var SortOrder;
(function (SortOrder) {
    SortOrder["ASC"] = "ASC";
    SortOrder["DESC"] = "DESC";
})(SortOrder || (SortOrder = {}));
export var WebhookIdentityType;
(function (WebhookIdentityType) {
    WebhookIdentityType["UNKNOWN"] = "UNKNOWN";
    WebhookIdentityType["ANONYMOUS_VISITOR"] = "ANONYMOUS_VISITOR";
    WebhookIdentityType["MEMBER"] = "MEMBER";
    WebhookIdentityType["WIX_USER"] = "WIX_USER";
    WebhookIdentityType["APP"] = "APP";
})(WebhookIdentityType || (WebhookIdentityType = {}));
export var ReasonNotSuspendable;
(function (ReasonNotSuspendable) {
    /** Reason unknown */
    ReasonNotSuspendable["UNDEFINED"] = "UNDEFINED";
    /** Saved in the database but is awaiting payment. Non-active orders cannot be suspended */
    ReasonNotSuspendable["PENDING"] = "PENDING";
    /** Trial orders cannot be suspended */
    ReasonNotSuspendable["TRIAL"] = "TRIAL";
    /** Canceled orders cannot be suspended */
    ReasonNotSuspendable["CANCELED"] = "CANCELED";
    /** Ended orders cannot be suspended */
    ReasonNotSuspendable["ENDED"] = "ENDED";
    /** Paid for orders with future start dates cannot be suspended */
    ReasonNotSuspendable["NOT_STARTED"] = "NOT_STARTED";
    /** Order is already suspended */
    ReasonNotSuspendable["ALREADY_SUSPENDED"] = "ALREADY_SUSPENDED";
    /** Orders based on recurring payments using older Stripe versions cannot be suspended */
    ReasonNotSuspendable["OLD_STRIPE"] = "OLD_STRIPE";
})(ReasonNotSuspendable || (ReasonNotSuspendable = {}));
/**
 * Gets an order by ID for the currently logged-in member.
 *
 * The `memberGetOrder()` function returns a Promise that resolves to information about a specified order for the currently logged-in member.
 * @param _id - Order ID.
 * @public
 * @requiredField _id
 * @param options - Options for getting a logged-in member's order.
 * @permissionId PRICING_PLANS.READ_OWN_ORDERS
 * @applicableIdentity MEMBER
 * @returns Requested order.
 */
export async function memberGetOrder(_id, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        id: _id,
        fieldSet: options?.fieldSet,
    });
    const reqOpts = ambassadorWixPricingPlansV2Order.memberGetOrder(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data)?.order;
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: { id: '$[0]', fieldSet: '$[1].fieldSet' },
            singleArgumentUnchanged: false,
        }, ['_id', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Lists orders for the currently logged-in member.
 *
 * The `memberListOrders()` function returns a Promise that resolves to a list of up to 100 pricing plan orders.
 * @public
 * @documentationMaturity preview
 * @param options - Filtering, sorting, and pagination options.
 * @permissionId PRICING_PLANS.READ_OWN_ORDERS
 * @applicableIdentity MEMBER
 */
export async function memberListOrders(options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[1];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        planIds: options?.planIds,
        autoRenewCanceled: options?.autoRenewCanceled,
        orderStatuses: options?.orderStatuses,
        paymentStatuses: options?.paymentStatuses,
        limit: options?.limit,
        offset: options?.offset,
        sorting: options?.sorting,
        fieldSet: options?.fieldSet,
    });
    const reqOpts = ambassadorWixPricingPlansV2Order.memberListOrders(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                planIds: '$[0].planIds',
                autoRenewCanceled: '$[0].autoRenewCanceled',
                orderStatuses: '$[0].orderStatuses',
                paymentStatuses: '$[0].paymentStatuses',
                limit: '$[0].limit',
                offset: '$[0].offset',
                sorting: '$[0].sorting',
                fieldSet: '$[0].fieldSet',
            },
            singleArgumentUnchanged: false,
        }, ['options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Starts the process of canceling an order.
 *
 *
 * The `requestCancellation()` function returns a Promise that resolves when the order cancellation is successfully requested.
 *
 * For orders with recurring payments, a cancellation can be set to occur either immediately or at the next payment date. For orders with one-time payments, a cancellation occurs immediately after the request is processed.
 *
 * Requesting an order cancellation starts the cancellation process. There may be some operations that continue to be processed before the status of the order is changed to `"CANCELED"`. For example, payments might need to be refunded before the order is fully canceled.
 *
 * #### Canceling during the free trial period.
 *
 * When a buyer cancels their order during the free trial period, the buyer's subscription expires at the end of the free trial period and they won't be billed. The buyer may continue using the benefits until the end of the free trial period.
 *
 * @param _id - Order ID.
 * @param effectiveAt - Whether to cancel the order immediately or at the next payment date.
 * One-time payment orders can only be canceled immediately.
 *
 * Supported values:
 * - `"IMMEDIATELY"`: Indicates that the order should be canceled immediately.
 * - `"NEXT_PAYMENT_DATE"`: Indicates that the order be canceled at the next payment date.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @requiredField effectiveAt
 * @param options - Options for requesting a cancellation.
 * @permissionId PRICING_PLANS.MANAGE_OWN_ORDERS
 * @applicableIdentity MEMBER
 * @returns Fulfilled - When the cancellation process is started.
 */
export async function requestCancellation(_id, effectiveAt) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        id: _id,
        effectiveAt: effectiveAt,
    });
    const reqOpts = ambassadorWixPricingPlansV2Order.requestCancellation(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: { id: '$[0]', effectiveAt: '$[1]' },
            singleArgumentUnchanged: false,
        }, ['_id', 'effectiveAt']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Creates an order for a buyer who purchased the plan with an offline transaction.
 *
 * The `createOfflineOrder()` function returns a Promise that resolves to an `order` object when the order has been created.
 *
 * Payment of an offline order is handled in 1 of 2 ways.
 * - When creating the order, select `true` in the `paid` request parameter.
 * - After creation, with the [`markAsPaid()`](#markaspaid) function.
 *
 * When creating a non-free offline order:
 * - The order's status is set to `"PENDING"` if the start date is in the future. Otherwise, the status is set to `"ACTIVE"`.
 * The order's last payment status is set to `"UNPAID"` or `"PAID"`.
 *
 * When creating a free offline order:
 * - The order's status is set to `"PENDING"` if the start date is in the future. Otherwise, the status is set to `"ACTIVE"`.
 * - The order's last payment status is set to `"NOT_APPLICABLE"`.
 * @param memberId - ID of the member ordering the plan.
 * @public
 * @documentationMaturity preview
 * @requiredField memberId
 * @requiredField planId
 * @param options - Options for creating an offline order.
 * @param planId - ID of the plan being ordered. See [Plans for more information about plan IDs](plans)
 * @permissionId PRICING_PLANS.REGISTER_OFFLINE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns Fulfilled - The order of the plan.
 */
export async function createOfflineOrder(planId, memberId, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[3];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        planId: planId,
        memberId: memberId,
        startDate: options?.startDate,
        paid: options?.paid,
        couponCode: options?.couponCode,
        submissionId: options?.submissionId,
    });
    const reqOpts = ambassadorWixPricingPlansV2Order.createOfflineOrder(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                planId: '$[0]',
                memberId: '$[1]',
                startDate: '$[2].startDate',
                paid: '$[2].paid',
                couponCode: '$[2].couponCode',
                submissionId: '$[2].submissionId',
            },
            singleArgumentUnchanged: false,
        }, ['planId', 'memberId', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Provides a preview of an offline order as if it was purchased.
 *
 * The `getOfflineOrderPreview()` function returns a Promise that resolves to a temporary preview of the offline order.
 *
 * The preview uses the same logic as purchasing a plan, but the preview is not saved. Because an order is not actually created, the preview's `_id` and `subscriptionId` properties are displayed as a string of multiple zero characters (`000000-0000`).
 *
 * If [taxes are configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection) for the site, taxes are applied to the preview. If not, `tax` previews as `null`.
 *
 * You can preview the order to check purchase limitations, but the limitations are not enforced for the preview. If a pricing plan has a limit on the amount of purchases per buyer, that limit is not considered for generating the preview. But, if that limit has been reached and this order would then exceed the amount of purchases permitted for this buyer, then `purchaseLimitExceeded` will return as `true`. Thus function is not available to the buyer. You specify the member ID for the buyer whose order should be previewed. To get a general price preview for a plan that's not buyer-specific, use the [`getPricePreview()`](#getpricepreview) function.
 * @param memberId - Member ID of the buyer the previewed order is for.
 * @public
 * @documentationMaturity preview
 * @requiredField memberId
 * @requiredField planId
 * @param options - Options for previewing the offline order.
 * @param planId - ID of the plan of the previewed order.
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns Fulfilled - A preview of the order.
 */
export async function getOfflineOrderPreview(planId, memberId, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[3];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        planId: planId,
        memberId: memberId,
        startDate: options?.startDate,
        couponCode: options?.couponCode,
    });
    const reqOpts = ambassadorWixPricingPlansV2Order.getOfflineOrderPreview(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                planId: '$[0]',
                memberId: '$[1]',
                startDate: '$[2].startDate',
                couponCode: '$[2].couponCode',
            },
            singleArgumentUnchanged: false,
        }, ['planId', 'memberId', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Retrieves a preview of an order's pricing as if it was purchased.
 *
 * The `getPricePreview()` function returns a Promise that resolves to a temporary preview of the order's price.
 *
 * The price preview uses the same logic for calculating prices as used when purchasing a plan, but the preview is not saved. If [taxes are configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection) for the site, taxes are applied to the preview. If not, the `tax` previews as `null`.
 *
 * Buyers do not have to be logged in to preview the price, as such, the details returned by this function are not buyer-specific. To generate a preview of a purchase for a specific-buyer, use the [`getOfflineOrderPreview()`](#getofflineorderpreview).
 * @param planId - ID of plan to preview.
 * @public
 * @documentationMaturity preview
 * @requiredField planId
 * @param options - Options for getting a price preview.
 * @permissionId PRICING_PLANS.READ_PUBLIC_PLANS
 * @permissionScope Read Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-PLANS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Pricing Plans
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-PLANS
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @returns Fulfilled - A preview of the pricing for the order.
 */
export async function getPricePreview(planId, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        planId: planId,
        couponCode: options?.couponCode,
    });
    const reqOpts = ambassadorWixPricingPlansV2Order.getPricePreview(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                planId: '$[0]',
                couponCode: '$[1].couponCode',
            },
            singleArgumentUnchanged: false,
        }, ['planId', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Retrieves an order by ID.
 *
 * The `managementGetOrder()` function returns a Promise that resolves to information about the specified order.
 * @param _id - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @param options - Options to use when getting an order.
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @applicableIdentity APP
 */
export async function managementGetOrder(_id, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        id: _id,
        fieldSet: options?.fieldSet,
    });
    const reqOpts = ambassadorWixPricingPlansV2Order.managementGetOrder(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: { id: '$[0]', fieldSet: '$[1].fieldSet' },
            singleArgumentUnchanged: false,
        }, ['_id', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Lists pricing plan orders.
 *
 * The `managementListOrders()` function returns a Promise that resolves to a list of up to 50 pricing plan orders. You can specify options for filtering, sorting, and paginating the results.
 *
 * This function returns the orders on the site. To list orders for the currently logged-in member, use [`memberListOrders()`](#memberlistorders).
 * @public
 * @documentationMaturity preview
 * @param options - Filtering, sorting, and pagination options.
 * @permissionId PRICING_PLANS.READ_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.READ-ORDERS
 * @permissionScope Manage Portfolio
 * @permissionScopeId SCOPE.PORTFOLIO.MANAGE-PORTFOLIO
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @applicableIdentity APP
 */
export async function managementListOrders(options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[1];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        buyerIds: options?.buyerIds,
        planIds: options?.planIds,
        autoRenewCanceled: options?.autoRenewCanceled,
        orderStatuses: options?.orderStatuses,
        paymentStatuses: options?.paymentStatuses,
        limit: options?.limit,
        offset: options?.offset,
        sorting: options?.sorting,
        fieldSet: options?.fieldSet,
    });
    const reqOpts = ambassadorWixPricingPlansV2Order.managementListOrders(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                buyerIds: '$[0].buyerIds',
                planIds: '$[0].planIds',
                autoRenewCanceled: '$[0].autoRenewCanceled',
                orderStatuses: '$[0].orderStatuses',
                paymentStatuses: '$[0].paymentStatuses',
                limit: '$[0].limit',
                offset: '$[0].offset',
                sorting: '$[0].sorting',
                fieldSet: '$[0].fieldSet',
            },
            singleArgumentUnchanged: false,
        }, ['options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Extends the duration of a pricing plan order by postponing the order's `endDate`.
 *
 * The `postponeEndDate()` function returns a Promise that resolves when the order's end date is successfully changed.
 *
 * The new end date and time must be later than the order's current `endDate`.
 *
 * Postponing the end date of an order does not impact payments. For example, if the pricing plan is for a membership to an online lecture series, and you want to extend the duration of the series because the lecturer could not attend some sessions, you can postpone the end date of the orders for all relevant participants. The participants will not be billed additionally.
 *
 * Postponing an order causes the following changes:
 * - The `endDate` for the order is adjusted to the new end date.
 * @param _id - Order ID.
 * @param endDate - New end date and time.
 *
 * Must be later than the current end date and time.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @requiredField endDate
 * @param options - Options for postponing the end date of an order.
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns Fulfilled - When the order's end date has been postponed or made earlier.
 *
 *
 */
export async function postponeEndDate(_id, endDate) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        id: _id,
        endDate: endDate,
    });
    const reqOpts = ambassadorWixPricingPlansV2Order.postponeEndDate(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: { id: '$[0]', endDate: '$[1]' },
            singleArgumentUnchanged: false,
        }, ['_id', 'endDate']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Cancels an existing order.
 *
 * The `cancelOrder()` function returns a Promise that resolves when the order is successfully canceled.
 *
 * For orders with recurring payments, a cancellation can be set to occur either `IMMEDIATELY` or at the `NEXT_PAYMENT_DATE`.
 * For orders with one-time payments, a cancellation occurs `IMMEDIATELY`.
 *
 * Canceling an order changes the order status to `CANCELED`.
 *
 * #### Canceling during the free trial period.
 *
 * When a site owner cancels an ordered plan during the free trial period, they choose to apply the cancellation `IMMEDIATELY` or at the `NEXT_PAYMENT_DATE`.
 *
 * Canceling `IMMEDIATELY` will end the subscription for the buyer
 * immediately, even during the free trial period and the buyer won't be billed.
 *
 * Canceling at the `NEXT_PAYMENT_DATE` allows the buyer to continue using the benefits of the subscription until the end of the free trial period. Then, the subscription ends and the buyer is not billed.
 * @param _id - Order ID.
 * @param effectiveAt - When the order is canceled.
 *
 * One time orders can only be canceled immediately. Supported values:
 * - `"IMMEDIATELY"`: The order is canceled immediately.
 * - `"NEXT_PAYMENT_DATE"`: The order is canceled at the next payment date.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @requiredField effectiveAt
 * @param options - Options for canceling orders.
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns Fulfilled - When the order is canceled.
 */
export async function cancelOrder(_id, effectiveAt) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        id: _id,
        effectiveAt: effectiveAt,
    });
    const reqOpts = ambassadorWixPricingPlansV2Order.cancelOrder(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: { id: '$[0]', effectiveAt: '$[1]' },
            singleArgumentUnchanged: false,
        }, ['_id', 'effectiveAt']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Marks an offline order as paid.
 *
 * The `markAsPaid()` function returns a Promise that resolves when the offline order is successfully marked as paid.
 *
 * The entire order is marked as paid, even if the order's payments are recurring.
 *
 * >**Note:** Marking separate payment cycles as paid is not yet supported. Subsequent offline payments do trigger events and emails, but are not registered as additional offline payments.
 *
 * Marking an offline order as paid causes the following changes:
 * - The order's `lastPaymentStatus` changes to `"PAID"`.
 * - The order's status changes to either `"PENDING"` or `"ACTIVE"`, depending on the order's `startDate`.
 *
 * An error occurs if you attempt to:
 * - Mark an already-paid, offline order as paid. You cannot make an offline order as paid twice.
 * - Mark an online order as paid. The `markAsPaid()` function is supported for offline orders only.
 * @param _id - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns Fulfilled - When the order is marked as paid.
 */
export async function markAsPaid(_id) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[1];
    const payload = renameKeysFromSDKRequestToRESTRequest({ id: _id });
    const reqOpts = ambassadorWixPricingPlansV2Order.markAsPaid(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: { id: '$[0]' },
            singleArgumentUnchanged: false,
        }, ['_id']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Pauses a pricing plan order.
 *
 * The `pauseOrder()` function returns a Promise that resolves when the order is successfully paused.
 *
 * For orders with recurring payments, `pauseOrder()` also pauses the payment schedule. Buyers are not charged when an order is paused. Use `pauseOrder()`, for example, if the buyer is away and would like to put their pricing plan membership on hold until they return. Pausing an order affects the end date of the order by adding the time the order is paused to the `endDate`. You can only pause orders with an `"ACTIVE`" status.
 *
 * Pausing an order causes the following changes:
 * - The order status changes to `"PAUSED"`.
 * - The `pausePeriods` array is updated.
 *
 * The `endDate` and the `earliestEndDate` for the order are adjusted to include the pause period when the order is resumed.
 *
 * Paused orders can be continued with the [`resumeOrder()`](#resumeorder) function.
 * @param _id - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns Fulfilled - When the order is paused.
 */
export async function pauseOrder(_id) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[1];
    const payload = renameKeysFromSDKRequestToRESTRequest({ id: _id });
    const reqOpts = ambassadorWixPricingPlansV2Order.pauseOrder(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: { id: '$[0]' },
            singleArgumentUnchanged: false,
        }, ['_id']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Resumes a paused pricing plan order.
 *
 * The `resumeOrder()` function returns a Promise that resolves when a paused order is successfully resumed.
 *
 * For orders with recurring payments, `resumeOrder()` also restarts the payment schedule.
 *
 * Resuming an order causes the following changes:
 * - The order status changes to `"ACTIVE"`.
 * - The `pausePeriods` array is updated.
 * - The `endDate` for the order is adjusted to include the pause period.
 * - The `earliestEndDate` is adjusted to include the pause period. (This property is reserved for future use).
 * @param _id - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @permissionId PRICING_PLANS.MANAGE_ORDERS
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-PAIDPLANS.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns Fulfilled - When the order is resumed.
 */
export async function resumeOrder(_id) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[1];
    const payload = renameKeysFromSDKRequestToRESTRequest({ id: _id });
    const reqOpts = ambassadorWixPricingPlansV2Order.resumeOrder(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: { id: '$[0]' },
            singleArgumentUnchanged: false,
        }, ['_id']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
//# sourceMappingURL=pricing-plans-v2-order-orders.universal.js.map