/**
 * An order object includes all of the details related to the purchase of a Pricing Plan.
 * You can manage existing orders, create offline orders, and preview orders not yet purchased.
 *
 * Orders are based on pricing models based on the payment and duration cycles for each plan. See here to
 * [learn more about pricing models](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/introduction#wix-pricing-plans_pricing-plans_introduction_pricing-models).
 */
export interface Order {
    /**
     * Order ID.
     * @readonly
     */
    id?: string;
    /**
     * ID of the plan purchased with the order. See [Plans for more information about pricing plans](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/introduction).
     * @readonly
     */
    planId?: string;
    /**
     * ID of the related Wix subscription.
     *
     * Every pricing plan order corresponds to a Wix subscription, including orders for single payment plans. See here
     * for a [Pricing Plans overview](https://support.wix.com/en/article/pricing-plans-an-overview#create-plans-to-suit-your-business).
     * @readonly
     */
    subscriptionId?: string;
    /**
     * Wix Pay order ID.
     *
     * Provided by Wix whether the order is created online or offline. The field is omitted when the order is free.
     * @readonly
     */
    wixPayOrderId?: string | null;
    /**
     * The buyer's IDs. Includes `memberId` and `contactId`.
     *
     * Currently, Pricing Plan purchases are limited to members only. `contactId` is returned,
     * but a buyer will not be able to purchase a plan without a `memberId`.
     * @readonly
     */
    buyer?: Buyer;
    /**
     * __Deprecated.__ Use `pricing` instead. This property will be removed on September 30, 2022.
     * @readonly
     * @deprecated __Deprecated.__ Use `pricing` instead. This property will be removed on September 30, 2022.
     * @replacedBy pricing
     * @targetRemovalDate 2022-10-01
     */
    priceDetails?: PriceDetails;
    /**
     * Order pricing model, price, and payment schedule.
     *
     * [Learn more about pricing models](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/introduction#wix-pricing-plans_pricing-plans_introduction_pricing-models).
     * @readonly
     */
    pricing?: PricingDetails;
    /**
     * How the order was processed. One of:
     * + `ONLINE`: The buyer purchased the plan using the site.
     * + `OFFLINE`: The buyer made a manual, offline purchase without using the site.
     * + `EXTERNAL`: The buyer made a purchase through an external payment provider.
     * @readonly
     */
    type?: OrderType;
    /**
     * Status of the order. One of:
     * + `DRAFT`: Order has been initiated but payment hasn't been processed yet. The plan isn't yet available for use to the buyer.
     * + `PENDING`: Order has been purchased and its start date is set in the future.
     * + `ACTIVE`: Order has been processed. The plan is available for use.
     * + `PAUSED`: Order, and use of the plan, is [paused](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/pause-order). The order, and use of the plan, can be [resumed](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/resume-order).
     * + `ENDED`: Order has completed its duration and is no longer available for use.
     * + `CANCELED`: Order has been [canceled](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/cancel-order).
     * @readonly
     */
    status?: OrderStatus;
    /**
     * Whether the order will be canceled at the next payment date.
     *
     * If `true`, the order status will be `CANCELED` and the next payment won't be charged. Omitted for single payment orders.
     * @readonly
     */
    autoRenewCanceled?: boolean | null;
    /**
     * Details about the cancellation of an order.
     *
     * Only present if the status is `CANCELED`.
     * @readonly
     */
    cancellation?: Cancellation;
    /**
     * Status of the last payment for the order.
     * Updated automatically for online orders. Updated manually by the site owner for offline orders. One of:
     * + `PAID`: The last payment was paid.
     * + `REFUNDED`: The last payment was refunded.
     * + `FAILED`: The last payment transaction didn't complete.
     * + `UNPAID`: The last payment wasn't paid.
     * + `PENDING`: Awaiting payment.
     * + `NOT_APPLICABLE`: No payment was necessary. For example, for free plans or free trials.
     * @readonly
     */
    lastPaymentStatus?: PaymentStatus;
    /**
     * Start date and time for the ordered plan.
     * @readonly
     */
    startDate?: Date;
    /**
     * Current end date and time for the ordered plan.
     *
     * `endDate` may be updated over the course of an order. If the order is [paused](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/pause-order),
     * it will have a later `endDate` once it [resumes](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/resume-order). `endDate` may also be [postponed](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/postpone-end-date).
     *
     * Omitted if the order is valid until canceled and still `ACTIVE`.
     * @readonly
     */
    endDate?: Date;
    /**
     * List of periods during which the order is paused.
     * @readonly
     */
    pausePeriods?: PausePeriod[];
    /**
     * Free trial period for the order, in days.
     *
     * Only available for recurring plans.
     * @readonly
     */
    freeTrialDays?: number | null;
    /**
     * Earliest end date and time that the plan for the order can expire.
     *
     * Calculated by using the original end date plus any pause periods. Omitted if the order is active until canceled. Reserved for future use.
     * @readonly
     */
    earliestEndDate?: Date;
    /**
     * Current payment cycle for the order.
     *
     * `currentCycle` will be omitted if the order's status is `CANCELED` or `ENDED`, or if the `startDate` hasn't passed yet.
     * @readonly
     */
    currentCycle?: CurrentCycle;
    /**
     * Plan name at the time of purchase.
     * @readonly
     */
    planName?: string;
    /**
     * Plan description at the time of purchase
     * @readonly
     */
    planDescription?: string;
    /**
     * Plan price as it was at the moment of order creation.
     * @readonly
     */
    planPrice?: string;
    /**
     * Date and time the order was created.
     * @readonly
     */
    createdDate?: Date;
    /**
     * Date and time the order was updated.
     * @readonly
     */
    updatedDate?: Date;
    /**
     * Information about the form submitted during the plan's checkout.
     * @readonly
     */
    formData?: FormData;
}
export interface Buyer {
    /**
     * Member ID for a Wix site member. See [Members to learn more about a site's members](https://dev.wix.com/api/rest/members/members).
     * @readonly
     */
    memberId?: string;
    /**
     * Contact ID for a Wix site contact. See [Contacts to learn more about a site's contacts](https://dev.wix.com/api/rest/contacts/contacts/contacts-v4/contact-object).
     * @readonly
     */
    contactId?: string;
}
export interface PriceDetails extends PriceDetailsPricingModelOneOf {
    /** Order has recurring payments. */
    subscription?: Recurrence;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
    /** Price of the order excluding tax, specified as a monetary amount. for example, `"9.99"`. */
    subtotal?: string;
    /** Total discount applied. */
    discount?: string;
    /** Tax applied. */
    tax?: Tax;
    /**
     * Price after tax and discount is applied, specified as a monetary amount. For example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     */
    total?: string;
    /** Plan price as it was at the moment of order creation. */
    planPrice?: string;
    /** Currency code. Must be valid ISO 4217 currency code (e.g., USD). */
    currency?: string;
    /** Free trial period for the order in days. Only available for recurring plans. */
    freeTrialDays?: number | null;
    /** Coupon applied to the order. Empty means no coupon was applied. */
    coupon?: Coupon;
}
/** @oneof */
export interface PriceDetailsPricingModelOneOf {
    /** Order has recurring payments. */
    subscription?: Recurrence;
    /** One-time payment. Order is valid for a specified duration. */
    singlePaymentForDuration?: Duration;
    /** One-time payment. Order is valid until it is canceled. */
    singlePaymentUnlimited?: boolean | null;
}
export interface Tax {
    /** Name of the tax. For example, VAT. */
    name?: string;
    /** Whether tax is included in the original price. When `false`, tax is added at checkout. */
    includedInPrice?: boolean;
    /** Tax rate percentage, as a number between 0 and 100. For example, a 7% tax rate is `"7.00"`. */
    rate?: string;
    /** Total tax, specified as a monetary amount. For example, `"3.99"`. */
    amount?: string;
}
/** An object specifying how often and for how long payments recur (may be forever). */
export interface Recurrence {
    /** Length of one payment cycle. */
    cycleDuration?: Duration;
    /**
     * Amount of payment cycles this subscription is valid for.
     *
     * `0` for unlimited or until-canceled.
     */
    cycleCount?: number | null;
}
/** A duration expressed in number of time units. */
export interface Duration {
    /** The amount of a duration `unit` in a single payment cycle. */
    count?: number | null;
    /** Unit of time for the cycle duration. */
    unit?: PeriodUnit;
}
export declare enum PeriodUnit {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
export interface Coupon {
    /** Code of the applied coupon. */
    code?: string;
    /** Total discount of the coupon, as a monetary amount. */
    amount?: string;
    /**
     * Coupon ID.
     * @readonly
     */
    id?: string;
}
export interface PricingDetails extends PricingDetailsPricingModelOneOf {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
    /**
     * Pricing details for all pricing models.
     * @readonly
     */
    prices?: SpannedPrice[];
}
/** @oneof */
export interface PricingDetailsPricingModelOneOf {
    /** Pricing model for an order with recurring payment cycles. */
    subscription?: Recurrence;
    /** Pricing model for an order with a one-time payment and the order is valid for a specific amount of time. */
    singlePaymentForDuration?: Duration;
    /** Pricing model for an order with a one-time payment and the order is valid until canceled. */
    singlePaymentUnlimited?: boolean | null;
}
export interface SpannedPrice {
    /**
     * Cycle duration to apply `price` for.
     *
     * Use with all pricing models.
     * Can apply the same price to multiple payment cycles.
     */
    duration?: PriceDuration;
    /** Order price. */
    price?: Price;
}
export interface PriceDuration {
    /**
     * Price starts to apply with this cycle.
     *
     * `1` is the first payment cycle for all pricing models.
     */
    cycleFrom?: number;
    /**
     * Amount of cycles to apply price for.
     *
     * For `subscription` pricing models with a finite number of cycles, the `numberOfCycles` is the same as `pricing.subscription.cycleCount`.
     *
     * For `subscription` pricing models that are unlimited or until-canceled, the `numberOfCycles` is not returned.
     *
     * For `singlePaymentForDuration` and `singlePaymentUnlimited` pricing models, the `numberOfCycles` is `1`.
     */
    numberOfCycles?: number | null;
}
export interface Price {
    /** Price of the order excluding tax, specified as a monetary amount. For example, `"9.99"`. */
    subtotal?: string;
    /**
     * Coupon applied to the order.
     *
     * See Coupons [to learn more about coupons](https://dev.wix.com/api/rest/coupons).
     */
    coupon?: Coupon;
    /** Total discount applied to the order. */
    discount?: string;
    /**
     * Tax applied to the order.
     *
     * Tax is only applied if the site [has it configured](https://support.wix.com/en/article/pricing-plans-setting-up-tax-collection).
     */
    tax?: Tax;
    /**
     * Price after tax and discount is applied. Specified as a monetary amount, for example, `"13.98"`.
     *
     * If no tax is applied, the amount is the same as `subtotal`.
     */
    total?: string;
    /**
     * Three-letter currency code in
     * [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     */
    currency?: string;
    /** Price change after billing date was change and price was adjusted. Could be positive and negative values. */
    proration?: string;
}
export interface Fee {
    /** Fee name */
    name?: string;
    /** Amount of fee to be charged */
    amount?: string;
}
export declare enum OrderType {
    UNDEFINED = "UNDEFINED",
    /** Payments made by the buyer */
    ONLINE = "ONLINE",
    /** Payments managed manually by the site owner */
    OFFLINE = "OFFLINE",
    /** Payments managed externally */
    EXTERNAL = "EXTERNAL"
}
export declare enum OrderMethod {
    UNKNOWN = "UNKNOWN",
    /** Mail Order / Telephone Order transaction */
    MOTO = "MOTO",
    /** Point of Sale transaction */
    POS = "POS"
}
export declare enum OrderStatus {
    /** Order status undefined */
    UNDEFINED = "UNDEFINED",
    /** Order created, but hasn't been paid for yet. Filtered out in ListOrders response by default. */
    DRAFT = "DRAFT",
    /** Order has been paid for, but the start date is in the future */
    PENDING = "PENDING",
    /** Order is active */
    ACTIVE = "ACTIVE",
    /** Order is paused until site owner resumes it */
    PAUSED = "PAUSED",
    /** Order has ended */
    ENDED = "ENDED",
    /** Order has been canceled */
    CANCELED = "CANCELED"
}
export interface Cancellation {
    /** Date and time the cancellation was requested. */
    requestedDate?: Date;
    /**
     * Reason for the cancellation. One of:
     * + `OWNER_ACTION`: Site owner canceled the order.
     * + `MEMBER_ACTION`: Buyer initiated the cancellation.
     * + `PAYMENT_FAILURE`: Payment transaction failed.
     * + `PAYMENT_SETUP_FAILURE`: Buyer's payment details weren't set up correctly.
     * + `UNKNOWN`: Reason for the cancellation is unknown.
     */
    cause?: CancellationCause;
    /**
     * When the cancellation takes effect. Set when cancelling the order. One of:
     * + `IMMEDIATELY`: Cancellation occurs immediately and the buyer can no longer use the plan.
     * + `NEXT_PAYMENT_DATE`: Cancellation occurs at the next payment date and time. Buyer can continue to use the plan until that date and time.
     */
    effectiveAt?: CancellationEffectiveAt;
}
export declare enum CancellationCause {
    /** Cancellation initiator undefined */
    UNDEFINED = "UNDEFINED",
    /** Order was canceled by site owner (default if canceled by user or service identity) */
    OWNER_ACTION = "OWNER_ACTION",
    /** Order was canceled by member (default if canceled by member identity) */
    MEMBER_ACTION = "MEMBER_ACTION",
    /** Order was canceled because of payment failure */
    PAYMENT_FAILURE = "PAYMENT_FAILURE",
    /** Order was canceled because of payment setup failure */
    PAYMENT_SETUP_FAILURE = "PAYMENT_SETUP_FAILURE",
    /** Order was cancelled because of an unknown reason. It's not possible to know with certain payment providers (e.g. paypal) */
    UNKNOWN = "UNKNOWN"
}
export declare enum CancellationEffectiveAt {
    /** Cancellation time undefined */
    UNDEFINED = "UNDEFINED",
    /** Will cancel the order now, i.e. update validUntil to the current date */
    IMMEDIATELY = "IMMEDIATELY",
    /** Will cancel the order at the date when next payment should have been made */
    NEXT_PAYMENT_DATE = "NEXT_PAYMENT_DATE"
}
export declare enum PaymentStatus {
    /** Payment status undefined */
    UNDEFINED = "UNDEFINED",
    /** Payment has been paid */
    PAID = "PAID",
    /** Payment has been refunded */
    REFUNDED = "REFUNDED",
    /** Recurring payment has failed */
    FAILED = "FAILED",
    /** Payment has not been paid */
    UNPAID = "UNPAID",
    /** Billing has been initialized, but actual charge is yet to be made. Can happen for free trial and PayPal */
    PENDING = "PENDING",
    /** Used in cases where the plan is free */
    NOT_APPLICABLE = "NOT_APPLICABLE"
}
export interface PausePeriod {
    /**
     * Status of the pause period. One of:
     *
     * + `ACTIVE`: Status while the order is [paused](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/pause-order).
     * + `ENDED`: Status when the order is [resumed](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/orders/resume-order).
     */
    status?: Status;
    /** Start date and time of the pause period. */
    pauseDate?: Date;
    /**
     * End date and time of the pause period.
     *
     * Omitted while the pause period remains `ACTIVE`.
     */
    resumeDate?: Date;
}
export declare enum Status {
    UNDEFINED = "UNDEFINED",
    /** Order suspension is active */
    ACTIVE = "ACTIVE",
    /** Order suspension has ended */
    ENDED = "ENDED"
}
/**
 * Current cycle will be empty when order is cancelled, expired or order start date is in the future
 * Current cycle start and end dates take into account free trial days and suspensions
 */
export interface CurrentCycle {
    /**
     * Index of the current payment cycle in the order.
     *
     * `0` when order is in a free trial period. In all other cases, the index starts with `1`.
     */
    index?: number;
    /** Start date and time for the current payment cycle. */
    startedDate?: Date;
    /** End date and time for the current payment cycle. */
    endedDate?: Date;
}
/** Order cycle start and end dates take into account free trial days and suspensions */
export interface OrderCycle {
    /**
     * Index of this cycle in the order.
     *
     * `0` when order is in a free trial period. In all other cases, the index starts with `1`.
     */
    index?: number;
    /** Start date and time for this order cycle. */
    startedDate?: Date;
    /** End date and time for this order cycle. */
    endedDate?: Date;
}
export interface FormData {
    /**
     * ID of the order form associated with the plan at checkout.
     *
     * Learn more about [forms](https://dev.wix.com/docs/rest/api-reference/wix-forms/form-submissions/introduction).
     */
    formId?: string | null;
    /** ID of a submission to the plan's order form at checkout. Every time a visitor completes the checkout process for a plan, a new submission is created. */
    submissionId?: string | null;
    /**
     * Data submitted to the plan's order form at checkout.
     * @readonly
     */
    submissionData?: Record<string, any>;
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
export interface RestoreInfo {
    deletedDate?: Date;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntityAsJson?: string | null;
}
export interface ActionEvent {
    bodyAsJson?: string;
}
export interface Empty {
}
export interface MemberGetOrderRequest {
    /** Order ID. */
    id: string;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
export declare enum Set {
    /** Same behavior as BASIC */
    UNKNOWN_SET = "UNKNOWN_SET",
    /**
     * Returns fields of the entity that are available in the database.
     * By default a field is available in the database unless explicitly specified in the documentation
     */
    BASIC = "BASIC",
    /**
     * Returns all fields in the entity.
     * This might make additional calls to gather the full entity
     */
    FULL = "FULL"
}
export interface MemberGetOrderResponse {
    /** Requested order. */
    order?: Order;
}
export interface MemberListOrdersRequest {
    /** Filter by plan IDs. */
    planIds?: string[];
    /** Filter for orders where auto renewal was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatus[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatus[];
    /** Limit the number of pricing plans returned. Default limit is 50. */
    limit?: number | null;
    /** Number of entries to offset. */
    offset?: number | null;
    /** Sorting direction (defaults to ASC) and field to sort by. [See available fields here](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort). */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
export interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
export declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
export interface MemberListOrdersResponse {
    /** Requested orders. */
    orders?: Order[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
export interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
export interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
/**
 * TODO: Write orders filter and sort docs page
 * Retrieves a list of up to 1,000 orders, based on the provided paging, [sorting, and filtering](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort).
 */
export interface QueryOrdersRequest {
    /** [See available fields here](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort). */
    query?: QueryV2;
}
export interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting[];
    /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
    fields?: string[];
    /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
    fieldsets?: string[];
}
/** @oneof */
export interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
export interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
export interface QueryOrdersResponse {
    /** Order data. */
    plans?: Order[];
    /** Paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
export interface RequestCancellationRequest {
    /** Order ID. */
    id: string;
    /** Required. Whether to cancel the order effective immediately or at the next payment date. One-time orders can only be canceled immediately. */
    effectiveAt: CancellationEffectiveAt;
}
export interface RequestCancellationResponse {
}
/**
 * Emitted when an order is canceled immediately or when cycle ends for an order with canceled auto renewal
 *
 * To determine the specific reason of the cancellation check `order.cancellation.cause` field.
 */
export interface OrderCanceled {
    /** Canceled order. */
    order?: Order;
}
export interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
export interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
export interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
export declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
export interface CreateOnlineOrderRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Provided if checkout is initiated on buyer's behalf. */
    onBehalf?: OnBehalf;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
export interface OnBehalf {
    /** Member ID. */
    memberId?: string;
    /** Method by which checkout is initiated on buyer's behalf */
    orderMethod?: OrderMethod;
}
export interface CreateOnlineOrderResponse {
    /** Order. */
    order?: Order;
}
export interface CouponsError {
    /** Coupon code. */
    couponCode?: string;
    /** Plan ID. */
    planId?: string;
}
export interface CreateGuestOnlineOrderRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Captcha data to prove you are not a robot */
    captcha?: Captcha;
    /** Visitor info */
    guest?: Guest;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
export interface Captcha {
    /** Token from captcha */
    token?: string;
}
export interface Guest {
    /** Email for checkout */
    email?: string;
}
export interface CreateGuestOnlineOrderResponse {
    /** Order. */
    order?: Order;
}
export interface CreateOfflineOrderRequest {
    /** ID of the plan being ordered. See [Plans for more information about plan IDs](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans). */
    planId: string;
    /** ID of the member ordering the plan. See [Members for more information about member IDs](https://dev.wix.com/api/rest/members/members). */
    memberId: string;
    /**
     * Start date and time for the ordered plan.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /**
     * Whether the order is paid.
     *
     * Default: `false`
     */
    paid?: boolean | null;
    /**
     * Coupon code to apply.
     *
     * See [Coupons to learn more](https://dev.wix.com/api/rest/coupons).
     */
    couponCode?: string | null;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
export interface CreateOfflineOrderResponse {
    /** Order. */
    order?: Order;
}
export interface CreateExternalOrderRequest {
    /** Plan ID. */
    planId?: string;
    /** Form submission id that was submitted together with the order */
    submissionId?: string | null;
}
export interface CreateExternalOrderResponse {
    /** Created order */
    order?: Order;
}
export interface GetOnlineOrderPreviewRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
}
export interface GetOnlineOrderPreviewResponse {
    /** Will be missing if limit is exceeded */
    order?: Order;
    /**
     * Whether the purchase limit has already been reached for this plan by this member.
     * Always false for plans without purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
export interface GetGuestOnlineOrderPreviewRequest {
    /** Plan ID. */
    planId?: string;
    /**
     * Start date for the ordered plan.
     *
     * Default: Current date
     */
    startDate?: Date;
    /** Coupon code to apply. */
    couponCode?: string | null;
    /** Email for checkout */
    email?: string;
}
export interface GetGuestOnlineOrderPreviewResponse {
    /** Will be missing if limit is exceeded */
    order?: Order;
    /**
     * Whether the purchase limit has already been reached for this plan by this email.
     * Always false for plans without purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
export interface GetOfflineOrderPreviewRequest {
    /** ID of the plan of the previewed order. See [Plans for more information about plan IDs](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans). */
    planId: string;
    /** Member ID of the buyer the previewed order is for. See [Members for more information about member IDs](https://dev.wix.com/api/rest/members/members). */
    memberId: string;
    /**
     * Start date and time for plan of the previewed order.
     *
     * Default: Current date and time
     */
    startDate?: Date;
    /** Coupon code to apply. See [Coupons to learn more](https://dev.wix.com/api/rest/coupons). */
    couponCode?: string | null;
}
export interface GetOfflineOrderPreviewResponse {
    /** The previewed order, as if the plan had been ordered. */
    order?: Order;
    /**
     * Whether this previewed order would exceed the permitted amount of purchases available
     * for this plan for this buyer.
     *
     * Always `false` for plans that do not have purchase limits.
     */
    purchaseLimitExceeded?: boolean;
}
export interface GetPricePreviewRequest {
    /** ID of plan to preview. */
    planId: string;
    /**
     * Coupon code to apply.
     *
     * See Coupons [to learn more](https://dev.wix.com/api/rest/coupons).
     */
    couponCode?: string | null;
}
export interface GetPricePreviewResponse {
    /**
     * __Deprecated.__ Use `prices` instead. This property will be removed on September 30, 2022.
     * @deprecated __Deprecated.__ Use `prices` instead. This property will be removed on September 30, 2022.
     * @replacedBy prices
     * @targetRemovalDate 2022-10-01
     */
    price?: PriceDetails;
    /** Pricing details. */
    prices?: SpannedPrice[];
}
export interface ChangeStartDateRequest {
    /** Draft order ID. */
    orderId?: string;
    /** New valid from date (timestamp). */
    startDate?: Date;
}
export interface ChangeStartDateResponse {
    /** Updated draft order. */
    order?: Order;
}
export interface OrderStartDateChanged {
    /** Order whose `startDate` changed. */
    order?: Order;
}
export interface ApplyCouponRequest {
    /** Draft order ID. */
    orderId?: string;
    /** Coupon code to apply. */
    couponCode?: string;
}
export interface ApplyCouponResponse {
    /** Order with applied coupon and recalculated tax. */
    order?: Order;
}
export interface SetSubmissionRequest {
    /** Order ID. */
    orderId?: string;
    /** Submission ID. */
    submissionId?: string;
}
export interface SetSubmissionResponse {
    /** Order with submission id */
    order?: Order;
}
export interface OrderPurchased {
    /** Order that was paid for. If a free or an offline order, the order that was created. */
    order?: Order;
}
export interface OrderStarted {
    /** Order that reached its `startDate`. */
    order?: Order;
}
/**
 * Triggered at the start of a new payment cycle for an existing order.
 *
 * This webhook does not trigger at the initial start of an offline order.
 */
export interface OrderCycleStarted {
    /** Order whose new cycle started. */
    order?: Order;
    /** Number of the payment cycle will be 0 when the order is in the free trial period. In other cases, the cycle number starts from 1. */
    cycleNumber?: number;
}
/** Emitted when a recurring order is canceled for the next payment cycle */
export interface OrderAutoRenewCanceled {
    /** Order that is canceled, effective at the end of the current payment cycle. */
    order?: Order;
}
export interface OrderEnded {
    /** Order that ended. */
    order?: Order;
}
export interface GetOrderRequest {
    /** Order ID. */
    id: string;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return the order's form submission data.
     * - `FULL`: Returns the order's form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
export interface GetOrderResponse {
    /** Order. */
    order?: Order;
}
export interface ListOrdersRequest {
    /** Filter by a buyer's member ID. See [Members to learn more about a site's members](https://dev.wix.com/api/rest/members/members). */
    buyerIds?: string[];
    /** Filter by plan IDs. See [Plans to learn more about pricing plans](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans). */
    planIds?: string[];
    /** Filter by whether or not the auto-renewal of recurring orders was canceled. */
    autoRenewCanceled?: boolean | null;
    /** Filter by order status. */
    orderStatuses?: OrderStatus[];
    /** Filter by payment status. */
    paymentStatuses?: PaymentStatus[];
    /**
     * Number of orders to return. See [Pagination](https://dev.wix.com/api/rest/getting-started/sorting-and-paging#getting-started_sorting-and-paging_paging) for more information.
     *
     * Max: `50`
     */
    limit?: number | null;
    /** Number of orders to skip in the current sort order. */
    offset?: number | null;
    /**
     * Sort order.
     *
     * Use `ASC` for ascending order or `DESC` for descending order.
     *
     * Default: `DESC`
     */
    sorting?: Sorting;
    /**
     * Predefined set of fields to return.
     *
     * - `BASIC`: Doesn't return any order form submission data.
     * - `FULL`: Returns all order form submission data.
     *
     * Default: If `fieldSet` is omitted, no order form submission data is returned.
     */
    fieldSet?: Set;
}
export interface ListOrdersResponse {
    /** List of orders. */
    orders?: Order[];
    /** Object containing paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
export interface OrdersQueryOrdersRequest {
    /** [See available fields here](https://dev.wix.com/api/rest/pricing-plans/pricing-plans/order-v2/filter-and-sort). */
    query?: QueryV2;
}
export interface OrdersQueryOrdersResponse {
    /** Retrieved orders. */
    plans?: Order[];
    /** Paging-related data (number of orders returned, offset). */
    pagingMetadata?: PagingMetadataV2;
}
export interface GetOrdersStatsRequest {
}
export interface GetOrdersStatsResponse {
    /** Total number of orders. */
    totalOrderCount?: number;
    /** Number of active orders. */
    activeOrderCount?: number;
}
export interface GetAvailableOrderActionsRequest {
    /** Order ID. */
    id?: string;
}
export interface GetAvailableOrderActionsResponse {
    /** Whether the order can be suspended. */
    suspendable?: boolean;
    /** If the order cannot be suspended, a reason is returned here. */
    notSuspendableReason?: ReasonNotSuspendable;
    /** Whether the order can be canceled by the buyer. */
    cancelableByBuyer?: boolean;
}
export declare enum ReasonNotSuspendable {
    /** Reason unknown */
    UNDEFINED = "UNDEFINED",
    /** Saved in the database but is awaiting payment. Non-active orders cannot be suspended */
    PENDING = "PENDING",
    /** Trial orders cannot be suspended */
    TRIAL = "TRIAL",
    /** Canceled orders cannot be suspended */
    CANCELED = "CANCELED",
    /** Ended orders cannot be suspended */
    ENDED = "ENDED",
    /** Paid for orders with future start dates cannot be suspended */
    NOT_STARTED = "NOT_STARTED",
    /** Order is already suspended */
    ALREADY_SUSPENDED = "ALREADY_SUSPENDED",
    /** Orders based on recurring payments using older Stripe versions cannot be suspended */
    OLD_STRIPE = "OLD_STRIPE"
}
export interface PostponeEndDateRequest {
    /** Order ID. */
    id: string;
    /**
     * New end date and time.
     *
     * Must be later than the current end date and time.
     */
    endDate: Date;
}
export interface PostponeEndDateResponse {
}
export interface OrderEndDatePostponed {
    /** Order whose `endDate` was postponed. */
    order?: Order;
}
export interface CancelOrderRequest {
    /** Order ID. */
    id: string;
    /** __Required.__ When the order will be canceled. One-time orders can only be canceled `IMMEDIATELY`. */
    effectiveAt: CancellationEffectiveAt;
}
export interface CancelOrderResponse {
}
export interface MarkAsPaidRequest {
    /** Order ID. */
    id: string;
}
export interface MarkAsPaidResponse {
}
export interface OrderMarkedAsPaid {
    /** Order that was marked as paid. */
    order?: Order;
}
export interface PauseOrderRequest {
    /** Order ID. */
    id: string;
}
export interface PauseOrderResponse {
}
export interface OrderPaused {
    /** Paused order. */
    order?: Order;
}
export interface BulkPauseOrderRequest {
    /** List of Order IDs. */
    ids?: string[];
    /** Set to true to return Order entity in response. */
    returnFullEntity?: boolean;
}
export interface BulkPauseOrderResponse {
    /** Orders that were paused. */
    results?: BulkOrderResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkOrderResult {
    /** Item metadata */
    itemMetadata?: ItemMetadata;
    /** The order. */
    order?: Order;
}
export interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
export interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
export interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
export interface ResumeOrderRequest {
    /** Order ID. */
    id: string;
}
export interface ResumeOrderResponse {
}
export interface OrderResumed {
    /** Resumed order. */
    order?: Order;
}
export interface BulkResumeOrderRequest {
    /** List of Order IDs. */
    ids?: string[];
    /** Set to true to return Order entity in response. */
    returnFullEntity?: boolean;
}
export interface BulkResumeOrderResponse {
    /** Orders that were resumed. */
    results?: BulkOrderResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BuyerNonNullableFields {
    memberId: string;
    contactId: string;
}
interface DurationNonNullableFields {
    unit: PeriodUnit;
}
interface RecurrenceNonNullableFields {
    cycleDuration?: DurationNonNullableFields;
}
interface TaxNonNullableFields {
    name: string;
    includedInPrice: boolean;
    rate: string;
    amount: string;
}
interface CouponNonNullableFields {
    code: string;
    amount: string;
    id: string;
}
interface PriceDetailsNonNullableFields {
    subscription?: RecurrenceNonNullableFields;
    singlePaymentForDuration?: DurationNonNullableFields;
    subtotal: string;
    discount: string;
    tax?: TaxNonNullableFields;
    total: string;
    planPrice: string;
    currency: string;
    coupon?: CouponNonNullableFields;
}
interface PriceDurationNonNullableFields {
    cycleFrom: number;
}
interface FeeNonNullableFields {
    name: string;
    amount: string;
}
interface PriceNonNullableFields {
    subtotal: string;
    coupon?: CouponNonNullableFields;
    discount: string;
    tax?: TaxNonNullableFields;
    total: string;
    currency: string;
    fees: FeeNonNullableFields[];
    proration: string;
}
interface SpannedPriceNonNullableFields {
    duration?: PriceDurationNonNullableFields;
    price?: PriceNonNullableFields;
}
interface PricingDetailsNonNullableFields {
    subscription?: RecurrenceNonNullableFields;
    singlePaymentForDuration?: DurationNonNullableFields;
    prices: SpannedPriceNonNullableFields[];
}
interface CancellationNonNullableFields {
    cause: CancellationCause;
    effectiveAt: CancellationEffectiveAt;
}
interface PausePeriodNonNullableFields {
    status: Status;
}
interface CurrentCycleNonNullableFields {
    index: number;
}
interface OrderCycleNonNullableFields {
    index: number;
}
interface OrderNonNullableFields {
    id: string;
    planId: string;
    subscriptionId: string;
    buyer?: BuyerNonNullableFields;
    priceDetails?: PriceDetailsNonNullableFields;
    pricing?: PricingDetailsNonNullableFields;
    type: OrderType;
    orderMethod: OrderMethod;
    status: OrderStatus;
    cancellation?: CancellationNonNullableFields;
    lastPaymentStatus: PaymentStatus;
    pausePeriods: PausePeriodNonNullableFields[];
    currentCycle?: CurrentCycleNonNullableFields;
    cycles: OrderCycleNonNullableFields[];
    planName: string;
    planDescription: string;
    planPrice: string;
    statusNew: OrderStatus;
}
export interface MemberGetOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
export interface MemberListOrdersResponseNonNullableFields {
    orders: OrderNonNullableFields[];
}
export interface CreateOfflineOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
export interface GetOfflineOrderPreviewResponseNonNullableFields {
    order?: OrderNonNullableFields;
    purchaseLimitExceeded: boolean;
}
export interface GetPricePreviewResponseNonNullableFields {
    price?: PriceDetailsNonNullableFields;
    prices: SpannedPriceNonNullableFields[];
}
export interface GetOrderResponseNonNullableFields {
    order?: OrderNonNullableFields;
}
export interface ListOrdersResponseNonNullableFields {
    orders: OrderNonNullableFields[];
}
export {};
