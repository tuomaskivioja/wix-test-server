import { lastPathSegmentOf, parentPathOf, } from '@wix/motion-edm-autogen-common';
import { filter, some } from 'lodash';
import { isReservedCommonFieldName, toCorvidName } from '../../corvid-entity';
import { hasValidArgumentIndex, isInvalidJsonPath, isInvalidJsonValue, isSpreadOperator, } from '../../helpers';
import { isFunctionCallExpression } from '../custom-functions';
import { reduceTransformation } from '../reduceTransformation';
import { validateOmitTransformation, validationError } from './common';
const validateSimpleTransformation = (simpleTransformation, path = null) => {
    const validationErrors = [];
    const transformationSegments = simpleTransformation.split('.');
    const [firstSegment] = transformationSegments;
    transformationSegments
        .filter(isReservedCommonFieldName)
        .forEach((invalidName) => validationErrors.push(validationError(`cannot refer to ${invalidName} field, consider using ${toCorvidName(invalidName)} instead`, simpleTransformation, path)));
    if (some(transformationSegments, isSpreadOperator)) {
        validationErrors.push(validationError('cannot refer to the * operator', simpleTransformation, path));
    }
    if (!hasValidArgumentIndex(firstSegment)) {
        validationErrors.push(validationError('must start with $[N] where N is an index', simpleTransformation, path));
    }
    if (filter(transformationSegments, hasValidArgumentIndex).length > 1) {
        validationErrors.push(validationError('must have a single argument-index as the first path segment', simpleTransformation, path));
    }
    return validationErrors;
};
function validateRequestTransformation(transformation) {
    const errors = reduceTransformation(transformation, {
        visitors: {
            TopLevelSimpleTransformationExpression: (simpleTransformation) => validateSimpleTransformation(simpleTransformation),
            CustomFunctionExpression: (acc, path, functionName, argumentExpressions, rawExpression) => {
                if (functionName === null || argumentExpressions === null) {
                    acc.push(validationError('contains an invalid custom function expression', rawExpression, path));
                }
                else {
                    const [argumentExpression] = argumentExpressions;
                    if (functionName === 'constant') {
                        if (isInvalidJsonValue(argumentExpression)) {
                            acc.push(validationError('must be a valid json value', argumentExpression, path));
                        }
                    }
                    else {
                        // TODO: validate all arguments
                        const [firstSegment, ...nestedPathSegments] = argumentExpression.split('.');
                        if (isInvalidJsonPath(argumentExpression)) {
                            acc.push(validationError('must be a valid json-path', argumentExpression, path));
                        }
                        if (!hasValidArgumentIndex(firstSegment)) {
                            acc.push(validationError('must start with $[N] where N is an index', argumentExpression, path));
                        }
                        nestedPathSegments.forEach((nestedPathSegment) => {
                            if (hasValidArgumentIndex(nestedPathSegment)) {
                                acc.push(validationError('must have a single argument-index as the first path segment', argumentExpression, path));
                            }
                        });
                    }
                }
            },
            NestedSimpleTransformationExpression: (acc, path, simpleTransformationExpression) => {
                const lastPathSegment = lastPathSegmentOf(path);
                const parentPath = parentPathOf(path);
                if (isFunctionCallExpression(lastPathSegment)) {
                    acc.push(validationError('cannot be a custom function call', lastPathSegment, parentPath));
                }
                if (hasValidArgumentIndex(lastPathSegment)) {
                    acc.push(validationError("must start with '$.'", lastPathSegment, parentPath));
                }
                if (isSpreadOperator(lastPathSegment)) {
                    acc.push(validationError('cannot refer to the * operator', lastPathSegment, parentPath));
                }
                acc.push(...validateSimpleTransformation(simpleTransformationExpression, path));
            },
            NestedUnsupportedTransformationExpression: (acc, path, value) => {
                acc.push(validationError('must start with $[N] where N is an index', value, path));
            },
            TopLevelUnsupportedTransformationExpression: (unsupportedTransformation) => [
                validationError('must start with $[N] where N is an index', unsupportedTransformation),
            ],
            TopLevelOmit: (source, fieldsToOmit) => validateOmitTransformation({
                source,
                fieldsToOmit,
                validateSource: validateRequestTransformation,
            }),
            NestedOmit: (acc, path, source, fieldsToOmit) => acc.push(...validateOmitTransformation({
                source,
                fieldsToOmit,
                parentPath: path,
                validateSource: validateRequestTransformation,
            })),
        },
        accumulator: [],
    });
    return {
        isValid: errors.length === 0,
        validationErrors: errors,
    };
}
export { validateRequestTransformation };
//# sourceMappingURL=validateRequestTransformation.js.map