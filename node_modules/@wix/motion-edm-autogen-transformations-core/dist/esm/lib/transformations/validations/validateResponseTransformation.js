import { lastPathSegmentOf, parentPathOf, } from '@wix/motion-edm-autogen-common';
import { some } from 'lodash';
import { isReservedCorvidFieldName } from '../../corvid-entity';
import { hasValidArgumentIndex, isInvalidJsonPath, isRootObjectIdentifier, isSpreadOperator, } from '../../helpers';
import { transformations } from '../common';
import { isFunctionCallExpression } from '../custom-functions';
import { reduceTransformation } from '../reduceTransformation';
import { validateOmitTransformation, validationError } from './common';
const { ARRAY_ITEMS_PATH_PROPERTY_NAME, ARRAY_ITEM_TRANSFORMATION_PROPERTY_NAME, } = transformations;
const INVALID_PATH_STRING_MESSAGE = "must be a string starting with '$.'";
const validateArrayItemTransformation = (sourceArrayExpression, itemTransformation, parentPath = null) => {
    const withOptionalParentPath = (path) => (err) => ({
        ...err,
        // @ts-expect-error
        parentPath: [parentPath, path, validationError.parentPath]
            .filter((s) => s)
            .join('.'),
    });
    const validationErrors = [];
    if (isInvalidJsonPath(sourceArrayExpression)) {
        const fullPath = parentPath
            ? [parentPath, ARRAY_ITEMS_PATH_PROPERTY_NAME]
            : [ARRAY_ITEMS_PATH_PROPERTY_NAME];
        validationErrors.push(validationError(INVALID_PATH_STRING_MESSAGE, sourceArrayExpression, fullPath.join('.')));
    }
    validationErrors.push(
    // eslint-disable-next-line no-use-before-define
    ...validateResponseTransformation(sourceArrayExpression).validationErrors.map(withOptionalParentPath(ARRAY_ITEMS_PATH_PROPERTY_NAME)), 
    // eslint-disable-next-line no-use-before-define
    ...validateResponseTransformation(itemTransformation).validationErrors.map(withOptionalParentPath(ARRAY_ITEM_TRANSFORMATION_PROPERTY_NAME)));
    return validationErrors;
};
const validateSimpleTransformationExpression = (simpleTransformationExpression, path = null) => {
    const transformationSegments = simpleTransformationExpression.split('.');
    const [firstExpressionSegment] = transformationSegments;
    const validationErrors = [];
    if (!isRootObjectIdentifier(firstExpressionSegment)) {
        validationErrors.push(validationError(INVALID_PATH_STRING_MESSAGE, simpleTransformationExpression, path));
    }
    if (some(transformationSegments, isSpreadOperator)) {
        validationErrors.push(validationError('cannot refer to the * operator', simpleTransformationExpression, path));
    }
    if (isInvalidJsonPath(simpleTransformationExpression)) {
        validationErrors.push(validationError('must be a valid json-path', simpleTransformationExpression, path));
    }
    transformationSegments
        .filter(isReservedCorvidFieldName)
        .forEach((invalidName) => validationErrors.push(validationError(`cannot refer to the ${invalidName} field`, simpleTransformationExpression, path)));
    return validationErrors;
};
const validateCustomFunctionExpression = ({ functionName, argumentExpressions, rawExpression, path = null, }) => {
    const validationErrors = [];
    if (functionName === null || argumentExpressions === null) {
        validationErrors.push(validationError('contains an invalid custom function expression', rawExpression, path));
        return validationErrors;
    }
    // TODO: validate all arguments
    const [argumentExpression] = argumentExpressions;
    const [firstSegment] = argumentExpression.split('.');
    if (isInvalidJsonPath(argumentExpression)) {
        validationErrors.push(validationError('must be a valid json-path', argumentExpression, path));
    }
    if (!isRootObjectIdentifier(firstSegment)) {
        validationErrors.push(validationError(INVALID_PATH_STRING_MESSAGE, argumentExpression, path));
    }
    return validationErrors;
};
function validateResponseTransformation(transformation) {
    const errors = reduceTransformation(transformation, {
        visitors: {
            TopLevelSimpleTransformationExpression: (simpleTransformation) => validateSimpleTransformationExpression(simpleTransformation),
            TopLevelCustomFunctionExpression: (functionName, argumentExpressions, rawExpression) => validateCustomFunctionExpression({
                functionName,
                argumentExpressions,
                rawExpression,
            }),
            CustomFunctionExpression: (acc, path, functionName, argumentExpressions, rawExpression) => {
                acc.push(...validateCustomFunctionExpression({
                    functionName,
                    argumentExpressions,
                    rawExpression,
                    path,
                }));
            },
            NestedSimpleTransformationExpression: (acc, path, simpleTransformationExpression) => {
                const lastPathSegment = lastPathSegmentOf(path);
                const parentPath = parentPathOf(path);
                acc.push(...validateSimpleTransformationExpression(simpleTransformationExpression, path));
                if (isFunctionCallExpression(lastPathSegment)) {
                    acc.push(validationError('cannot be a custom function call', lastPathSegment, parentPath));
                }
                if (isReservedCorvidFieldName(lastPathSegment)) {
                    acc.push(validationError(`cannot refer to the ${lastPathSegment} field`, lastPathSegment, parentPath));
                }
                if (hasValidArgumentIndex(lastPathSegment)) {
                    acc.push(validationError(INVALID_PATH_STRING_MESSAGE, lastPathSegment, parentPath));
                }
                if (isRootObjectIdentifier(lastPathSegment)) {
                    acc.push(validationError('cannot refer to $ in a transformation key', lastPathSegment, parentPath));
                }
            },
            NestedUnsupportedTransformationExpression: (acc, path, value) => {
                acc.push(validationError(INVALID_PATH_STRING_MESSAGE, value, path));
            },
            TopLevelUnsupportedTransformationExpression: (unsupportedTransformation) => [
                validationError(INVALID_PATH_STRING_MESSAGE, unsupportedTransformation),
            ],
            TopLevelOmit: (source, fieldsToOmit) => validateOmitTransformation({
                source,
                fieldsToOmit,
                validateSource: validateResponseTransformation,
            }),
            NestedOmit: (acc, path, source, fieldsToOmit) => acc.push(...validateOmitTransformation({
                source,
                fieldsToOmit,
                parentPath: path,
                validateSource: validateResponseTransformation,
            })),
            MapArrayItems: (acc, path, sourceArrayExpression, itemTransformation) => {
                acc.push(...validateArrayItemTransformation(sourceArrayExpression, itemTransformation, path));
            },
            TopLevelMapArrayItems: (sourceArrayExpression, itemTransformation) => validateArrayItemTransformation(sourceArrayExpression, itemTransformation),
        },
        accumulator: [],
    });
    return {
        isValid: errors.length === 0,
        validationErrors: errors,
    };
}
export { validateResponseTransformation };
//# sourceMappingURL=validateResponseTransformation.js.map