import deepForEachModule from 'deep-for-each';
import { get, isArray, isString, some } from 'lodash';
import { isConstantExpression, isJsonPathExpression, isMapArrayItemsTransformation, isOmitTransformation, isSimpleTransformation, isSpreadOperator, parseMapArrayItemsTransformation, parseOmitTransformation, } from '../helpers';
import { transformations } from './common';
import { visitorTypes } from './constants';
import { isFunctionCallExpression, parseCustomFunctionCall, } from './custom-functions';
const { ARRAY_ITEMS_PATH_PROPERTY_NAME, ARRAY_ITEM_TRANSFORMATION_PROPERTY_NAME, OMIT_SOURCE_PROPERTY_NAME, FIELDS_TO_OMIT_PROPERTY_NAME, CONSTANT_VALUE_PROPERTY_NAME, } = transformations;
const { TOP_LEVEL_SIMPLE_TRANSFORMATION, TOP_LEVEL_CUSTOM_FUNCTION, TOP_LEVEL_SPREAD, NESTED_SPREAD, NESTED_UNSUPPORTED_TRANSFORMATION, TOP_LEVEL_UNSUPPORTED_TRANSFORMATION, CUSTOM_FUNCTION, NESTED_SIMPLE_TRANSFORMATION, MAP_ARRAY_ITEMS, TOP_LEVEL_MAP_ARRAY_ITEMS, TOP_LEVEL_OMIT_TRANSFORMATION, NESTED_OMIT_TRANSFORMATION, NESTED_CONSTANT_VALUE, } = visitorTypes;
const safeResolveDefaultExport = (module) => {
    const isEsModule = module && module.__esModule && module.default;
    return isEsModule ? module.default : module;
};
const deepForEach = safeResolveDefaultExport(deepForEachModule);
const withoutSpreadOperatorKeys = (obj) => Object.keys(obj).filter((k) => !isSpreadOperator(k));
const safeInvokeVisitor = (visitors, name, ...args) => {
    const visitor = get(visitors, name);
    return visitor && visitor(...args);
};
const reduceComplexTransformation = (transformation, { visitors, accumulator }) => {
    const terminalPaths = [];
    const addTerminals = (path, leaves = []) => leaves.length > 0
        ? leaves.forEach((leaf) => terminalPaths.push([path, leaf].join('.')))
        : terminalPaths.push(path);
    deepForEach(transformation, (value, key, _, path) => {
        if (some(terminalPaths, (tp) => path.startsWith(tp))) {
            return;
        }
        if (isSpreadOperator(key)) {
            addTerminals(path);
            const spreadOperatorParentPath = path.replace(/\.?\*/, '');
            const values = !isArray(value) ? [value] : value;
            values.forEach((item) => {
                if (spreadOperatorParentPath === '') {
                    const siblingKeys = withoutSpreadOperatorKeys(transformation);
                    safeInvokeVisitor(visitors, TOP_LEVEL_SPREAD, accumulator, item, siblingKeys);
                }
                else {
                    const siblingKeys = withoutSpreadOperatorKeys(get(transformation, spreadOperatorParentPath));
                    safeInvokeVisitor(visitors, NESTED_SPREAD, accumulator, spreadOperatorParentPath, item, siblingKeys);
                }
            });
            return;
        }
        if (isOmitTransformation(value)) {
            addTerminals(path, [
                OMIT_SOURCE_PROPERTY_NAME,
                FIELDS_TO_OMIT_PROPERTY_NAME,
            ]);
            const { sourceExpression, fieldsToOmit } = parseOmitTransformation(value);
            safeInvokeVisitor(visitors, NESTED_OMIT_TRANSFORMATION, accumulator, path, sourceExpression, fieldsToOmit);
            return;
        }
        if (isMapArrayItemsTransformation(value)) {
            addTerminals(path, [
                ARRAY_ITEMS_PATH_PROPERTY_NAME,
                ARRAY_ITEM_TRANSFORMATION_PROPERTY_NAME,
            ]);
            const { sourceArrayExpression, itemTransformation } = parseMapArrayItemsTransformation(value);
            safeInvokeVisitor(visitors, MAP_ARRAY_ITEMS, accumulator, path, sourceArrayExpression, itemTransformation);
            return;
        }
        if (isFunctionCallExpression(value)) {
            const { functionName, argumentExpressions } = parseCustomFunctionCall(value);
            safeInvokeVisitor(visitors, CUSTOM_FUNCTION, accumulator, path, functionName, argumentExpressions, value);
            return;
        }
        if (isConstantExpression(value)) {
            addTerminals(path, [CONSTANT_VALUE_PROPERTY_NAME]);
            safeInvokeVisitor(visitors, NESTED_CONSTANT_VALUE, {
                accumulator,
                path,
                value: value[CONSTANT_VALUE_PROPERTY_NAME],
            });
            return;
        }
        if (isString(value)) {
            if (isJsonPathExpression(value)) {
                safeInvokeVisitor(visitors, NESTED_SIMPLE_TRANSFORMATION, accumulator, path, value);
            }
            else {
                safeInvokeVisitor(visitors, NESTED_UNSUPPORTED_TRANSFORMATION, accumulator, path, value);
            }
        }
    });
    return accumulator;
};
const reduceTransformation = (transformation, { visitors, accumulator }) => {
    if (isSimpleTransformation(transformation)) {
        switch (true) {
            case isJsonPathExpression(transformation):
                return safeInvokeVisitor(visitors, TOP_LEVEL_SIMPLE_TRANSFORMATION, transformation);
            case isFunctionCallExpression(transformation): {
                const { functionName, argumentExpressions } = parseCustomFunctionCall(transformation);
                return safeInvokeVisitor(visitors, TOP_LEVEL_CUSTOM_FUNCTION, functionName, argumentExpressions, transformation);
            }
            default:
                return safeInvokeVisitor(visitors, TOP_LEVEL_UNSUPPORTED_TRANSFORMATION, transformation);
        }
    }
    if (isOmitTransformation(transformation)) {
        const { sourceExpression, fieldsToOmit } = parseOmitTransformation(transformation);
        return safeInvokeVisitor(visitors, TOP_LEVEL_OMIT_TRANSFORMATION, sourceExpression, fieldsToOmit);
    }
    if (isMapArrayItemsTransformation(transformation)) {
        const { sourceArrayExpression, itemTransformation } = parseMapArrayItemsTransformation(transformation);
        return safeInvokeVisitor(visitors, TOP_LEVEL_MAP_ARRAY_ITEMS, sourceArrayExpression, itemTransformation);
    }
    return reduceComplexTransformation(transformation, { visitors, accumulator });
};
export { reduceTransformation };
//# sourceMappingURL=reduceTransformation.js.map