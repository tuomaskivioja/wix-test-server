import { JSONPath } from 'jsonpath-plus';
import { attempt, has, isError } from 'lodash';
import { transformations } from './transformations/common';
import { JSON_PATH_ROOT } from './transformations/constants';
const { RESPONSE_OBJECT_UNCHANGED, ARRAY_ITEMS_PATH_PROPERTY_NAME, ARRAY_ITEM_TRANSFORMATION_PROPERTY_NAME, OMIT_SOURCE_PROPERTY_NAME, FIELDS_TO_OMIT_PROPERTY_NAME, SPREAD_OPERATOR, CONSTANT_VALUE_PROPERTY_NAME, } = transformations;
const isInvalidJsonPath = (path) => isError(attempt(() => JSONPath({ path, json: {} })));
const isInvalidJsonValue = (value) => isError(attempt(() => JSON.parse(value)));
const isSimpleTransformation = (transformation) => typeof transformation === 'string';
const isArrayIndexString = (str) => !!/\d+/.test(str);
const isSpreadOperator = (key) => key === SPREAD_OPERATOR;
const isIdentityResponseTransformation = (transformationPath) => transformationPath === RESPONSE_OBJECT_UNCHANGED;
const getArgumentIndex = (s) => {
    const match = s.match(/\$\[(?<argIndex>\d+)\]/);
    return match && match.groups && Number(match.groups.argIndex);
};
const hasValidArgumentIndex = (path) => getArgumentIndex(path) !== null;
const isRootObjectIdentifier = (s) => s === JSON_PATH_ROOT;
const isJsonPathExpression = (exp) => exp && exp.startsWith(JSON_PATH_ROOT);
const stripJsonPathRootPrefix = (jsonPath) => jsonPath.replace(`${JSON_PATH_ROOT}.`, '');
const extractIndexAndPath = (simpleTransformation) => {
    const [maybeIndexExpression, ...rest] = simpleTransformation.split('.');
    const index = getArgumentIndex(maybeIndexExpression);
    return {
        index,
        nestedPath: index !== null && rest.length > 0 ? rest.join('.') : null,
    };
};
const isMapArrayItemsTransformation = (transformationValue) => has(transformationValue, ARRAY_ITEMS_PATH_PROPERTY_NAME) &&
    has(transformationValue, ARRAY_ITEM_TRANSFORMATION_PROPERTY_NAME);
const parseMapArrayItemsTransformation = (transformationValue) => ({
    sourceArrayExpression: transformationValue[ARRAY_ITEMS_PATH_PROPERTY_NAME],
    itemTransformation: transformationValue[ARRAY_ITEM_TRANSFORMATION_PROPERTY_NAME],
});
const isOmitTransformation = (transformationValue) => has(transformationValue, OMIT_SOURCE_PROPERTY_NAME) &&
    has(transformationValue, FIELDS_TO_OMIT_PROPERTY_NAME);
const parseOmitTransformation = (transformationValue) => ({
    sourceExpression: transformationValue[OMIT_SOURCE_PROPERTY_NAME],
    fieldsToOmit: transformationValue[FIELDS_TO_OMIT_PROPERTY_NAME],
});
const isConstantExpression = (value) => has(value, CONSTANT_VALUE_PROPERTY_NAME);
export { extractIndexAndPath, getArgumentIndex, hasValidArgumentIndex, isArrayIndexString, isConstantExpression, isIdentityResponseTransformation, isInvalidJsonPath, isInvalidJsonValue, isJsonPathExpression, isMapArrayItemsTransformation, isOmitTransformation, isRootObjectIdentifier, isSimpleTransformation, isSpreadOperator, parseMapArrayItemsTransformation, parseOmitTransformation, stripJsonPathRootPrefix, };
//# sourceMappingURL=helpers.js.map