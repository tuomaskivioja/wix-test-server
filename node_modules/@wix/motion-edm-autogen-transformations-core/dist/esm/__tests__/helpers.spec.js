import { aComplexMappingTransformation, aRandomJsonPath, aRandomResponseTransformationJsonPath, aSimpleMappingTransformation, } from '@wix/motion-edm-autogen-test-context';
import { aNumber, aString } from '@wix/motion-runtime-test-context';
import { times } from 'lodash';
import { extractIndexAndPath, getArgumentIndex, isInvalidJsonValue, isJsonPathExpression, isSimpleTransformation, stripJsonPathRootPrefix, } from '../lib/helpers';
describe('helper functions', () => {
    const index = aNumber({ min: 0, max: 1 });
    // @ts-expect-error
    const nestedPath = times(3, aString()).join('.');
    const simpleTransformation = `$[${index}]`;
    const simpleTransformationWithNestedPath = `$[${index}].${nestedPath}`;
    describe('isSimpleTransformation', () => {
        test.each `
      transformation                                    | expectedValue | transformationType
      ${aSimpleMappingTransformation().simpleMapping}   | ${true}       | ${'simple'}
      ${aComplexMappingTransformation().complexMapping} | ${false}      | ${'complex'}
    `('returns $expectedValue for $transformationType transformation', ({ transformation, expectedValue }) => {
            expect(isSimpleTransformation(transformation)).toStrictEqual(expectedValue);
        });
    });
    describe('extractIndexAndPath', () => {
        test('extracts the index and nested-path of the argument from a simple tranformation', () => {
            expect(extractIndexAndPath(simpleTransformationWithNestedPath)).toStrictEqual({ index, nestedPath });
        });
        test('sets the nestedPath to null when one could not be found', () => {
            expect(extractIndexAndPath(simpleTransformation)).toStrictEqual({
                index,
                nestedPath: null,
            });
        });
    });
    describe('getArgumentIndex', () => {
        test('extracts the index of an argument within a jsonpath', () => {
            expect(getArgumentIndex(simpleTransformation)).toStrictEqual(index);
        });
        test('return null when no index was found', () => {
            expect(getArgumentIndex(aString())).toBeNull();
        });
    });
    describe('isJsonPathExpression', () => {
        test.each `
      description                | expression           | expectedResult
      ${'starts with $'}         | ${aRandomJsonPath()} | ${true}
      ${'does not start with $'} | ${aString()}         | ${false}
    `('return $expectedResult when the expression $description', ({ expression, expectedResult }) => {
            expect(isJsonPathExpression(expression)).toStrictEqual(expectedResult);
        });
    });
    describe('stripJsonPathRootPrefix', () => {
        const nonJsonPathString = aString();
        const jsonPath = aRandomResponseTransformationJsonPath();
        test.each `
      description                | expression           | expectedResult
      ${'is $'}                  | ${'$'}               | ${'$'}
      ${'does not start with $'} | ${nonJsonPathString} | ${nonJsonPathString}
      ${'starts with $.'}        | ${jsonPath}          | ${jsonPath.slice(2)}
    `('return $expectedResult when the expression $description', ({ expression, expectedResult }) => {
            expect(stripJsonPathRootPrefix(expression)).toStrictEqual(expectedResult);
        });
    });
    describe('isInvalidJsonValue', () => {
        test('returns true for an invalid json-value', () => {
            expect(isInvalidJsonValue('x-y-z')).toBeTruthy();
        });
        test('returns false for a valid json-value', () => {
            expect(isInvalidJsonValue('"string"')).toBeFalsy();
        });
    });
});
//# sourceMappingURL=helpers.spec.js.map