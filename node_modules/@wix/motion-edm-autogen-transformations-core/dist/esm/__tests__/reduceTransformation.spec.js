import { anObject, aString } from '@wix/motion-runtime-test-context';
import { set, times } from 'lodash';
import { reduceTransformation } from '../lib/transformations/reduceTransformation';
describe('reduceTransformation', () => {
    describe('simple transformations', () => {
        const visitorCallbackResult = aString();
        test('traverses a simple transformation', () => {
            const visitorCallback = jest
                .fn()
                .mockReturnValueOnce(visitorCallbackResult);
            const transformation = '$.a.b.c';
            const result = reduceTransformation(transformation, {
                visitors: {
                    TopLevelSimpleTransformationExpression: visitorCallback,
                },
            });
            expect(visitorCallback).toHaveBeenCalledTimes(1);
            expect(visitorCallback).toHaveBeenCalledWith('$.a.b.c');
            expect(result).toStrictEqual(visitorCallbackResult);
        });
        describe('custom-functions', () => {
            test('traverses a valid custom-function expression', () => {
                const visitorCallback = jest
                    .fn()
                    .mockReturnValueOnce(visitorCallbackResult);
                const transformation = '#someCustomFunction($.a.b.c,someOtherArg)';
                const result = reduceTransformation(transformation, {
                    visitors: {
                        TopLevelCustomFunctionExpression: visitorCallback,
                    },
                });
                expect(visitorCallback).toHaveBeenCalledTimes(1);
                expect(visitorCallback).toHaveBeenCalledWith('someCustomFunction', ['$.a.b.c', 'someOtherArg'], transformation);
                expect(result).toStrictEqual(visitorCallbackResult);
            });
            test('does not fail for invalid custom-function expression', () => {
                const visitorCallback = jest
                    .fn()
                    .mockReturnValueOnce(visitorCallbackResult);
                const transformationWithInvalidCustomFunctionExpression = '#($.a.b.c)';
                const result = reduceTransformation(transformationWithInvalidCustomFunctionExpression, {
                    visitors: {
                        TopLevelCustomFunctionExpression: visitorCallback,
                    },
                });
                expect(visitorCallback).toHaveBeenCalledTimes(1);
                expect(visitorCallback).toHaveBeenCalledWith(null, null, transformationWithInvalidCustomFunctionExpression);
                expect(result).toStrictEqual(visitorCallbackResult);
            });
        });
        // TODO: replace with returning the invalid value, for constant-transformation
        test('invokes the TopLevelUnsupportedTransformationExpression otherwise', () => {
            const visitorCallback = jest
                .fn()
                .mockReturnValueOnce(visitorCallbackResult);
            const transformation = aString();
            const result = reduceTransformation(transformation, {
                visitors: {
                    TopLevelUnsupportedTransformationExpression: visitorCallback,
                },
            });
            expect(visitorCallback).toHaveBeenCalledTimes(1);
            expect(visitorCallback).toHaveBeenCalledWith(transformation);
            expect(result).toStrictEqual(visitorCallbackResult);
        });
    });
    describe('complex transformation', () => {
        const accumulator = anObject();
        test('traverses all string nodes that are transformation expressions', () => {
            const visitorCallback = jest.fn();
            const transformation = {
                a: {
                    b: { c: '$[0].ddd.eee.ffff' },
                    d: 2,
                    e: ['$.ggg', 3, 4, 5],
                },
            };
            reduceTransformation(transformation, {
                accumulator,
                visitors: {
                    NestedSimpleTransformationExpression: visitorCallback,
                },
            });
            expect(visitorCallback).toHaveBeenCalledTimes(2);
            expect(visitorCallback).toHaveBeenCalledWith(accumulator, 'a.b.c', '$[0].ddd.eee.ffff');
            expect(visitorCallback).toHaveBeenCalledWith(accumulator, 'a.e[0]', '$.ggg');
        });
        describe('spread operator', () => {
            const [topLevelSpreadOperatorCallback, nestedSpreadOperatorCallback] = times(2, () => jest.fn());
            const argumentExpression = '$[1].d.e.f';
            const sibling = anObject();
            const siblingKeys = Object.keys(sibling);
            const path = `${siblingKeys[0]}.b.c`;
            beforeEach(() => {
                [topLevelSpreadOperatorCallback, nestedSpreadOperatorCallback].forEach((mock) => mock.mockClear());
            });
            test('invokes the spread operator visitor prior to its children', () => {
                const nestedOmitCallback = jest.fn();
                const omitExpression = {
                    '@source': argumentExpression,
                    '@omit': times(2, () => aString()),
                };
                const transformation = { '*': omitExpression, ...sibling };
                reduceTransformation(transformation, {
                    accumulator,
                    visitors: {
                        TopLevelSpreadExpression: topLevelSpreadOperatorCallback,
                        NestedOmit: nestedOmitCallback,
                    },
                });
                expect(topLevelSpreadOperatorCallback).toHaveBeenCalledTimes(1);
                expect(topLevelSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, omitExpression, siblingKeys);
                // expect(nestedOmitCallback).toHaveBeenCalled();
            });
            test('traverses top-level spread-operator transformation nodes', () => {
                const transformation = { '*': argumentExpression, ...sibling };
                reduceTransformation(transformation, {
                    accumulator,
                    visitors: {
                        TopLevelSpreadExpression: topLevelSpreadOperatorCallback,
                        NestedSpreadExpression: nestedSpreadOperatorCallback,
                    },
                });
                expect(topLevelSpreadOperatorCallback).toHaveBeenCalledTimes(1);
                expect(topLevelSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, argumentExpression, siblingKeys);
                expect(nestedSpreadOperatorCallback).not.toHaveBeenCalled();
            });
            test('traverses nested spread-operator transformation nodes', () => {
                const transformation = set({}, path, {
                    '*': argumentExpression,
                    ...sibling,
                });
                const simpleTransformationCallback = jest.fn();
                reduceTransformation(transformation, {
                    accumulator,
                    visitors: {
                        TopLevelSpreadExpression: topLevelSpreadOperatorCallback,
                        NestedSpreadExpression: nestedSpreadOperatorCallback,
                        NestedSimpleTransformationExpression: simpleTransformationCallback,
                    },
                });
                expect(topLevelSpreadOperatorCallback).not.toHaveBeenCalled();
                expect(simpleTransformationCallback).not.toHaveBeenCalled();
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledTimes(1);
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, argumentExpression, siblingKeys);
            });
            test('traverses items within an array of a spread-operator transformation nodes', () => {
                const simpleTransformationCallback = jest.fn();
                const transformation = set({}, path, {
                    '*': ['$[0].x.y.z', '$[1].d.e.f'],
                    ...sibling,
                });
                reduceTransformation(transformation, {
                    accumulator,
                    visitors: {
                        NestedSpreadExpression: nestedSpreadOperatorCallback,
                        NestedSimpleTransformationExpression: simpleTransformationCallback,
                    },
                });
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledTimes(2);
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, '$[0].x.y.z', siblingKeys);
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, '$[1].d.e.f', siblingKeys);
                expect(simpleTransformationCallback).not.toHaveBeenCalled();
            });
            test('sets the path to be the parent of the spread operator', () => {
                const anotherArgumentExpression = '$[0].x.y.z';
                const topLevelArgumentExpression = '$[1]';
                const transformation = set({ '*': topLevelArgumentExpression, ...sibling }, path, {
                    '*': [anotherArgumentExpression, argumentExpression],
                });
                reduceTransformation(transformation, {
                    accumulator,
                    visitors: {
                        NestedSpreadExpression: nestedSpreadOperatorCallback,
                        TopLevelSpreadExpression: topLevelSpreadOperatorCallback,
                    },
                });
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledTimes(2);
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, argumentExpression, []);
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, anotherArgumentExpression, []);
                expect(topLevelSpreadOperatorCallback).toHaveBeenCalledTimes(1);
                expect(topLevelSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, topLevelArgumentExpression, siblingKeys);
            });
        });
        describe('custom functions', () => {
            test('traverses custom-function nodes', () => {
                const customFunctionExpressionCallback = jest.fn();
                const simpleTransformationCallback = jest.fn();
                const customFunctionExpression = '#someCustomFunction($[0].someCustomFunction)';
                const transformation = {
                    a: {
                        b: customFunctionExpression,
                    },
                };
                reduceTransformation(transformation, {
                    accumulator,
                    visitors: {
                        CustomFunctionExpression: customFunctionExpressionCallback,
                        NestedSimpleTransformationExpression: simpleTransformationCallback,
                    },
                });
                expect(customFunctionExpressionCallback).toHaveBeenCalledTimes(1);
                expect(customFunctionExpressionCallback).toHaveBeenCalledWith(accumulator, 'a.b', 'someCustomFunction', ['$[0].someCustomFunction'], customFunctionExpression);
                expect(simpleTransformationCallback).not.toHaveBeenCalled();
            });
            test('does not fail on invalid custom-function nodes', () => {
                const customFunctionExpressionCallback = jest.fn();
                const simpleTransformationCallback = jest.fn();
                const invalidCustomFunctionExpression = '#($[0].someCustomFunction)';
                const transformation = {
                    a: {
                        b: invalidCustomFunctionExpression,
                    },
                };
                reduceTransformation(transformation, {
                    accumulator,
                    visitors: {
                        CustomFunctionExpression: customFunctionExpressionCallback,
                        NestedSimpleTransformationExpression: simpleTransformationCallback,
                    },
                });
                expect(customFunctionExpressionCallback).toHaveBeenCalledTimes(1);
                expect(customFunctionExpressionCallback).toHaveBeenCalledWith(accumulator, 'a.b', null, null, invalidCustomFunctionExpression);
                expect(simpleTransformationCallback).not.toHaveBeenCalled();
            });
        });
        describe('constant annotation', () => {
            test('traverses a nested constant annotation expression', () => {
                const nestedConstantExpressionCallback = jest.fn();
                const undesiredVisitor = jest.fn();
                const transformation = {
                    a: { b: { c: { '@constant': { someConst: '$.value123' } } } },
                };
                reduceTransformation(transformation, {
                    accumulator,
                    visitors: {
                        NestedConstantValue: nestedConstantExpressionCallback,
                        NestedSimpleTransformationExpression: undesiredVisitor,
                    },
                });
                expect(nestedConstantExpressionCallback).toHaveBeenCalledTimes(1);
                expect(nestedConstantExpressionCallback).toHaveBeenCalledWith({
                    accumulator,
                    path: 'a.b.c',
                    value: { someConst: '$.value123' },
                });
                expect(undesiredVisitor).not.toHaveBeenCalled();
            });
        });
        test('returns the accumulator with changes made to it', () => {
            const countAccumulator = { count: 0 };
            const transformation = {
                a: {
                    b: 1,
                    '*': '$[0].a.b.c',
                },
            };
            const result = reduceTransformation(transformation, {
                accumulator: countAccumulator,
                visitors: {
                    NestedSpreadExpression: () => {
                        countAccumulator.count += 1;
                    },
                },
            });
            expect(result).toStrictEqual({ count: 1 });
        });
        // TODO: replace with returning the invalid value, for constant-transformation
        test('invokes the NestedUnsupportedTransformationExpression otherwise', () => {
            const visitorCallback = jest.fn();
            const unsupportedTransformationValue = aString();
            const transformation = {
                a: { b: { c: unsupportedTransformationValue } },
            };
            reduceTransformation(transformation, {
                visitors: {
                    NestedUnsupportedTransformationExpression: visitorCallback,
                },
                accumulator,
            });
            expect(visitorCallback).toHaveBeenCalledTimes(1);
            expect(visitorCallback).toHaveBeenCalledWith(accumulator, 'a.b.c', unsupportedTransformationValue);
        });
    });
    describe('mapping array items', () => {
        const visitorCallback = jest.fn();
        beforeEach(() => {
            visitorCallback.mockClear();
        });
        describe('top-level transformation', () => {
            test('invokes the TopLevelMapArrayItems visitor', () => {
                const transformation = {
                    '@path': '$.d.e.f',
                    '@itemTransformation': '$.g.h.i',
                };
                reduceTransformation(transformation, {
                    visitors: {
                        TopLevelMapArrayItems: visitorCallback,
                    },
                    accumulator: {},
                });
                expect(visitorCallback).toHaveBeenCalledTimes(1);
                expect(visitorCallback).toHaveBeenCalledWith('$.d.e.f', '$.g.h.i');
            });
        });
        describe('nested transformation', () => {
            const accumulator = {};
            const path = 'a.b.c';
            const withItemTransformation = (itemTransformation) => set({}, path, {
                '@path': '$.d.e.f',
                '@itemTransformation': itemTransformation,
            });
            describe('simple item-transformation', () => {
                test('invokes the MapArrayItems visitor', () => {
                    reduceTransformation(withItemTransformation('$.g.h.i'), {
                        visitors: {
                            MapArrayItems: visitorCallback,
                        },
                        accumulator,
                    });
                    expect(visitorCallback).toHaveBeenCalledTimes(1);
                    expect(visitorCallback).toHaveBeenCalledWith(accumulator, path, '$.d.e.f', '$.g.h.i');
                });
            });
            describe('complex item-transformation', () => {
                test('invokes the MapArrayItems visitor', () => {
                    const nestedSimpleTransformationVisitor = jest.fn();
                    reduceTransformation(withItemTransformation({ yyy: '$.g.h.i', zzz: '$.j.k.l' }), {
                        visitors: {
                            MapArrayItems: visitorCallback,
                            NestedSimpleTransformationExpression: nestedSimpleTransformationVisitor,
                        },
                        accumulator,
                    });
                    expect(visitorCallback).toHaveBeenCalledTimes(1);
                    expect(visitorCallback).toHaveBeenCalledWith(accumulator, path, '$.d.e.f', {
                        yyy: '$.g.h.i',
                        zzz: '$.j.k.l',
                    });
                    expect(nestedSimpleTransformationVisitor).not.toHaveBeenCalled();
                });
            });
        });
    });
    describe('omit notation', () => {
        const fieldsToOmit = times(2, () => aString());
        const visitorCallback = jest.fn();
        const sourcePathExpression = '$.d.e.f';
        const path = 'a.b.c';
        const accumulator = {};
        beforeEach(() => {
            visitorCallback.mockClear();
        });
        describe('top-level transformation', () => {
            test('invokes the TopLevelOmit visitor', () => {
                const transformation = {
                    '@source': sourcePathExpression,
                    '@omit': fieldsToOmit,
                };
                reduceTransformation(transformation, {
                    visitors: {
                        TopLevelOmit: visitorCallback,
                    },
                    accumulator,
                });
                expect(visitorCallback).toHaveBeenCalledTimes(1);
                expect(visitorCallback).toHaveBeenCalledWith(sourcePathExpression, fieldsToOmit);
            });
        });
        describe('nested transformation', () => {
            test('invokes the NestedOmit visitor', () => {
                const transformation = set({}, path, {
                    '@source': sourcePathExpression,
                    '@omit': fieldsToOmit,
                });
                reduceTransformation(transformation, {
                    visitors: {
                        NestedOmit: visitorCallback,
                    },
                    accumulator,
                });
                expect(visitorCallback).toHaveBeenCalledTimes(1);
                expect(visitorCallback).toHaveBeenCalledWith(accumulator, path, sourcePathExpression, fieldsToOmit);
            });
        });
    });
    describe('error handling', () => {
        describe.each `
      transformation                                       | visitorType
      ${'$.a.b.c'}                                         | ${'TopLevelSimpleTransformationExpression'}
      ${'#someCustomFunc($.a.b.c)'}                        | ${'TopLevelCustomFunctionExpression'}
      ${{ a: { b: { c: 'unsupported transformation' } } }} | ${'NestedUnsupportedTransformationExpression'}
      ${{ a: { b: { c: '$.d.e.f' } } }}                    | ${'NestedSimpleTransformationExpression'}
      ${{ '*': '$.d.e.f' }}                                | ${'TopLevelSpreadExpression'}
      ${{ a: { '*': '$.d.e.f' } }}                         | ${'NestedSpreadExpression'}
      ${{ a: { b: '#someCustomFunction($.d.e.f)' } }}      | ${'CustomFunctionExpression'}
    `('$visitor visitor', ({ transformation, visitorType }) => {
            test(`rethrows the error thrown by the ${visitorType} visitor`, () => {
                const errorMessage = aString();
                const error = new Error(errorMessage);
                const visitorCallback = jest.fn().mockImplementationOnce(() => {
                    throw error;
                });
                expect(() => reduceTransformation(transformation, {
                    visitors: {
                        [visitorType]: visitorCallback,
                    },
                })).toThrow(error);
            });
            test(`does not fail when the ${visitorType} visitor is missing`, () => {
                expect(() => reduceTransformation(transformation, {
                    visitors: {
                        [visitorType]: null,
                    },
                })).not.toThrow();
            });
        });
    });
});
//# sourceMappingURL=reduceTransformation.spec.js.map