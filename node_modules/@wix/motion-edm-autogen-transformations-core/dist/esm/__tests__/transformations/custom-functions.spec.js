import { aString } from '@wix/motion-runtime-test-context';
import { set, times } from 'lodash';
import { isFunctionCallExpression, parseCustomFunctionCall } from '../..';
import { runCustomFunctionCallExpression } from '../../lib/transformations/custom-functions';
describe('parseCustomFunctionCall', () => {
    /* eslint-disable max-len */
    test.each `
    argumentCount                            | argumentExpressions                      | expectedArgumentExpressions
    ${'a single argument'}                   | ${'$[0].some.path'}                      | ${['$[0].some.path']}
    ${'multiple arguments'}                  | ${'$[0].some.path,someString'}           | ${['$[0].some.path', 'someString']}
    ${'multiple arguments with whitespaces'} | ${'$[0].some.path,   someString , $[1]'} | ${['$[0].some.path', 'someString', '$[1]']}
    ${'no arguments'}                        | ${''}                                    | ${[]}
  `(
    /* eslint-enable max-len */
    'parses a custom-function call applied with $argumentCount', ({ argumentExpressions, expectedArgumentExpressions }) => {
        const functionName = aString();
        const functionExpression = `#${functionName}(${argumentExpressions})`;
        expect(parseCustomFunctionCall(functionExpression)).toStrictEqual({
            functionName,
            argumentExpressions: expectedArgumentExpressions,
        });
    });
});
describe('isFunctionCallExpression', () => {
    test.each `
    description                                      | expression                 | expectedResult
    ${'a #-prefixed with a valid function name'}     | ${'#someInvalidName$#@#>'} | ${true}
    ${'a non-# prefixed with a valid function name'} | ${'someFunctions($[1])'}   | ${false}
    ${'a non-string value'}                          | ${[1, 2, 3]}               | ${false}
  `('returns $expectedResult when $description function call expression is provided', ({ expression, expectedResult }) => {
        expect(isFunctionCallExpression(expression)).toStrictEqual(expectedResult);
    });
});
describe('runCustomFunctionCallExpression', () => {
    const value = aString();
    const transformationParentPath = aString();
    const joinWithDots = (...args) => args.join('|');
    describe.each `
    argumentCount | argumentValues    | expectedResult
    ${'single'}   | ${[value]}        | ${value}
    ${'multi'}    | ${[value, value]} | ${`${value}|${value}`}
    ${'no'}       | ${[]}             | ${''}
  `('$argumentCount-argument expression', ({ argumentValues, expectedResult }) => {
        describe.each `
        functionName                | description
        ${'someFunction'}           | ${'an unscoped'}
        ${'someScope.someFunction'} | ${'a scoped'}
      `('$description custom function', ({ functionName }) => {
            const customFunctions = set({}, functionName, joinWithDots);
            test('runs it and returns its result', () => {
                const result = runCustomFunctionCallExpression({
                    functionName,
                    customFunctions,
                    argumentValues,
                    transformationParentPath,
                });
                expect(result).toStrictEqual(expectedResult);
            });
        });
    });
    describe('error handling', () => {
        const argumentValues = times(2, () => aString());
        test('throws when the function is not recognized', () => {
            const customFunctions = {};
            expect(() => runCustomFunctionCallExpression({
                functionName: 'someNonexistentFunction',
                customFunctions,
                argumentValues,
                transformationParentPath,
            })).toThrow(`unrecognized custom function "someNonexistentFunction"`);
        });
        test('throws an error when the function call throws an error', () => {
            const functionName = aString();
            const customFunctions = {
                [functionName]: () => {
                    throw new Error('Something went wrong in the custom function');
                },
            };
            const t = () => runCustomFunctionCallExpression({
                functionName,
                customFunctions,
                argumentValues,
                transformationParentPath,
            });
            expect(t).toThrow(Error);
            expect(t).toThrow(new RegExp(`Transforming ${transformationParentPath} failed, #${functionName} threw: "Something went wrong in the custom function" for arguments: .+`));
        });
    });
});
//# sourceMappingURL=custom-functions.spec.js.map