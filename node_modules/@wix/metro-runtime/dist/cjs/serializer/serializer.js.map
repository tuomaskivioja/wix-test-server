{"version":3,"names":["_","require","schemaSerializer","rootSchema","depSchemas","converterSets","serialize","json","converterType","transformSchema","schema","payload","result","undefined","includes","Object","entries","forEach","key","val","_getConverter","renderedSchemaName","schemaName","schemaType","parseLeanSchemaRef","isMap","isRepeatable","getConverter","checkRepetable","Array","isArray","parsedValue","map","v","applyField","applyFieldOnMap","schemaOrSerializer","maybeSchema","maybeConverter","transform","Error","name","_converterSets$name","sanitizedSchemaOrSerializer","reduce","acc","propertyName","value"],"sources":["../../../src/serializer/serializer.ts"],"sourcesContent":["import type {\n  RenderedLeanSchemaFields,\n  RenderedLeanSchema,\n} from '@wix/metro-public-utils';\nimport { parseLeanSchemaRef } from '..';\nimport { ConverterType, Payload, TypeToConverterSet } from './domain';\n\nexport function schemaSerializer(\n  rootSchema: RenderedLeanSchemaFields,\n  depSchemas: RenderedLeanSchema = {},\n  converterSets: TypeToConverterSet,\n) {\n  return function serialize(\n    json: Payload = {},\n    converterType: ConverterType,\n  ): Payload {\n    return typeof json === 'string' ? json : transformSchema(rootSchema, json);\n\n    function transformSchema(\n      schema: RenderedLeanSchemaFields,\n      payload: any,\n    ): Payload {\n      const result = {} as Payload;\n      if ([null, undefined].includes(payload)) {\n        return payload;\n      }\n\n      Object.entries(payload).forEach(([key, val]) => {\n        const renderedSchemaName = schema[key];\n        const { schemaName, schemaType } =\n          parseLeanSchemaRef(renderedSchemaName);\n\n        const isMap = schemaType === 'Map';\n        const isRepeatable =\n          getConverter(schemaName)?.checkRepetable?.(val) ?? Array.isArray(val);\n\n        let parsedValue;\n\n        if (isRepeatable) {\n          parsedValue = (val as any[]).map((v) => applyField(v, schemaName));\n        } else if (isMap) {\n          parsedValue = applyFieldOnMap(val, schemaName);\n        } else {\n          parsedValue = applyField(val, schemaName);\n        }\n\n        result[key] = parsedValue;\n      });\n\n      return result;\n    }\n\n    function applyField(val: unknown, schemaOrSerializer?: string) {\n      if (!schemaOrSerializer) {\n        return val;\n      }\n\n      const maybeSchema = depSchemas[schemaOrSerializer];\n      const maybeConverter = getConverter(schemaOrSerializer);\n\n      if (maybeConverter) {\n        return getConverter(schemaOrSerializer).transform(val);\n      } else if (maybeSchema) {\n        return transformSchema(maybeSchema, val);\n      }\n\n      throw new Error(\n        `${schemaOrSerializer} is neither schema nor serializable type`,\n      );\n    }\n\n    function getConverter(name: string) {\n      return converterSets[name]?.[converterType];\n    }\n\n    function applyFieldOnMap(val: any, sanitizedSchemaOrSerializer: string) {\n      return Object.entries(val).reduce<Record<string, any>>(\n        (acc, [propertyName, value]) => {\n          acc[propertyName] = applyField(value, sanitizedSchemaOrSerializer);\n          return acc;\n        },\n        {},\n      );\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]}