import { builtinCustomFunctions } from '@wix/motion-edm-autogen-p13n';
import {
  transformResponseMessage,
  transformToRequestMessage,
} from '@wix/motion-edm-autogen-transformations';
import { ConverterType, Payload } from './serializer/domain';
import { protobufConverters } from './serializer/protobuf-converters/converters';
import { schemaSerializer } from './serializer/serializer';
import { typeToConverterSet } from './serializer/utils';
import { isUndefined, omitBy } from 'lodash';
import { veloConverters } from './serializer/velo-converters/converters';
import {
  RootPath,
  transformError,
  transformFqdn,
} from './transformation-handler';
import { SerializerParams } from './types';
import { resolveQueryFieldsTransformationPaths } from './query-transformation';
import { renameAllNestedKeys } from './rename-all-nested-keys';

const converters = typeToConverterSet([
  ...protobufConverters,
  ...veloConverters,
]);

export { RootPath, resolveQueryFieldsTransformationPaths, transformError };

export type { GoogleProtoDuration } from './serializer/protobuf-converters/types';

export type DomainEventMetadata = {
  id?: string;
  entityId?: string;
  eventTime?: string;
  triggeredByAnonymizeRequest?: boolean;
};

export type DeletedEvent = { deletedEntityAsJson?: object };

export type DomainEvent = {
  createdEvent?: { entityAsJson: object };
  updatedEvent?: { currentEntityAsJson: object };
  actionEvent?: { bodyAsJson: object };
  deletedEvent?: { deletedEntityAsJson?: object };
} & DomainEventMetadata;

export function extractDomainEventPayload(parsedDomainEvent: DomainEvent) {
  const event =
    parsedDomainEvent.createdEvent?.entityAsJson ||
    parsedDomainEvent.actionEvent?.bodyAsJson ||
    parsedDomainEvent.updatedEvent?.currentEntityAsJson ||
    parsedDomainEvent.deletedEvent?.deletedEntityAsJson;

  if (event) {
    return event;
  }

  throw new Error('Invalid Domain Event structure detected');
}

export function serializer({
  rootSchema,
  depSchemas,
  fqdnTransformation = { paths: [], transformation: '$' },
  customTransformation = '$',
}: SerializerParams) {
  const serialize = schemaSerializer(rootSchema, depSchemas, converters);

  return {
    toAmbassadorRequest(
      userInputArgs: any[],
      ignorePathsForKeyRenames: string[] = [],
    ): Payload {
      return omitBy(
        serialize(
          renameAllNestedKeys(
            transformToRequestMessage(
              userInputArgs,
              customTransformation,
              builtinCustomFunctions,
            ),
            {
              _id: 'id',
              _createdDate: 'createdDate',
              _updatedDate: 'updatedDate',
            },
            ignorePathsForKeyRenames,
          ),
          ConverterType.TO_JSON,
        ),
        isUndefined,
      );
    },

    fromJSON(json: Payload, ignorePathsForKeyRenames: string[] = []): Payload {
      const deserialized = serialize(json, ConverterType.FROM_JSON);

      const fqdnTransformed = transformFqdn(deserialized, fqdnTransformation);

      const fqdnTransformedWithRenamedKeys = renameAllNestedKeys(
        fqdnTransformed,
        {
          id: '_id',
          createdDate: '_createdDate',
          updatedDate: '_updatedDate',
        },
        ignorePathsForKeyRenames,
      );

      return transformResponseMessage(
        fqdnTransformedWithRenamedKeys,
        customTransformation,
        builtinCustomFunctions,
      );
    },

    toJSON(
      veloPayload: Payload,
      ignorePathsForKeyRenames: string[] = [],
    ): Payload {
      const deserialized = serialize(veloPayload, ConverterType.TO_JSON);

      return renameAllNestedKeys(
        transformToRequestMessage(
          deserialized,
          customTransformation,
          builtinCustomFunctions,
        ),
        {
          _id: 'id',
          _createdDate: 'createdDate',
          _updatedDate: 'updatedDate',
        },
        ignorePathsForKeyRenames,
      );
    },
  };
}
