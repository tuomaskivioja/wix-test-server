import { DEFAULT_LIMIT, ITEMS_RESULT_PROPERTY_NAME, PAGING_METADATA_RESULT_PROPERTY_NAME, SDKRequestToRESTRequestRenameMap, } from './constants.js';
import { and, not, or } from './query-filter.js';
import { CursorBasedIterator, OffsetBasedIterator } from './query-iterators.js';
export function queryBuilder(opts) {
    const createQueryBuilder = (query) => {
        return {
            query,
            async find() {
                try {
                    const request = opts.requestTransformer(opts.pagingMethod === 'CURSOR' &&
                        query.cursorPaging.cursor
                        ? {
                            cursorPaging: query.cursorPaging,
                        }
                        : query);
                    const response = await opts.func(request);
                    const { [ITEMS_RESULT_PROPERTY_NAME]: items, [PAGING_METADATA_RESULT_PROPERTY_NAME]: pagingMetadata, } = opts.responseTransformer(response);
                    if (opts.pagingMethod === 'OFFSET') {
                        const offsetQuery = query;
                        return new OffsetBasedIterator({
                            items: items ?? [],
                            fetchNextPage: () => {
                                return createQueryBuilder({
                                    ...offsetQuery,
                                    paging: {
                                        offset: offsetQuery.paging.offset + offsetQuery.paging.limit,
                                        limit: offsetQuery.paging.limit,
                                    },
                                }).find();
                            },
                            fetchPrevPage: () => {
                                return createQueryBuilder({
                                    ...query,
                                    paging: {
                                        offset: Math.max(offsetQuery.paging.offset - offsetQuery.paging.limit, 0),
                                        limit: offsetQuery.paging.limit,
                                    },
                                }).find();
                            },
                            offset: offsetQuery.paging.offset,
                            limit: offsetQuery.paging.limit,
                            totalCount: pagingMetadata?.total,
                            tooManyToCount: pagingMetadata?.tooManyToCount,
                            originQuery: this,
                        });
                    }
                    const paging = query.cursorPaging;
                    return new CursorBasedIterator({
                        items: items ?? [],
                        limit: paging.limit,
                        originQuery: this,
                        fetchNextPage: () => {
                            return createQueryBuilder({
                                ...query,
                                cursorPaging: {
                                    cursor: pagingMetadata?.cursors?.next ?? undefined,
                                    limit: paging.limit,
                                },
                            }).find();
                        },
                        fetchPrevPage: () => {
                            return createQueryBuilder({
                                ...query,
                                cursorPaging: {
                                    cursor: pagingMetadata?.cursors?.prev ?? undefined,
                                    limit: paging.limit,
                                },
                            }).find();
                        },
                        prevCursor: pagingMetadata?.cursors?.prev ?? undefined,
                        nextCursor: pagingMetadata?.cursors?.next ?? undefined,
                    });
                }
                catch (err) {
                    throw opts.errorTransformer(err);
                }
            },
            skipTo(cursor) {
                return createQueryBuilder({
                    ...query,
                    cursorPaging: {
                        cursor,
                        limit: query.cursorPaging.limit,
                    },
                });
            },
            eq(field, value) {
                const serializableValue = typeof value === 'undefined' ? null : value;
                const newFilter = {
                    [renameFieldByPaths(opts.transformationPaths, field)]: serializableValue,
                };
                return createQueryBuilder({
                    ...query,
                    filter: and(query.filter, newFilter),
                });
            },
            ne(field, value) {
                const serializableValue = typeof value === 'undefined' ? null : value;
                const newFilter = {
                    [renameFieldByPaths(opts.transformationPaths, field)]: {
                        $ne: serializableValue,
                    },
                };
                return createQueryBuilder({
                    ...query,
                    filter: and(query.filter, newFilter),
                });
            },
            ge(field, value) {
                const newFilter = {
                    [renameFieldByPaths(opts.transformationPaths, field)]: {
                        $gte: value,
                    },
                };
                return createQueryBuilder({
                    ...query,
                    filter: and(query.filter, newFilter),
                });
            },
            gt(field, value) {
                const newFilter = {
                    [renameFieldByPaths(opts.transformationPaths, field)]: { $gt: value },
                };
                return createQueryBuilder({
                    ...query,
                    filter: and(query.filter, newFilter),
                });
            },
            le(field, value) {
                const newFilter = {
                    [renameFieldByPaths(opts.transformationPaths, field)]: {
                        $lte: value,
                    },
                };
                return createQueryBuilder({
                    ...query,
                    filter: and(query.filter, newFilter),
                });
            },
            lt(field, value) {
                const newFilter = {
                    [renameFieldByPaths(opts.transformationPaths, field)]: { $lt: value },
                };
                return createQueryBuilder({
                    ...query,
                    filter: and(query.filter, newFilter),
                });
            },
            isNotEmpty(field) {
                return this.ne(field, null);
            },
            isEmpty(field) {
                return this.eq(field, null);
            },
            startsWith(field, value) {
                const newFilter = {
                    [renameFieldByPaths(opts.transformationPaths, field)]: {
                        $startsWith: value,
                    },
                };
                return createQueryBuilder({
                    ...query,
                    filter: and(query.filter, newFilter),
                });
            },
            endsWith(field, value) {
                const newFilter = {
                    [renameFieldByPaths(opts.transformationPaths, field)]: {
                        $endsWith: value,
                    },
                };
                return createQueryBuilder({
                    ...query,
                    filter: and(query.filter, newFilter),
                });
            },
            contains(field, value) {
                const newFilter = {
                    [renameFieldByPaths(opts.transformationPaths, field)]: {
                        $contains: value,
                    },
                };
                return createQueryBuilder({
                    ...query,
                    filter: and(query.filter, newFilter),
                });
            },
            hasSome(field, ...values) {
                const newFilter = {
                    [renameFieldByPaths(opts.transformationPaths, field)]: {
                        $hasSome: Array.isArray(values[0]) ? values[0] : values,
                    },
                };
                return createQueryBuilder({
                    ...query,
                    filter: and(query.filter, newFilter),
                });
            },
            hasAll(field, ...values) {
                const newFilter = {
                    [renameFieldByPaths(opts.transformationPaths, field)]: {
                        $hasAll: Array.isArray(values[0]) ? values[0] : values,
                    },
                };
                return createQueryBuilder({
                    ...query,
                    filter: and(query.filter, newFilter),
                });
            },
            between(field, from, to) {
                return this.ge(field, from).lt(field, to);
            },
            in(field, values) {
                const newFilter = {
                    [renameFieldByPaths(opts.transformationPaths, field)]: {
                        $in: values,
                    },
                };
                return createQueryBuilder({
                    ...query,
                    filter: and(query.filter, newFilter),
                });
            },
            exists(field, value = true) {
                const newFilter = {
                    [renameFieldByPaths(opts.transformationPaths, field)]: {
                        $exists: value,
                    },
                };
                return createQueryBuilder({
                    ...query,
                    filter: and(query.filter, newFilter),
                });
            },
            or(orQuery) {
                return createQueryBuilder({
                    ...query,
                    filter: or(query.filter, orQuery.query.filter),
                });
            },
            and(andQuery) {
                return createQueryBuilder({
                    ...query,
                    filter: and(query.filter, andQuery.query.filter),
                });
            },
            not(notQuery) {
                return createQueryBuilder({
                    ...query,
                    filter: not(notQuery.query.filter),
                });
            },
            ascending(...fieldNames) {
                return createQueryBuilder({
                    ...query,
                    sort: [
                        ...(query.sort ?? []),
                        ...fieldNames.map((fieldName) => ({
                            fieldName: renameFieldByPaths(opts.transformationPaths, fieldName),
                            order: 'ASC',
                        })),
                    ],
                });
            },
            descending(...fieldNames) {
                return createQueryBuilder({
                    ...query,
                    sort: [
                        ...(query.sort ?? []),
                        ...fieldNames.map((fieldName) => ({
                            fieldName: renameFieldByPaths(opts.transformationPaths, fieldName),
                            order: 'DESC',
                        })),
                    ],
                });
            },
            skip(offset) {
                return createQueryBuilder({
                    ...query,
                    paging: {
                        offset,
                        limit: 'limit' in query.paging
                            ? query.paging.limit
                            : DEFAULT_LIMIT,
                    },
                });
            },
            limit(limit) {
                if (opts.pagingMethod === 'CURSOR') {
                    const cursorQuery = query;
                    return createQueryBuilder({
                        ...query,
                        cursorPaging: {
                            limit,
                            cursor: 'cursor' in cursorQuery.cursorPaging
                                ? cursorQuery.cursorPaging.cursor
                                : undefined,
                        },
                    });
                }
                const offsetQuery = query;
                return createQueryBuilder({
                    ...query,
                    paging: {
                        limit,
                        offset: 'offset' in offsetQuery.paging ? offsetQuery.paging.offset : 0,
                    },
                });
            },
        };
    };
    return createQueryBuilder({
        filter: {},
        ...(opts.pagingMethod === 'OFFSET'
            ? { paging: { offset: 0, limit: DEFAULT_LIMIT } }
            : { cursorPaging: { limit: DEFAULT_LIMIT } }),
    });
}
function renameFieldByPaths(transformationPaths, fieldPath) {
    const transformationPath = Object.entries(transformationPaths).find(([path]) => path === fieldPath || fieldPath.startsWith(`${path}.`))?.[0];
    if (transformationPath) {
        return fieldPath.replace(transformationPath, transformationPaths[transformationPath]);
    }
    return fieldPath
        .split('.')
        .map((segment) => transformationPaths[segment] ??
        SDKRequestToRESTRequestRenameMap[segment] ??
        segment)
        .join('.');
}
