import { HttpResponse } from '@wix/sdk-types';
import { Filter } from './query-filter.js';
import { CursorBasedIterator, OffsetBasedIterator } from './query-iterators.js';
type Query<PagingMethod extends 'OFFSET' | 'CURSOR'> = {
    filter?: Filter;
    sort?: {
        fieldName: string;
        order: any;
    }[];
} & (PagingMethod extends 'OFFSET' ? {
    paging: OffsetPaging;
} : {
    cursorPaging: CursorPaging;
});
type OffsetPaging = {
    offset: number;
    limit: number;
};
type CursorPaging = {
    limit: number;
    cursor?: string;
};
export type QueryBuilder<Item, PagingMethod extends 'OFFSET' | 'CURSOR'> = {
    query: Query<PagingMethod>;
    eq(field: string, value: unknown): QueryBuilder<Item, PagingMethod>;
    ne(field: string, value: unknown): QueryBuilder<Item, PagingMethod>;
    ge(field: string, value: string | number | Date): QueryBuilder<Item, PagingMethod>;
    gt(field: string, value: string | number | Date): QueryBuilder<Item, PagingMethod>;
    le(field: string, value: string | number | Date): QueryBuilder<Item, PagingMethod>;
    lt(field: string, value: string | number | Date): QueryBuilder<Item, PagingMethod>;
    startsWith(field: string, value: string): QueryBuilder<Item, PagingMethod>;
    endsWith(field: string, value: string): QueryBuilder<Item, PagingMethod>;
    contains(field: string, value: string): QueryBuilder<Item, PagingMethod>;
    hasSome(field: string, ...values: (string | number | Date)[] | [(string | number | Date)[]]): QueryBuilder<Item, PagingMethod>;
    hasAll(field: string, ...values: (string | number | Date)[] | [(string | number | Date)[]]): QueryBuilder<Item, PagingMethod>;
    between<T extends string | number | Date>(field: string, from: T, to: T): QueryBuilder<Item, PagingMethod>;
    in(field: string, values: (string | number | Date)[]): QueryBuilder<Item, PagingMethod>;
    exists(field: string, value?: boolean): QueryBuilder<Item, PagingMethod>;
    isNotEmpty(field: string): QueryBuilder<Item, PagingMethod>;
    isEmpty(field: string): QueryBuilder<Item, PagingMethod>;
    or(orQuery: QueryBuilder<Item, PagingMethod>): QueryBuilder<Item, PagingMethod>;
    and(andQuery: QueryBuilder<Item, PagingMethod>): QueryBuilder<Item, PagingMethod>;
    not(notQuery: QueryBuilder<Item, PagingMethod>): QueryBuilder<Item, PagingMethod>;
    ascending(...fieldNames: string[]): QueryBuilder<Item, PagingMethod>;
    descending(...fieldNames: string[]): QueryBuilder<Item, PagingMethod>;
    skip(offset: number): QueryBuilder<Item, PagingMethod>;
    limit(limit: number): QueryBuilder<Item, PagingMethod>;
    find(): Promise<PagingMethod extends 'OFFSET' ? OffsetBasedIterator<Item> : CursorBasedIterator<Item>>;
    skipTo(cursor: unknown): QueryBuilder<Item, PagingMethod>;
};
export interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used, `returnTotalCount` is `true` in the request, and `tooManyToCount` is false. */
    total?: number | null;
    /** Whether the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
export interface Cursors {
    /** Cursor pointing to next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to previous page in the list of results. */
    prev?: string | null;
}
export declare function queryBuilder<TItem, PagingMethod extends 'OFFSET' | 'CURSOR', TRequest, TResponse>(opts: {
    func(payload: TRequest): Promise<HttpResponse<TResponse>>;
    requestTransformer(query: Query<PagingMethod>): TRequest;
    responseTransformer(response: HttpResponse<TResponse>): {
        items?: TItem[];
        pagingMetadata?: PagingMetadataV2;
    };
    errorTransformer(error: unknown): void;
    pagingMethod: PagingMethod;
    transformationPaths: Record<string, string>;
}): QueryBuilder<TItem, PagingMethod>;
export {};
