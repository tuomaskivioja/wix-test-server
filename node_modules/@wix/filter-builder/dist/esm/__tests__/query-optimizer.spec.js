import chai from 'chai';
import { optimisedQuery as optimised } from '../query-optimiser';
const expect = chai.expect;
describe('query optimisations', () => {
    describe('$and with single element', () => {
        testCase('gets unwrapped', { $and: [{ a: 1 }] }, { a: 1 });
    });
    describe('$and with object pieces', () => {
        testCase('gets unwrapped as object', { $and: [{ a: 1 }, { b: 2 }] }, { a: 1, b: 2 });
        testCase('remains if keys overlap', { $and: [{ a: 1 }, { b: 2 }, { a: 1 }] }, { $and: [{ a: 1 }, { b: 2 }, { a: 1 }] });
        testCase("nested operators don't get merged", { $and: [{ a: 1 }, { $lte: 4 }, { b: 2 }] }, { $and: [{ a: 1, b: 2 }, { $lte: 4 }] });
        it('merges empty objects', () => {
            const actualOutput = optimised({ $and: [{}, {}, {}] });
            expect(actualOutput).to.be.eql({});
        });
    });
    describe('empty $and', () => {
        testCase('is removed', { $and: [{ $and: [] }] }, {});
        testCase('is removed when nested', { $and: [{ $and: [] }] }, {});
    });
    describe('nested $and', () => {
        testCase('get flattened', {
            $and: [{ a: 1 }, { $and: [{ a: 1 }] }, { $and: [{ a: 1 }, { a: 1 }] }],
        }, { $and: [{ a: 1 }, { a: 1 }, { a: 1 }, { a: 1 }] });
    });
    describe('nested $or', () => {
        testCase('get flattened', { $or: [{ a: 1 }, { $or: [{ a: 1 }] }, { $or: [{ a: 1 }, { a: 1 }] }] }, { $or: [{ a: 1 }, { a: 1 }, { a: 1 }, { a: 1 }] });
    });
    describe('type compatibility', () => {
        testCase('maintains date objects', { x: [new Date('2020-01-01T00:00:00Z')] }, { x: [new Date('2020-01-01T00:00:00Z')] });
    });
});
function testCase(description, input, expectedOutput) {
    it(description, () => {
        const actualOutput = optimised(input);
        expect(actualOutput).to.be.eql(expectedOutput);
    });
}
//# sourceMappingURL=query-optimizer.spec.js.map